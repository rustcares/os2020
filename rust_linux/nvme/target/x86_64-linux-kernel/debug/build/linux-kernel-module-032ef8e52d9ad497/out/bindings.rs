/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const KERN_INFO: &'static [u8; 3usize] = b"\x016\0";
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EFAULT: u32 = 14;
pub const EINVAL: u32 = 22;
pub const ESPIPE: u32 = 29;
pub const O_NONBLOCK: u32 = 2048;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const FS_REQUIRES_DEV: u32 = 1;
pub const FS_BINARY_MOUNTDATA: u32 = 2;
pub const FS_HAS_SUBTYPE: u32 = 4;
pub const FS_USERNS_MOUNT: u32 = 8;
pub const FS_RENAME_DOES_D_MOVE: u32 = 32768;
pub const VERIFY_WRITE: u32 = 1;
pub const LINUX_VERSION_CODE: u32 = 266002;
pub type __u8 = c_types::c_uchar;
pub type __u16 = c_types::c_ushort;
pub type __s32 = c_types::c_int;
pub type __u32 = c_types::c_uint;
pub type __s64 = c_types::c_longlong;
pub type __u64 = c_types::c_ulonglong;
pub type s8 = c_types::c_schar;
pub type u8 = c_types::c_uchar;
pub type s16 = c_types::c_short;
pub type u16 = c_types::c_ushort;
pub type s32 = c_types::c_int;
pub type u32 = c_types::c_uint;
pub type s64 = c_types::c_longlong;
pub type u64 = c_types::c_ulonglong;
pub type __kernel_long_t = c_types::c_long;
pub type __kernel_ulong_t = c_types::c_ulong;
pub type __kernel_mode_t = c_types::c_uint;
pub type __kernel_pid_t = c_types::c_int;
pub type __kernel_uid32_t = c_types::c_uint;
pub type __kernel_gid32_t = c_types::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_loff_t = c_types::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = c_types::c_int;
pub type __kernel_clockid_t = c_types::c_int;
pub type __kernel_dev_t = __u32;
pub type dev_t = __kernel_dev_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = c_types::c_ushort;
pub type pid_t = __kernel_pid_t;
pub type clockid_t = __kernel_clockid_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type loff_t = __kernel_loff_t;
pub type sector_t = c_types::c_ulong;
pub type blkcnt_t = c_types::c_ulong;
pub type dma_addr_t = u64;
pub type gfp_t = c_types::c_uint;
pub type fmode_t = c_types::c_uint;
pub type phys_addr_t = u64;
pub type resource_size_t = phys_addr_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: c_types::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::core::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<atomic_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: c_types::c_long,
}
#[test]
fn bindgen_test_layout_atomic64_t() {
    assert_eq!(
        ::core::mem::size_of::<atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<atomic64_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic64_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::core::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::core::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for list_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_head),
            "::",
            stringify!(first)
        )
    );
}
impl Default for hlist_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(pprev)
        )
    );
}
impl Default for hlist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct callback_head - callback structure for use with RCU and task_work"]
#[doc = " @next: next update requests in a list"]
#[doc = " @func: actual update function to call after the grace period."]
#[doc = ""]
#[doc = " The struct is aligned to size of pointer. On most architectures it happens"]
#[doc = " naturally due ABI requirements, but some architectures (like CRIS) have"]
#[doc = " weird ABI and we need to ask it explicitly."]
#[doc = ""]
#[doc = " The alignment is required to guarantee that bit 0 of @next will be"]
#[doc = " clear under normal conditions -- as long as we use call_rcu(),"]
#[doc = " call_rcu_bh(), call_rcu_sched(), or call_srcu() to queue callback."]
#[doc = ""]
#[doc = " This guarantee is important for few reasons:"]
#[doc = "  - future call_rcu_lazy() will make use of lower bits in the pointer;"]
#[doc = "  - the structure shares storage spacer in struct page with @compound_head,"]
#[doc = "    which encode PageTail() in bit 0. The guarantee is needed to avoid"]
#[doc = "    false-positive PageTail()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
#[test]
fn bindgen_test_layout_callback_head() {
    assert_eq!(
        ::core::mem::size_of::<callback_head>(),
        16usize,
        concat!("Size of: ", stringify!(callback_head))
    );
    assert_eq!(
        ::core::mem::align_of::<callback_head>(),
        8usize,
        concat!("Alignment of ", stringify!(callback_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callback_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callback_head>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(func)
        )
    );
}
impl Default for callback_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_symbol {
    pub value: c_types::c_ulong,
    pub name: *const c_types::c_char,
}
#[test]
fn bindgen_test_layout_kernel_symbol() {
    assert_eq!(
        ::core::mem::size_of::<kernel_symbol>(),
        16usize,
        concat!("Size of: ", stringify!(kernel_symbol))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_symbol>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_symbol))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_symbol>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_symbol>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(name)
        )
    );
}
impl Default for kernel_symbol {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state,
    pub list: list_head,
    pub name: [c_types::c_char; 56usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const c_types::c_char,
    pub srcversion: *const c_types::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *const kernel_symbol,
    pub crcs: *const s32,
    pub num_syms: c_types::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: c_types::c_uint,
    pub num_gpl_syms: c_types::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const s32,
    pub unused_syms: *const kernel_symbol,
    pub unused_crcs: *const s32,
    pub num_unused_syms: c_types::c_uint,
    pub num_unused_gpl_syms: c_types::c_uint,
    pub unused_gpl_syms: *const kernel_symbol,
    pub unused_gpl_crcs: *const s32,
    pub sig_ok: bool_,
    pub async_probe_requested: bool_,
    pub gpl_future_syms: *const kernel_symbol,
    pub gpl_future_crcs: *const s32,
    pub num_gpl_future_syms: c_types::c_uint,
    pub num_exentries: c_types::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> c_types::c_int>,
    pub core_layout: module_layout,
    pub init_layout: module_layout,
    pub arch: mod_arch_specific,
    pub taints: c_types::c_ulong,
    pub num_bugs: c_types::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut c_types::c_char,
    pub percpu: *mut c_types::c_void,
    pub percpu_size: c_types::c_uint,
    pub num_tracepoints: c_types::c_uint,
    pub tracepoints_ptrs: *const *mut tracepoint,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: c_types::c_uint,
    pub num_trace_bprintk_fmt: c_types::c_uint,
    pub trace_bprintk_fmt_start: *mut *const c_types::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: c_types::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: c_types::c_uint,
    pub num_ftrace_callsites: c_types::c_uint,
    pub ftrace_callsites: *mut c_types::c_ulong,
    pub klp: bool_,
    pub klp_alive: bool_,
    pub klp_info: *mut klp_modinfo,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
}
#[test]
fn bindgen_test_layout_module() {
    assert_eq!(
        ::core::mem::size_of::<module>(),
        832usize,
        concat!("Size of: ", stringify!(module))
    );
    assert_eq!(
        ::core::mem::align_of::<module>(),
        64usize,
        concat!("Alignment of ", stringify!(module))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).mkobj as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(mkobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).modinfo_attrs as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(modinfo_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).version as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).srcversion as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(srcversion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).holders_dir as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(holders_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).syms as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).crcs as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_syms as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).param_lock as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(param_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).kp as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_kp as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_gpl_syms as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_syms as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_crcs as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_syms as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_crcs as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_unused_syms as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_unused_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_unused_gpl_syms as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_unused_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_gpl_syms as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_gpl_crcs as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_gpl_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).sig_ok as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(sig_ok)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).async_probe_requested as *const _ as usize },
        337usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(async_probe_requested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_future_syms as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_future_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_future_crcs as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_future_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_gpl_future_syms as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_gpl_future_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_exentries as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_exentries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).extable as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(extable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).init as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).core_layout as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(core_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).init_layout as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(init_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).arch as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).taints as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(taints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_bugs as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_bugs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).bug_list as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(bug_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).bug_table as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(bug_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).kallsyms as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(kallsyms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).core_kallsyms as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(core_kallsyms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).sect_attrs as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(sect_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).notes_attrs as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(notes_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).args as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).percpu as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(percpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).percpu_size as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(percpu_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_tracepoints as *const _ as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_tracepoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).tracepoints_ptrs as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(tracepoints_ptrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).jump_entries as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(jump_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_jump_entries as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_jump_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_bprintk_fmt as *const _ as usize },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_bprintk_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_bprintk_fmt_start as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_bprintk_fmt_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_events as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_events as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_evals as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_evals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_evals as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_evals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_ftrace_callsites as *const _ as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_ftrace_callsites)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).ftrace_callsites as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(ftrace_callsites)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp_alive as *const _ as usize },
        729usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp_alive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp_info as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).source_list as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(source_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).target_list as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(target_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).exit as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(exit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).refcnt as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(refcnt)
        )
    );
}
impl Default for module {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut __this_module: module;
}
extern "C" {
    pub fn printk(fmt: *const c_types::c_char, ...) -> c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: c_types::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_static_key__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<static_key__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(static_key__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<static_key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).entries as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
impl Default for static_key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_static_key() {
    assert_eq!(
        ::core::mem::size_of::<static_key>(),
        16usize,
        concat!("Size of: ", stringify!(static_key))
    );
    assert_eq!(
        ::core::mem::align_of::<static_key>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<static_key>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key),
            "::",
            stringify!(enabled)
        )
    );
}
impl Default for static_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type jump_label_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct jump_entry {
    pub code: jump_label_t,
    pub target: jump_label_t,
    pub key: jump_label_t,
}
#[test]
fn bindgen_test_layout_jump_entry() {
    assert_eq!(
        ::core::mem::size_of::<jump_entry>(),
        24usize,
        concat!("Size of: ", stringify!(jump_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<jump_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(jump_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).target as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: c_types::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut c_types::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const c_types::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iterate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> c_types::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> c_types::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> c_types::c_uint,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_uint,
            arg3: c_types::c_ulong,
        ) -> c_types::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_uint,
            arg3: c_types::c_ulong,
        ) -> c_types::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> c_types::c_int,
    >,
    pub mmap_supported_flags: c_types::c_ulong,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> c_types::c_int,
    >,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> c_types::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> c_types::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: c_types::c_int,
            arg2: *mut file,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_int,
            arg3: *mut file_lock,
        ) -> c_types::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut page,
            arg3: c_types::c_int,
            arg4: usize,
            arg5: *mut loff_t,
            arg6: c_types::c_int,
        ) -> isize,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_ulong,
            arg3: c_types::c_ulong,
            arg4: c_types::c_ulong,
            arg5: c_types::c_ulong,
        ) -> c_types::c_ulong,
    >,
    pub check_flags:
        ::core::option::Option<unsafe extern "C" fn(arg1: c_types::c_int) -> c_types::c_int>,
    pub setfl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: c_types::c_ulong) -> c_types::c_int,
    >,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_int,
            arg3: *mut file_lock,
        ) -> c_types::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: c_types::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: c_types::c_uint,
        ) -> isize,
    >,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_long,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: c_types::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> c_types::c_long,
    >,
    pub show_fdinfo: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: c_types::c_uint,
        ) -> isize,
    >,
    pub clone_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: u64,
        ) -> c_types::c_int,
    >,
    pub dedupe_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: u64,
            arg3: u64,
            arg4: *mut file,
            arg5: u64,
        ) -> isize,
    >,
}
#[test]
fn bindgen_test_layout_file_operations() {
    assert_eq!(
        ::core::mem::size_of::<file_operations>(),
        256usize,
        concat!("Size of: ", stringify!(file_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<file_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(file_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).llseek as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(llseek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).write as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).read_iter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(read_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).write_iter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(write_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).iterate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iterate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).iterate_shared as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iterate_shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).poll as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).unlocked_ioctl as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(unlocked_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).compat_ioctl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(compat_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).mmap as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).mmap_supported_flags as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(mmap_supported_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).open as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).flush as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).release as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fsync as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fasync as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fasync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).lock as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).sendpage as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(sendpage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).get_unmapped_area as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(get_unmapped_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).check_flags as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(check_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).setfl as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(setfl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).flock as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(flock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).splice_write as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(splice_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).splice_read as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(splice_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).setlease as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(setlease)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fallocate as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fallocate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).show_fdinfo as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(show_fdinfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).copy_file_range as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(copy_file_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).clone_file_range as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(clone_file_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).dedupe_file_range as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(dedupe_file_range)
        )
    );
}
impl Default for file_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8,
    pub pending: u8,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).locked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).pending as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16,
    pub tail: u16,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).locked_pending
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(locked_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).tail as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qspinlock__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
impl Default for qspinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock))
    );
}
impl Default for qspinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8,
    pub __lstate: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).wlocked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(wlocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).__lstate as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__lstate)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qrwlock__bindgen_ty_1>())).cnts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1),
            "::",
            stringify!(cnts)
        )
    );
}
impl Default for qrwlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qrwlock() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock>(),
        8usize,
        concat!("Size of: ", stringify!(qrwlock))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qrwlock>())).wait_lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock),
            "::",
            stringify!(wait_lock)
        )
    );
}
impl Default for qrwlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lock_class_key {}
#[test]
fn bindgen_test_layout_lock_class_key() {
    assert_eq!(
        ::core::mem::size_of::<lock_class_key>(),
        0usize,
        concat!("Size of: ", stringify!(lock_class_key))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_class_key>(),
        1usize,
        concat!("Alignment of ", stringify!(lock_class_key))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lockdep_map {}
#[test]
fn bindgen_test_layout_lockdep_map() {
    assert_eq!(
        ::core::mem::size_of::<lockdep_map>(),
        0usize,
        concat!("Size of: ", stringify!(lockdep_map))
    );
    assert_eq!(
        ::core::mem::align_of::<lockdep_map>(),
        1usize,
        concat!("Alignment of ", stringify!(lockdep_map))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(raw_spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_spinlock),
            "::",
            stringify!(raw_lock)
        )
    );
}
impl Default for raw_spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock__bindgen_ty_1),
            "::",
            stringify!(rlock)
        )
    );
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock))
    );
}
impl Default for spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
#[test]
fn bindgen_test_layout_rwlock_t() {
    assert_eq!(
        ::core::mem::size_of::<rwlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rwlock_t>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rwlock_t),
            "::",
            stringify!(raw_lock)
        )
    );
}
impl Default for rwlock_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pt_regs {
    pub r15: c_types::c_ulong,
    pub r14: c_types::c_ulong,
    pub r13: c_types::c_ulong,
    pub r12: c_types::c_ulong,
    pub bp: c_types::c_ulong,
    pub bx: c_types::c_ulong,
    pub r11: c_types::c_ulong,
    pub r10: c_types::c_ulong,
    pub r9: c_types::c_ulong,
    pub r8: c_types::c_ulong,
    pub ax: c_types::c_ulong,
    pub cx: c_types::c_ulong,
    pub dx: c_types::c_ulong,
    pub si: c_types::c_ulong,
    pub di: c_types::c_ulong,
    pub orig_ax: c_types::c_ulong,
    pub ip: c_types::c_ulong,
    pub cs: c_types::c_ulong,
    pub flags: c_types::c_ulong,
    pub sp: c_types::c_ulong,
    pub ss: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(
        ::core::mem::size_of::<pt_regs>(),
        168usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<pt_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).bp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).bx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r11 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r10 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r9 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ax as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).cx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).si as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).di as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).orig_ax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(orig_ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).cs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).flags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).sp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ss as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone)]
pub struct desc_struct {
    pub _bindgen_opaque_blob: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_desc_struct() {
    assert_eq!(
        ::core::mem::size_of::<desc_struct>(),
        8usize,
        concat!("Size of: ", stringify!(desc_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<desc_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_struct))
    );
}
pub type pteval_t = c_types::c_ulong;
pub type pmdval_t = c_types::c_ulong;
pub type pudval_t = c_types::c_ulong;
pub type pgdval_t = c_types::c_ulong;
pub type pgprotval_t = c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[test]
fn bindgen_test_layout_pte_t() {
    assert_eq!(
        ::core::mem::size_of::<pte_t>(),
        8usize,
        concat!("Size of: ", stringify!(pte_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pte_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pte_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pte_t>())).pte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pte_t),
            "::",
            stringify!(pte)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
#[test]
fn bindgen_test_layout_pgprot() {
    assert_eq!(
        ::core::mem::size_of::<pgprot>(),
        8usize,
        concat!("Size of: ", stringify!(pgprot))
    );
    assert_eq!(
        ::core::mem::align_of::<pgprot>(),
        8usize,
        concat!("Alignment of ", stringify!(pgprot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pgprot>())).pgprot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgprot),
            "::",
            stringify!(pgprot)
        )
    );
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[test]
fn bindgen_test_layout_pgd_t() {
    assert_eq!(
        ::core::mem::size_of::<pgd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pgd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pgd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pgd_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pgd_t>())).pgd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgd_t),
            "::",
            stringify!(pgd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
#[test]
fn bindgen_test_layout_pud_t() {
    assert_eq!(
        ::core::mem::size_of::<pud_t>(),
        8usize,
        concat!("Size of: ", stringify!(pud_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pud_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pud_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pud_t>())).pud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pud_t),
            "::",
            stringify!(pud)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[test]
fn bindgen_test_layout_pmd_t() {
    assert_eq!(
        ::core::mem::size_of::<pmd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pmd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pmd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pmd_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmd_t>())).pmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmd_t),
            "::",
            stringify!(pmd)
        )
    );
}
pub type pgtable_t = *mut page;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: c_types::c_long,
    pub regs: *mut pt_regs,
}
#[test]
fn bindgen_test_layout_math_emu_info() {
    assert_eq!(
        ::core::mem::size_of::<math_emu_info>(),
        16usize,
        concat!("Size of: ", stringify!(math_emu_info))
    );
    assert_eq!(
        ::core::mem::align_of::<math_emu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(math_emu_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<math_emu_info>())).___orig_eip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(___orig_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<math_emu_info>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(regs)
        )
    );
}
impl Default for math_emu_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: c_types::c_int,
    pub file_disp: c_types::c_int,
    pub line: c_types::c_ushort,
    pub flags: c_types::c_ushort,
}
#[test]
fn bindgen_test_layout_bug_entry() {
    assert_eq!(
        ::core::mem::size_of::<bug_entry>(),
        12usize,
        concat!("Size of: ", stringify!(bug_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<bug_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(bug_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).bug_addr_disp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(bug_addr_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).file_disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(file_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpumask {
    pub bits: [c_types::c_ulong; 128usize],
}
#[test]
fn bindgen_test_layout_cpumask() {
    assert_eq!(
        ::core::mem::size_of::<cpumask>(),
        1024usize,
        concat!("Size of: ", stringify!(cpumask))
    );
    assert_eq!(
        ::core::mem::align_of::<cpumask>(),
        8usize,
        concat!("Alignment of ", stringify!(cpumask))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpumask>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpumask),
            "::",
            stringify!(bits)
        )
    );
}
impl Default for cpumask {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cpumask_t = cpumask;
pub type cpumask_var_t = *mut cpumask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut c_types::c_void,
    pub data: *mut c_types::c_void,
    pub prio: c_types::c_int,
}
#[test]
fn bindgen_test_layout_tracepoint_func() {
    assert_eq!(
        ::core::mem::size_of::<tracepoint_func>(),
        24usize,
        concat!("Size of: ", stringify!(tracepoint_func))
    );
    assert_eq!(
        ::core::mem::align_of::<tracepoint_func>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint_func))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint_func>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint_func>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint_func>())).prio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(prio)
        )
    );
}
impl Default for tracepoint_func {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const c_types::c_char,
    pub key: static_key,
    pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> c_types::c_int>,
    pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
#[test]
fn bindgen_test_layout_tracepoint() {
    assert_eq!(
        ::core::mem::size_of::<tracepoint>(),
        48usize,
        concat!("Size of: ", stringify!(tracepoint))
    );
    assert_eq!(
        ::core::mem::align_of::<tracepoint>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).regfunc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(regfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).unregfunc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(unregfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).funcs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(funcs)
        )
    );
}
impl Default for tracepoint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32,
    pub swd: u32,
    pub twd: u32,
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
    pub st_space: [u32; 20usize],
    pub status: u32,
}
#[test]
fn bindgen_test_layout_fregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fregs_state>(),
        112usize,
        concat!("Size of: ", stringify!(fregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fregs_state>(),
        4usize,
        concat!("Alignment of ", stringify!(fregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16,
    pub swd: u16,
    pub twd: u16,
    pub fop: u16,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32,
    pub mxcsr_mask: u32,
    pub st_space: [u32; 32usize],
    pub xmm_space: [u32; 64usize],
    pub padding: [u32; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64,
    pub rdp: u64,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rdp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fcs as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).foo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fos as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fos)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_1))
    );
}
impl Default for fxregs_state__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32; 12usize],
    pub sw_reserved: [u32; 12usize],
    _bindgen_union_align: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_2>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
impl Default for fxregs_state__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_fxregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state>(),
        512usize,
        concat!("Size of: ", stringify!(fxregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state>(),
        16usize,
        concat!("Alignment of ", stringify!(fxregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(padding)
        )
    );
}
impl Default for fxregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32,
    pub swd: u32,
    pub twd: u32,
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
    pub st_space: [u32; 20usize],
    pub ftop: u8,
    pub changed: u8,
    pub lookahead: u8,
    pub no_update: u8,
    pub rm: u8,
    pub alimit: u8,
    pub info: *mut math_emu_info,
    pub entry_eip: u32,
}
#[test]
fn bindgen_test_layout_swregs_state() {
    assert_eq!(
        ::core::mem::size_of::<swregs_state>(),
        136usize,
        concat!("Size of: ", stringify!(swregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<swregs_state>(),
        8usize,
        concat!("Alignment of ", stringify!(swregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).ftop as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(ftop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).changed as *const _ as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).lookahead as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(lookahead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).no_update as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(no_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).rm as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).alimit as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(alimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).info as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).entry_eip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(entry_eip)
        )
    );
}
impl Default for swregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct xregs_state {
    pub _bindgen_opaque_blob: [u8; 576usize],
}
#[test]
fn bindgen_test_layout_xregs_state() {
    assert_eq!(
        ::core::mem::size_of::<xregs_state>(),
        576usize,
        concat!("Size of: ", stringify!(xregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<xregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(xregs_state))
    );
}
impl Default for xregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8; 4096usize]>,
    pub bindgen_union_field: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_fpregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fpregs_state>(),
        4096usize,
        concat!("Size of: ", stringify!(fpregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fpregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(fpregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).fsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).fxsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fxsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).soft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).xsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(xsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).__padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(__padding)
        )
    );
}
impl Default for fpregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct fpu {
    pub last_cpu: c_types::c_uint,
    pub initialized: c_types::c_uchar,
    pub __bindgen_padding_0: [u64; 7usize],
    pub state: fpregs_state,
}
#[test]
fn bindgen_test_layout_fpu() {
    assert_eq!(
        ::core::mem::size_of::<fpu>(),
        4160usize,
        concat!("Size of: ", stringify!(fpu))
    );
    assert_eq!(
        ::core::mem::align_of::<fpu>(),
        64usize,
        concat!("Alignment of ", stringify!(fpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).last_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(last_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).initialized as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).state as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(state)
        )
    );
}
impl Default for fpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seq_operations {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, pos: *mut loff_t) -> *mut c_types::c_void,
    >,
    pub stop:
        ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, v: *mut c_types::c_void)>,
    pub next: ::core::option::Option<
        unsafe extern "C" fn(
            m: *mut seq_file,
            v: *mut c_types::c_void,
            pos: *mut loff_t,
        ) -> *mut c_types::c_void,
    >,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, v: *mut c_types::c_void) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_seq_operations() {
    assert_eq!(
        ::core::mem::size_of::<seq_operations>(),
        32usize,
        concat!("Size of: ", stringify!(seq_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<seq_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(seq_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_operations>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_operations),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_operations>())).stop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_operations),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_operations>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_operations),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_operations>())).show as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_operations),
            "::",
            stringify!(show)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mm_segment_t {
    pub seg: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_mm_segment_t() {
    assert_eq!(
        ::core::mem::size_of::<mm_segment_t>(),
        8usize,
        concat!("Size of: ", stringify!(mm_segment_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_segment_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_segment_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_segment_t>())).seg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_segment_t),
            "::",
            stringify!(seg)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: c_types::c_ulong,
    pub es: c_types::c_ushort,
    pub ds: c_types::c_ushort,
    pub fsindex: c_types::c_ushort,
    pub gsindex: c_types::c_ushort,
    pub fsbase: c_types::c_ulong,
    pub gsbase: c_types::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub debugreg6: c_types::c_ulong,
    pub ptrace_dr7: c_types::c_ulong,
    pub cr2: c_types::c_ulong,
    pub trap_nr: c_types::c_ulong,
    pub error_code: c_types::c_ulong,
    pub io_bitmap_ptr: *mut c_types::c_ulong,
    pub iopl: c_types::c_ulong,
    pub io_bitmap_max: c_types::c_uint,
    pub addr_limit: mm_segment_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u64; 3usize],
    pub fpu: fpu,
}
#[test]
fn bindgen_test_layout_thread_struct() {
    assert_eq!(
        ::core::mem::size_of::<thread_struct>(),
        4352usize,
        concat!("Size of: ", stringify!(thread_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(thread_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).tls_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(tls_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).sp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).es as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ds as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fsindex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).gsindex as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fsbase as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).gsbase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ptrace_bps as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).debugreg6 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(debugreg6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ptrace_dr7 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_dr7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).cr2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).trap_nr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).error_code as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).io_bitmap_ptr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).iopl as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(iopl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).io_bitmap_max as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).addr_limit as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(addr_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fpu as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fpu)
        )
    );
}
impl Default for thread_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl thread_struct {
    #[inline]
    pub fn sig_on_uaccess_err(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_on_uaccess_err(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uaccess_err(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uaccess_err(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sig_on_uaccess_err: c_types::c_uint,
        uaccess_err: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sig_on_uaccess_err: u32 = unsafe { ::core::mem::transmute(sig_on_uaccess_err) };
            sig_on_uaccess_err as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let uaccess_err: u32 = unsafe { ::core::mem::transmute(uaccess_err) };
            uaccess_err as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[test]
fn bindgen_test_layout_optimistic_spin_queue() {
    assert_eq!(
        ::core::mem::size_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Size of: ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<optimistic_spin_queue>())).tail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_queue),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_mutex() {
    assert_eq!(
        ::core::mem::size_of::<mutex>(),
        32usize,
        concat!("Size of: ", stringify!(mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).wait_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).osq as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).wait_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_list)
        )
    );
}
impl Default for mutex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compat_timespec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub fn_:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut restart_block) -> c_types::c_long>,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32,
    pub val: u32,
    pub flags: u32,
    pub bitset: u32,
    pub time: u64,
    pub uaddr2: *mut u32,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).val as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).bitset
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).time as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr2
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr2)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut timespec,
    pub compat_rmtp: *mut compat_timespec,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rmtp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .compat_rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(compat_rmtp)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).clockid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).type_ as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).expires
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(expires)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: c_types::c_int,
    pub has_timeout: c_types::c_int,
    pub tv_sec: c_types::c_ulong,
    pub tv_nsec: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).ufds as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ufds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).nfds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).has_timeout
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(has_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_sec
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_nsec
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_nsec)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).futex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).nanosleep as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(nanosleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).poll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(poll)
        )
    );
}
impl Default for restart_block__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block() {
    assert_eq!(
        ::core::mem::size_of::<restart_block>(),
        48usize,
        concat!("Size of: ", stringify!(restart_block))
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<restart_block>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block),
            "::",
            stringify!(fn_)
        )
    );
}
impl Default for restart_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct thread_info {
    pub flags: c_types::c_ulong,
    pub status: u32,
}
#[test]
fn bindgen_test_layout_thread_info() {
    assert_eq!(
        ::core::mem::size_of::<thread_info>(),
        16usize,
        concat!("Size of: ", stringify!(thread_info))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_info>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_info>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_node {
    pub shift: c_types::c_uchar,
    pub offset: c_types::c_uchar,
    pub count: c_types::c_uchar,
    pub exceptional: c_types::c_uchar,
    pub parent: *mut radix_tree_node,
    pub root: *mut radix_tree_root,
    pub __bindgen_anon_1: radix_tree_node__bindgen_ty_1,
    pub slots: [*mut c_types::c_void; 64usize],
    pub tags: [[c_types::c_ulong; 1usize]; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union radix_tree_node__bindgen_ty_1 {
    pub private_list: list_head,
    pub callback_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_radix_tree_node__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<radix_tree_node__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(radix_tree_node__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<radix_tree_node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(radix_tree_node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<radix_tree_node__bindgen_ty_1>())).private_list as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node__bindgen_ty_1),
            "::",
            stringify!(private_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<radix_tree_node__bindgen_ty_1>())).callback_head as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node__bindgen_ty_1),
            "::",
            stringify!(callback_head)
        )
    );
}
impl Default for radix_tree_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_radix_tree_node() {
    assert_eq!(
        ::core::mem::size_of::<radix_tree_node>(),
        576usize,
        concat!("Size of: ", stringify!(radix_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<radix_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(radix_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).shift as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).offset as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).count as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).exceptional as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(exceptional)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).slots as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).tags as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(tags)
        )
    );
}
impl Default for radix_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radix_tree_root {
    pub gfp_mask: gfp_t,
    pub rnode: *mut radix_tree_node,
}
#[test]
fn bindgen_test_layout_radix_tree_root() {
    assert_eq!(
        ::core::mem::size_of::<radix_tree_root>(),
        16usize,
        concat!("Size of: ", stringify!(radix_tree_root))
    );
    assert_eq!(
        ::core::mem::align_of::<radix_tree_root>(),
        8usize,
        concat!("Alignment of ", stringify!(radix_tree_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_root>())).gfp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_root),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_root>())).rnode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_root),
            "::",
            stringify!(rnode)
        )
    );
}
impl Default for radix_tree_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type wait_queue_entry_t = wait_queue_entry;
pub type wait_queue_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        wq_entry: *mut wait_queue_entry,
        mode: c_types::c_uint,
        flags: c_types::c_int,
        key: *mut c_types::c_void,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_queue_entry {
    pub flags: c_types::c_uint,
    pub private: *mut c_types::c_void,
    pub func: wait_queue_func_t,
    pub entry: list_head,
}
#[test]
fn bindgen_test_layout_wait_queue_entry() {
    assert_eq!(
        ::core::mem::size_of::<wait_queue_entry>(),
        40usize,
        concat!("Size of: ", stringify!(wait_queue_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<wait_queue_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_entry>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_entry>())).private as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_entry>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_entry>())).entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(entry)
        )
    );
}
impl Default for wait_queue_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
#[test]
fn bindgen_test_layout_wait_queue_head() {
    assert_eq!(
        ::core::mem::size_of::<wait_queue_head>(),
        24usize,
        concat!("Size of: ", stringify!(wait_queue_head))
    );
    assert_eq!(
        ::core::mem::align_of::<wait_queue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_head>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_head>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(head)
        )
    );
}
impl Default for wait_queue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type wait_queue_head_t = wait_queue_head;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seqcount {
    pub sequence: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_seqcount() {
    assert_eq!(
        ::core::mem::size_of::<seqcount>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount))
    );
    assert_eq!(
        ::core::mem::align_of::<seqcount>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seqcount>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount),
            "::",
            stringify!(sequence)
        )
    );
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [c_types::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout_nodemask_t() {
    assert_eq!(
        ::core::mem::size_of::<nodemask_t>(),
        128usize,
        concat!("Size of: ", stringify!(nodemask_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nodemask_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nodemask_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nodemask_t>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_t),
            "::",
            stringify!(bits)
        )
    );
}
pub type isolate_mode_t = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub wait_list: list_head,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub owner: *mut task_struct,
}
#[test]
fn bindgen_test_layout_rw_semaphore() {
    assert_eq!(
        ::core::mem::size_of::<rw_semaphore>(),
        40usize,
        concat!("Size of: ", stringify!(rw_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).wait_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).wait_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).osq as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(owner)
        )
    );
}
impl Default for rw_semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __kernel_time_t,
    pub tv_nsec: c_types::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type time64_t = __s64;
pub type ktime_t = s64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: c_types::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_timer_list() {
    assert_eq!(
        ::core::mem::size_of::<timer_list>(),
        40usize,
        concat!("Size of: ", stringify!(timer_list))
    );
    assert_eq!(
        ::core::mem::align_of::<timer_list>(),
        8usize,
        concat!("Alignment of ", stringify!(timer_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_list>())).entry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_list>())).expires as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_list>())).function as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_list>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for timer_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
#[test]
fn bindgen_test_layout_work_struct() {
    assert_eq!(
        ::core::mem::size_of::<work_struct>(),
        32usize,
        concat!("Size of: ", stringify!(work_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<work_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(work_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(func)
        )
    );
}
impl Default for work_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: c_types::c_int,
}
#[test]
fn bindgen_test_layout_delayed_work() {
    assert_eq!(
        ::core::mem::size_of::<delayed_work>(),
        88usize,
        concat!("Size of: ", stringify!(delayed_work))
    );
    assert_eq!(
        ::core::mem::align_of::<delayed_work>(),
        8usize,
        concat!("Alignment of ", stringify!(delayed_work))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_work>())).timer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_work>())).wq as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_work>())).cpu as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(cpu)
        )
    );
}
impl Default for delayed_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
#[test]
fn bindgen_test_layout_rcu_work() {
    assert_eq!(
        ::core::mem::size_of::<rcu_work>(),
        56usize,
        concat!("Size of: ", stringify!(rcu_work))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_work>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_work))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_work>())).rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_work>())).wq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(wq)
        )
    );
}
impl Default for rcu_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [c_types::c_ulong; 4usize],
    pub len: c_types::c_long,
    pub len_lazy: c_types::c_long,
}
#[test]
fn bindgen_test_layout_rcu_segcblist() {
    assert_eq!(
        ::core::mem::size_of::<rcu_segcblist>(),
        88usize,
        concat!("Size of: ", stringify!(rcu_segcblist))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_segcblist>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_segcblist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).tails as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(tails)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).gp_seq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(gp_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).len_lazy as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(len_lazy)
        )
    );
}
impl Default for rcu_segcblist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: c_types::c_uint,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_completion() {
    assert_eq!(
        ::core::mem::size_of::<completion>(),
        32usize,
        concat!("Size of: ", stringify!(completion))
    );
    assert_eq!(
        ::core::mem::align_of::<completion>(),
        8usize,
        concat!("Alignment of ", stringify!(completion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<completion>())).done as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<completion>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(wait)
        )
    );
}
impl Default for completion {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [c_types::c_ulong; 2usize],
    pub srcu_unlock_count: [c_types::c_ulong; 2usize],
    pub __bindgen_padding_0: [u32; 8usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: c_types::c_ulong,
    pub srcu_gp_seq_needed_exp: c_types::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub work: delayed_work,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: c_types::c_ulong,
    pub cpu: c_types::c_int,
    pub sp: *mut srcu_struct,
}
#[test]
fn bindgen_test_layout_srcu_data() {
    assert_eq!(
        ::core::mem::size_of::<srcu_data>(),
        320usize,
        concat!("Size of: ", stringify!(srcu_data))
    );
    assert_eq!(
        ::core::mem::align_of::<srcu_data>(),
        64usize,
        concat!("Alignment of ", stringify!(srcu_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_lock_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_lock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_unlock_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_unlock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_cblist as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_cblist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_gp_seq_needed as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_gp_seq_needed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_data>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_cblist_invoking as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_cblist_invoking)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).work as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_barrier_head as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_barrier_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).mynode as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(mynode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).grpmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(grpmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).cpu as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).sp as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(sp)
        )
    );
}
impl Default for srcu_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [c_types::c_ulong; 4usize],
    pub srcu_data_have_cbs: [c_types::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: c_types::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: c_types::c_int,
    pub grphi: c_types::c_int,
}
#[test]
fn bindgen_test_layout_srcu_node() {
    assert_eq!(
        ::core::mem::size_of::<srcu_node>(),
        96usize,
        concat!("Size of: ", stringify!(srcu_node))
    );
    assert_eq!(
        ::core::mem::align_of::<srcu_node>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).srcu_have_cbs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_have_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).srcu_data_have_cbs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_data_have_cbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_node>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).srcu_parent as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).grplo as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(grplo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).grphi as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(grphi)
        )
    );
}
impl Default for srcu_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub node: [srcu_node; 521usize],
    pub level: [*mut srcu_node; 4usize],
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_idx: c_types::c_uint,
    pub srcu_gp_seq: c_types::c_ulong,
    pub srcu_gp_seq_needed: c_types::c_ulong,
    pub srcu_gp_seq_needed_exp: c_types::c_ulong,
    pub srcu_last_gp_end: c_types::c_ulong,
    pub sda: *mut srcu_data,
    pub srcu_barrier_seq: c_types::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub work: delayed_work,
}
#[test]
fn bindgen_test_layout_srcu_struct() {
    assert_eq!(
        ::core::mem::size_of::<srcu_struct>(),
        50336usize,
        concat!("Size of: ", stringify!(srcu_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<srcu_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).level as *const _ as usize },
        50016usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_cb_mutex as *const _ as usize },
        50048usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_cb_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).lock as *const _ as usize },
        50080usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_gp_mutex as *const _ as usize },
        50088usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_idx as *const _ as usize },
        50120usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_gp_seq as *const _ as usize },
        50128usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_gp_seq_needed as *const _ as usize },
        50136usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq_needed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_struct>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        50144usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_last_gp_end as *const _ as usize },
        50152usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_last_gp_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).sda as *const _ as usize },
        50160usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(sda)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_barrier_seq as *const _ as usize },
        50168usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_barrier_mutex as *const _ as usize },
        50176usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_struct>())).srcu_barrier_completion as *const _ as usize
        },
        50208usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_completion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_struct>())).srcu_barrier_cpu_cnt as *const _ as usize
        },
        50240usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_cpu_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).work as *const _ as usize },
        50248usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(work)
        )
    );
}
impl Default for srcu_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub ia32_compat: c_types::c_ushort,
    pub lock: mutex,
    pub vdso: *mut c_types::c_void,
    pub vdso_image: *const vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16,
    pub execute_only_pkey: s16,
    pub bd_addr: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_mm_context_t() {
    assert_eq!(
        ::core::mem::size_of::<mm_context_t>(),
        136usize,
        concat!("Size of: ", stringify!(mm_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ctx_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ctx_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).tlb_gen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(tlb_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ldt_usr_sem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt_usr_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ldt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ia32_compat as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ia32_compat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).vdso as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).vdso_image as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso_image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_context_t>())).perf_rdpmc_allowed as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(perf_rdpmc_allowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_context_t>())).pkey_allocation_map as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(pkey_allocation_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).execute_only_pkey as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(execute_only_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).bd_addr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(bd_addr)
        )
    );
}
impl Default for mm_context_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
}
#[test]
fn bindgen_test_layout_fwnode_handle() {
    assert_eq!(
        ::core::mem::size_of::<fwnode_handle>(),
        16usize,
        concat!("Size of: ", stringify!(fwnode_handle))
    );
    assert_eq!(
        ::core::mem::align_of::<fwnode_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_handle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_handle>())).secondary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_handle>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for fwnode_handle {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct fwnode_endpoint - Fwnode graph endpoint"]
#[doc = " @port: Port number"]
#[doc = " @id: Endpoint id"]
#[doc = " @local_fwnode: reference to the related fwnode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: c_types::c_uint,
    pub id: c_types::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
#[test]
fn bindgen_test_layout_fwnode_endpoint() {
    assert_eq!(
        ::core::mem::size_of::<fwnode_endpoint>(),
        16usize,
        concat!("Size of: ", stringify!(fwnode_endpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<fwnode_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_endpoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_endpoint>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_endpoint>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_endpoint>())).local_fwnode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(local_fwnode)
        )
    );
}
impl Default for fwnode_endpoint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct fwnode_reference_args - Fwnode reference with additional arguments"]
#[doc = " @fwnode:- A reference to the base fwnode"]
#[doc = " @nargs: Number of elements in @args array"]
#[doc = " @args: Integer arguments on the fwnode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: c_types::c_uint,
    pub args: [c_types::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout_fwnode_reference_args() {
    assert_eq!(
        ::core::mem::size_of::<fwnode_reference_args>(),
        48usize,
        concat!("Size of: ", stringify!(fwnode_reference_args))
    );
    assert_eq!(
        ::core::mem::align_of::<fwnode_reference_args>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_reference_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_reference_args>())).fwnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(fwnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_reference_args>())).nargs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_reference_args>())).args as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(args)
        )
    );
}
impl Default for fwnode_reference_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct fwnode_operations - Operations for fwnode interface"]
#[doc = " @get: Get a reference to an fwnode."]
#[doc = " @put: Put a reference to an fwnode."]
#[doc = " @property_present: Return true if a property is present."]
#[doc = " @property_read_integer_array: Read an array of integer properties. Return"]
#[doc = "\t\t\t\t zero on success, a negative error code"]
#[doc = "\t\t\t\t otherwise."]
#[doc = " @property_read_string_array: Read an array of string properties. Return zero"]
#[doc = "\t\t\t\ton success, a negative error code otherwise."]
#[doc = " @get_parent: Return the parent of an fwnode."]
#[doc = " @get_next_child_node: Return the next child node in an iteration."]
#[doc = " @get_named_child_node: Return a child node with a given name."]
#[doc = " @get_reference_args: Return a reference pointed to by a property, with args"]
#[doc = " @graph_get_next_endpoint: Return an endpoint node in an iteration."]
#[doc = " @graph_get_remote_endpoint: Return the remote endpoint node of a local"]
#[doc = "\t\t\t       endpoint node."]
#[doc = " @graph_get_port_parent: Return the parent node of a port node."]
#[doc = " @graph_parse_endpoint: Parse endpoint for port and endpoint id."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::core::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle)>,
    pub device_is_available:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub property_present: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const c_types::c_char,
        ) -> bool_,
    >,
    pub property_read_int_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const c_types::c_char,
            elem_size: c_types::c_uint,
            val: *mut c_types::c_void,
            nval: usize,
        ) -> c_types::c_int,
    >,
    pub property_read_string_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode_handle: *const fwnode_handle,
            propname: *const c_types::c_char,
            val: *mut *const c_types::c_char,
            nval: usize,
        ) -> c_types::c_int,
    >,
    pub get_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            child: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            name: *const c_types::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prop: *const c_types::c_char,
            nargs_prop: *const c_types::c_char,
            nargs: c_types::c_uint,
            index: c_types::c_uint,
            args: *mut fwnode_reference_args,
        ) -> c_types::c_int,
    >,
    pub graph_get_next_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prev: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            endpoint: *mut fwnode_endpoint,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_fwnode_operations() {
    assert_eq!(
        ::core::mem::size_of::<fwnode_operations>(),
        112usize,
        concat!("Size of: ", stringify!(fwnode_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<fwnode_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_operations>())).get as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_operations>())).put as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).device_is_available as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(device_is_available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).property_present as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).property_read_int_array as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_read_int_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).property_read_string_array as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_read_string_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_operations>())).get_parent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).get_next_child_node as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_next_child_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).get_named_child_node as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_named_child_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).get_reference_args as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_reference_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).graph_get_next_endpoint as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_next_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).graph_get_remote_endpoint as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_remote_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).graph_get_port_parent as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_port_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).graph_parse_endpoint as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_parse_endpoint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_node() {
    assert_eq!(
        ::core::mem::size_of::<llist_node>(),
        8usize,
        concat!("Size of: ", stringify!(llist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<llist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<llist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_node),
            "::",
            stringify!(next)
        )
    );
}
impl Default for llist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: c_types::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(
        ::core::mem::size_of::<rb_node>(),
        24usize,
        concat!("Size of: ", stringify!(rb_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_node>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(__rb_parent_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).rb_right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).rb_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_left)
        )
    );
}
impl Default for rb_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root() {
    assert_eq!(
        ::core::mem::size_of::<rb_root>(),
        8usize,
        concat!("Size of: ", stringify!(rb_root))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_root>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root),
            "::",
            stringify!(rb_node)
        )
    );
}
impl Default for rb_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root_cached() {
    assert_eq!(
        ::core::mem::size_of::<rb_root_cached>(),
        16usize,
        concat!("Size of: ", stringify!(rb_root_cached))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_root_cached>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root_cached))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root_cached>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root_cached>())).rb_leftmost as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_leftmost)
        )
    );
}
impl Default for rb_root_cached {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut c_types::c_void,
    pub size: c_types::c_ulong,
    pub flags: c_types::c_ulong,
    pub pages: *mut *mut page,
    pub nr_pages: c_types::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const c_types::c_void,
}
#[test]
fn bindgen_test_layout_vm_struct() {
    assert_eq!(
        ::core::mem::size_of::<vm_struct>(),
        64usize,
        concat!("Size of: ", stringify!(vm_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).pages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).nr_pages as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(nr_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).phys_addr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).caller as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(caller)
        )
    );
}
impl Default for vm_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type smp_call_func_t = ::core::option::Option<unsafe extern "C" fn(info: *mut c_types::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __call_single_data {
    pub llist: llist_node,
    pub func: smp_call_func_t,
    pub info: *mut c_types::c_void,
    pub flags: c_types::c_uint,
}
#[test]
fn bindgen_test_layout___call_single_data() {
    assert_eq!(
        ::core::mem::size_of::<__call_single_data>(),
        32usize,
        concat!("Size of: ", stringify!(__call_single_data))
    );
    assert_eq!(
        ::core::mem::align_of::<__call_single_data>(),
        8usize,
        concat!("Alignment of ", stringify!(__call_single_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__call_single_data>())).llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__call_single_data>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__call_single_data>())).info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__call_single_data>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for __call_single_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idr {
    pub idr_rt: radix_tree_root,
    pub idr_next: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_idr() {
    assert_eq!(
        ::core::mem::size_of::<idr>(),
        24usize,
        concat!("Size of: ", stringify!(idr))
    );
    assert_eq!(
        ::core::mem::align_of::<idr>(),
        8usize,
        concat!("Alignment of ", stringify!(idr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idr>())).idr_rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idr),
            "::",
            stringify!(idr_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idr>())).idr_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idr),
            "::",
            stringify!(idr_next)
        )
    );
}
impl Default for idr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[test]
fn bindgen_test_layout_kuid_t() {
    assert_eq!(
        ::core::mem::size_of::<kuid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kuid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kuid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[test]
fn bindgen_test_layout_kgid_t() {
    assert_eq!(
        ::core::mem::size_of::<kgid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kgid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kgid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kgid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kgid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kgid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_open_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_iattrs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: c_types::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
}
#[test]
fn bindgen_test_layout_kernfs_elem_dir() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_dir>(),
        24usize,
        concat!("Size of: ", stringify!(kernfs_elem_dir))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_dir>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_dir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).subdirs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(subdirs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).children as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(root)
        )
    );
}
impl Default for kernfs_elem_dir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
#[test]
fn bindgen_test_layout_kernfs_elem_symlink() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_symlink>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_elem_symlink))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_symlink>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_symlink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_symlink>())).target_kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_symlink),
            "::",
            stringify!(target_kn)
        )
    );
}
impl Default for kernfs_elem_symlink {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
#[test]
fn bindgen_test_layout_kernfs_elem_attr() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_attr>(),
        32usize,
        concat!("Size of: ", stringify!(kernfs_elem_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_attr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).open as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).notify_next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(notify_next)
        )
    );
}
impl Default for kernfs_elem_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node_id {
    pub __bindgen_anon_1: kernfs_node_id__bindgen_ty_1,
    pub id: u64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_node_id__bindgen_ty_1 {
    pub ino: u32,
    pub generation: u32,
}
#[test]
fn bindgen_test_layout_kernfs_node_id__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node_id__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_node_id__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node_id__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(kernfs_node_id__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node_id__bindgen_ty_1>())).ino as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id__bindgen_ty_1),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node_id__bindgen_ty_1>())).generation as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id__bindgen_ty_1),
            "::",
            stringify!(generation)
        )
    );
}
#[test]
fn bindgen_test_layout_kernfs_node_id() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node_id>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_node_id))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node_id>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node_id>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id),
            "::",
            stringify!(id)
        )
    );
}
impl Default for kernfs_node_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub parent: *mut kernfs_node,
    pub name: *const c_types::c_char,
    pub rb: rb_node,
    pub ns: *const c_types::c_void,
    pub hash: c_types::c_uint,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub priv_: *mut c_types::c_void,
    pub id: kernfs_node_id,
    pub flags: c_types::c_ushort,
    pub mode: umode_t,
    pub iattr: *mut kernfs_iattrs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_kernfs_node__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(kernfs_node__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).dir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).symlink as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(symlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(attr)
        )
    );
}
impl Default for kernfs_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kernfs_node() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node>(),
        128usize,
        concat!("Size of: ", stringify!(kernfs_node))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).active as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).rb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(rb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).ns as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).hash as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).priv_ as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).id as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).flags as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).mode as *const _ as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).iattr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(iattr)
        )
    );
}
impl Default for kernfs_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_syscall_ops {
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            root: *mut kernfs_root,
            flags: *mut c_types::c_int,
            data: *mut c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, root: *mut kernfs_root) -> c_types::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            parent: *mut kernfs_node,
            name: *const c_types::c_char,
            mode: umode_t,
        ) -> c_types::c_int,
    >,
    pub rmdir: ::core::option::Option<unsafe extern "C" fn(kn: *mut kernfs_node) -> c_types::c_int>,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            kn: *mut kernfs_node,
            new_parent: *mut kernfs_node,
            new_name: *const c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            kn: *mut kernfs_node,
            root: *mut kernfs_root,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kernfs_syscall_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_syscall_ops>(),
        48usize,
        concat!("Size of: ", stringify!(kernfs_syscall_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_syscall_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_syscall_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).remount_fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(remount_fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_syscall_ops>())).show_options as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(show_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).mkdir as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).rmdir as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).rename as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).show_path as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(show_path)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_root {
    pub kn: *mut kernfs_node,
    pub flags: c_types::c_uint,
    pub ino_idr: idr,
    pub last_ino: u32,
    pub next_generation: u32,
    pub syscall_ops: *mut kernfs_syscall_ops,
    pub supers: list_head,
    pub deactivate_waitq: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_kernfs_root() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_root>(),
        96usize,
        concat!("Size of: ", stringify!(kernfs_root))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_root>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(kn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).ino_idr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(ino_idr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).last_ino as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(last_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).next_generation as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(next_generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).syscall_ops as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(syscall_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).supers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(supers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).deactivate_waitq as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(deactivate_waitq)
        )
    );
}
impl Default for kernfs_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut c_types::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: c_types::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut c_types::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub vm_ops: *const vm_operations_struct,
}
#[test]
fn bindgen_test_layout_kernfs_open_file() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_open_file>(),
        152usize,
        concat!("Size of: ", stringify!(kernfs_open_file))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_open_file>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_open_file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(kn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).seq_file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(seq_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_open_file>())).prealloc_mutex as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(prealloc_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).event as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).list as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).prealloc_buf as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(prealloc_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_open_file>())).atomic_write_len as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(atomic_write_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).vm_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(vm_ops)
        )
    );
}
impl Default for kernfs_open_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mmapped: bool_,
        released: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_ops {
    pub open:
        ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> c_types::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut c_types::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut c_types::c_void,
            ppos: *mut loff_t,
        ) -> *mut c_types::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut c_types::c_void)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut c_types::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut c_types::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, vma: *mut vm_area_struct) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kernfs_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_ops>(),
        88usize,
        concat!("Size of: ", stringify!(kernfs_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_show as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_start as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_stop as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).read as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).atomic_write_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(atomic_write_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).prealloc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(prealloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).write as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).mmap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(mmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock {
    _unused: [u8; 0],
}
pub const kobj_ns_type_KOBJ_NS_TYPE_NONE: kobj_ns_type = 0;
pub const kobj_ns_type_KOBJ_NS_TYPE_NET: kobj_ns_type = 1;
pub const kobj_ns_type_KOBJ_NS_TYPES: kobj_ns_type = 2;
pub type kobj_ns_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub netlink_ns:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const c_types::c_void>,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const c_types::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
}
#[test]
fn bindgen_test_layout_kobj_ns_type_operations() {
    assert_eq!(
        ::core::mem::size_of::<kobj_ns_type_operations>(),
        48usize,
        concat!("Size of: ", stringify!(kobj_ns_type_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_ns_type_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_ns_type_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_ns_type_operations>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).current_may_mount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(current_may_mount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).grab_current_ns as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(grab_current_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).netlink_ns as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(netlink_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).initial_ns as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(initial_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).drop_ns as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(drop_ns)
        )
    );
}
impl Default for kobj_ns_type_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32,
    pub mode: umode_t,
    pub nlink: c_types::c_uint,
    pub blksize: u32,
    pub attributes: u64,
    pub attributes_mask: u64,
    pub ino: u64,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec,
    pub mtime: timespec,
    pub ctime: timespec,
    pub btime: timespec,
    pub blocks: u64,
}
#[test]
fn bindgen_test_layout_kstat() {
    assert_eq!(
        ::core::mem::size_of::<kstat>(),
        136usize,
        concat!("Size of: ", stringify!(kstat))
    );
    assert_eq!(
        ::core::mem::align_of::<kstat>(),
        8usize,
        concat!("Alignment of ", stringify!(kstat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).result_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(result_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).nlink as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).blksize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).attributes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).attributes_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(attributes_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).dev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).rdev as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).uid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).gid as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).atime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).mtime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).ctime as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).btime as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).blocks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(blocks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute {
    pub name: *const c_types::c_char,
    pub mode: umode_t,
}
#[test]
fn bindgen_test_layout_attribute() {
    assert_eq!(
        ::core::mem::size_of::<attribute>(),
        16usize,
        concat!("Size of: ", stringify!(attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct attribute_group - data structure used to declare an attribute group."]
#[doc = " @name:\tOptional: Attribute group name"]
#[doc = "\t\tIf specified, the attribute group will be created in"]
#[doc = "\t\ta new subdirectory with this name."]
#[doc = " @is_visible:\tOptional: Function to return permissions associated with an"]
#[doc = "\t\tattribute of the group. Will be called repeatedly for each"]
#[doc = "\t\tnon-binary attribute in the group. Only read/write"]
#[doc = "\t\tpermissions as well as SYSFS_PREALLOC are accepted. Must"]
#[doc = "\t\treturn 0 if an attribute is not visible. The returned value"]
#[doc = "\t\twill replace static permissions defined in struct attribute."]
#[doc = " @is_bin_visible:"]
#[doc = "\t\tOptional: Function to return permissions associated with a"]
#[doc = "\t\tbinary attribute of the group. Will be called repeatedly"]
#[doc = "\t\tfor each binary attribute in the group. Only read/write"]
#[doc = "\t\tpermissions as well as SYSFS_PREALLOC are accepted. Must"]
#[doc = "\t\treturn 0 if a binary attribute is not visible. The returned"]
#[doc = "\t\tvalue will replace static permissions defined in"]
#[doc = "\t\tstruct bin_attribute."]
#[doc = " @attrs:\tPointer to NULL terminated list of attributes."]
#[doc = " @bin_attrs:\tPointer to NULL terminated list of binary attributes."]
#[doc = "\t\tEither attrs or bin_attrs or both must be provided."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute_group {
    pub name: *const c_types::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: c_types::c_int,
        ) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut bin_attribute,
            arg3: c_types::c_int,
        ) -> umode_t,
    >,
    pub attrs: *mut *mut attribute,
    pub bin_attrs: *mut *mut bin_attribute,
}
#[test]
fn bindgen_test_layout_attribute_group() {
    assert_eq!(
        ::core::mem::size_of::<attribute_group>(),
        40usize,
        concat!("Size of: ", stringify!(attribute_group))
    );
    assert_eq!(
        ::core::mem::align_of::<attribute_group>(),
        8usize,
        concat!("Alignment of ", stringify!(attribute_group))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).is_visible as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(is_visible)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).is_bin_visible as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(is_bin_visible)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).attrs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).bin_attrs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(bin_attrs)
        )
    );
}
impl Default for attribute_group {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: usize,
    pub private: *mut c_types::c_void,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut c_types::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut c_types::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            attr: *mut bin_attribute,
            vma: *mut vm_area_struct,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_bin_attribute() {
    assert_eq!(
        ::core::mem::size_of::<bin_attribute>(),
        56usize,
        concat!("Size of: ", stringify!(bin_attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<bin_attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(bin_attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).private as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).read as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).write as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).mmap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(mmap)
        )
    );
}
impl Default for bin_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut c_types::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const c_types::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
#[test]
fn bindgen_test_layout_sysfs_ops() {
    assert_eq!(
        ::core::mem::size_of::<sysfs_ops>(),
        16usize,
        concat!("Size of: ", stringify!(sysfs_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<sysfs_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(sysfs_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysfs_ops>())).show as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysfs_ops),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysfs_ops>())).store as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysfs_ops),
            "::",
            stringify!(store)
        )
    );
}
#[doc = " refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at UINT_MAX and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
#[test]
fn bindgen_test_layout_refcount_struct() {
    assert_eq!(
        ::core::mem::size_of::<refcount_struct>(),
        4usize,
        concat!("Size of: ", stringify!(refcount_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<refcount_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(refcount_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<refcount_struct>())).refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(refcount_struct),
            "::",
            stringify!(refs)
        )
    );
}
pub type refcount_t = refcount_struct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[test]
fn bindgen_test_layout_kref() {
    assert_eq!(
        ::core::mem::size_of::<kref>(),
        4usize,
        concat!("Size of: ", stringify!(kref))
    );
    assert_eq!(
        ::core::mem::align_of::<kref>(),
        4usize,
        concat!("Alignment of ", stringify!(kref))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kref>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kref),
            "::",
            stringify!(refcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobject {
    pub name: *const c_types::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *mut kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_kobject() {
    assert_eq!(
        ::core::mem::size_of::<kobject>(),
        64usize,
        concat!("Size of: ", stringify!(kobject))
    );
    assert_eq!(
        ::core::mem::align_of::<kobject>(),
        8usize,
        concat!("Alignment of ", stringify!(kobject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).kset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(kset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).ktype as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(ktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).sd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(sd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).kref as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(kref)
        )
    );
}
impl Default for kobject {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: c_types::c_uint,
        state_in_sysfs: c_types::c_uint,
        state_add_uevent_sent: c_types::c_uint,
        state_remove_uevent_sent: c_types::c_uint,
        uevent_suppress: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_attrs: *mut *mut attribute,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject) -> *const c_types::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
}
#[test]
fn bindgen_test_layout_kobj_type() {
    assert_eq!(
        ::core::mem::size_of::<kobj_type>(),
        48usize,
        concat!("Size of: ", stringify!(kobj_type))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_type>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).sysfs_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(sysfs_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).default_attrs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(default_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).child_ns_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(child_ns_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).namespace as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(namespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).get_ownership as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(get_ownership)
        )
    );
}
impl Default for kobj_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut c_types::c_char; 3usize],
    pub envp: [*mut c_types::c_char; 32usize],
    pub envp_idx: c_types::c_int,
    pub buf: [c_types::c_char; 2048usize],
    pub buflen: c_types::c_int,
}
#[test]
fn bindgen_test_layout_kobj_uevent_env() {
    assert_eq!(
        ::core::mem::size_of::<kobj_uevent_env>(),
        2336usize,
        concat!("Size of: ", stringify!(kobj_uevent_env))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_uevent_env>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_uevent_env))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).argv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).envp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(envp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).envp_idx as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(envp_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).buf as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).buflen as *const _ as usize },
        2332usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(buflen)
        )
    );
}
impl Default for kobj_uevent_env {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(kset: *mut kset, kobj: *mut kobject) -> c_types::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(kset: *mut kset, kobj: *mut kobject) -> *const c_types::c_char,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(
            kset: *mut kset,
            kobj: *mut kobject,
            env: *mut kobj_uevent_env,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kset_uevent_ops() {
    assert_eq!(
        ::core::mem::size_of::<kset_uevent_ops>(),
        24usize,
        concat!("Size of: ", stringify!(kset_uevent_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kset_uevent_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kset_uevent_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).filter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).uevent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(uevent)
        )
    );
}
#[doc = " struct kset - a set of kobjects of a specific type, belonging to a specific subsystem."]
#[doc = ""]
#[doc = " A kset defines a group of kobjects.  They can be individually"]
#[doc = " different \"types\" but overall these kobjects all want to be grouped"]
#[doc = " together and operated on in the same manner.  ksets are used to"]
#[doc = " define the attribute callbacks and other common events that happen to"]
#[doc = " a kobject."]
#[doc = ""]
#[doc = " @list: the list of all kobjects for this kset"]
#[doc = " @list_lock: a lock for iterating over the kobjects"]
#[doc = " @kobj: the embedded kobject for this kset (recursion, isn't it fun...)"]
#[doc = " @uevent_ops: the set of uevent operations for this kset.  These are"]
#[doc = " called whenever a kobject has something happen to it so that the kset"]
#[doc = " can add new environment variables, or filter out the uevents if so"]
#[doc = " desired."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
#[test]
fn bindgen_test_layout_kset() {
    assert_eq!(
        ::core::mem::size_of::<kset>(),
        96usize,
        concat!("Size of: ", stringify!(kset))
    );
    assert_eq!(
        ::core::mem::align_of::<kset>(),
        8usize,
        concat!("Alignment of ", stringify!(kset))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).list_lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).kobj as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).uevent_ops as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(uevent_ops)
        )
    );
}
impl Default for kset {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resource {
    pub start: resource_size_t,
    pub end: resource_size_t,
    pub name: *const c_types::c_char,
    pub flags: c_types::c_ulong,
    pub desc: c_types::c_ulong,
    pub parent: *mut resource,
    pub sibling: *mut resource,
    pub child: *mut resource,
}
#[test]
fn bindgen_test_layout_resource() {
    assert_eq!(
        ::core::mem::size_of::<resource>(),
        64usize,
        concat!("Size of: ", stringify!(resource))
    );
    assert_eq!(
        ::core::mem::align_of::<resource>(),
        8usize,
        concat!("Alignment of ", stringify!(resource))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).desc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).parent as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).sibling as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).child as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(child)
        )
    );
}
impl Default for resource {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klist_node {
    pub n_klist: *mut c_types::c_void,
    pub n_node: list_head,
    pub n_ref: kref,
}
#[test]
fn bindgen_test_layout_klist_node() {
    assert_eq!(
        ::core::mem::size_of::<klist_node>(),
        32usize,
        concat!("Size of: ", stringify!(klist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<klist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(klist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klist_node>())).n_klist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(klist_node),
            "::",
            stringify!(n_klist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klist_node>())).n_node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(klist_node),
            "::",
            stringify!(n_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klist_node>())).n_ref as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(klist_node),
            "::",
            stringify!(n_ref)
        )
    );
}
impl Default for klist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
#[test]
fn bindgen_test_layout_hlist_bl_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_bl_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_bl_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_bl_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_bl_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_head),
            "::",
            stringify!(first)
        )
    );
}
impl Default for hlist_bl_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
#[test]
fn bindgen_test_layout_hlist_bl_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_bl_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_bl_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_bl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_bl_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_node),
            "::",
            stringify!(pprev)
        )
    );
}
impl Default for hlist_bl_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: c_types::c_int,
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
}
impl Default for lockref__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1>())).lock_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1),
            "::",
            stringify!(lock_count)
        )
    );
}
impl Default for lockref__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_lockref() {
    assert_eq!(
        ::core::mem::size_of::<lockref>(),
        8usize,
        concat!("Size of: ", stringify!(lockref))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref))
    );
}
impl Default for lockref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsmount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const c_types::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32,
    pub len: u32,
}
#[test]
fn bindgen_test_layout_qstr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qstr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
}
#[test]
fn bindgen_test_layout_qstr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qstr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qstr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qstr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qstr__bindgen_ty_1>())).hash_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1),
            "::",
            stringify!(hash_len)
        )
    );
}
impl Default for qstr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qstr() {
    assert_eq!(
        ::core::mem::size_of::<qstr>(),
        16usize,
        concat!("Size of: ", stringify!(qstr))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr>(),
        8usize,
        concat!("Alignment of ", stringify!(qstr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qstr>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr),
            "::",
            stringify!(name)
        )
    );
}
impl Default for qstr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: c_types::c_uint,
    pub d_seq: seqcount_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [c_types::c_uchar; 32usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: c_types::c_ulong,
    pub d_fsdata: *mut c_types::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_child: list_head,
    pub d_subdirs: list_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_dentry__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<dentry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(dentry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_1>())).d_lru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_1),
            "::",
            stringify!(d_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_1>())).d_wait as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_1),
            "::",
            stringify!(d_wait)
        )
    );
}
impl Default for dentry__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_dentry__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<dentry__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(dentry__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_alias as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_alias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_in_lookup_hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_in_lookup_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_rcu)
        )
    );
}
impl Default for dentry__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_dentry() {
    assert_eq!(
        ::core::mem::size_of::<dentry>(),
        192usize,
        concat!("Size of: ", stringify!(dentry))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_inode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_iname as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_iname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_lockref as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_lockref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_op as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_sb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_fsdata as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_fsdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_child as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_subdirs as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_subdirs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_u as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_u)
        )
    );
}
impl Default for dentry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> c_types::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: c_types::c_uint,
            arg3: *const c_types::c_char,
            arg4: *const qstr,
        ) -> c_types::c_int,
    >,
    pub d_delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> c_types::c_int>,
    pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> c_types::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut c_types::c_char,
            arg3: c_types::c_int,
        ) -> *mut c_types::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> c_types::c_int,
    >,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *const inode,
            arg3: c_types::c_uint,
            arg4: c_types::c_uint,
        ) -> *mut dentry,
    >,
}
#[test]
fn bindgen_test_layout_dentry_operations() {
    assert_eq!(
        ::core::mem::size_of::<dentry_operations>(),
        128usize,
        concat!("Size of: ", stringify!(dentry_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry_operations>(),
        64usize,
        concat!("Alignment of ", stringify!(dentry_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_revalidate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_revalidate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dentry_operations>())).d_weak_revalidate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_weak_revalidate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_compare as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_delete as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_init as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_release as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_prune as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_prune)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_iput as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_iput)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_dname as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_dname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_automount as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_automount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_manage as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_manage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_real as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_real)
        )
    );
}
impl Default for dentry_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
#[test]
fn bindgen_test_layout_path() {
    assert_eq!(
        ::core::mem::size_of::<path>(),
        16usize,
        concat!("Size of: ", stringify!(path))
    );
    assert_eq!(
        ::core::mem::align_of::<path>(),
        8usize,
        concat!("Alignment of ", stringify!(path))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path>())).mnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(path), "::", stringify!(mnt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path>())).dentry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(path),
            "::",
            stringify!(dentry)
        )
    );
}
impl Default for path {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nr_to_scan: c_types::c_ulong,
    pub nr_scanned: c_types::c_ulong,
    pub nid: c_types::c_int,
    pub memcg: *mut mem_cgroup,
}
#[test]
fn bindgen_test_layout_shrink_control() {
    assert_eq!(
        ::core::mem::size_of::<shrink_control>(),
        40usize,
        concat!("Size of: ", stringify!(shrink_control))
    );
    assert_eq!(
        ::core::mem::align_of::<shrink_control>(),
        8usize,
        concat!("Alignment of ", stringify!(shrink_control))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).gfp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nr_to_scan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nr_to_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nr_scanned as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nr_scanned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).memcg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(memcg)
        )
    );
}
impl Default for shrink_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> c_types::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> c_types::c_ulong,
    >,
    pub seeks: c_types::c_int,
    pub batch: c_types::c_long,
    pub flags: c_types::c_ulong,
    pub list: list_head,
    pub nr_deferred: *mut atomic_long_t,
}
#[test]
fn bindgen_test_layout_shrinker() {
    assert_eq!(
        ::core::mem::size_of::<shrinker>(),
        64usize,
        concat!("Size of: ", stringify!(shrinker))
    );
    assert_eq!(
        ::core::mem::align_of::<shrinker>(),
        8usize,
        concat!("Alignment of ", stringify!(shrinker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).count_objects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(count_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).scan_objects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(scan_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).seeks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(seeks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).batch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).nr_deferred as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(nr_deferred)
        )
    );
}
impl Default for shrinker {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: c_types::c_long,
}
#[test]
fn bindgen_test_layout_list_lru_one() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_one>(),
        24usize,
        concat!("Size of: ", stringify!(list_lru_one))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_one>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru_one))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_one>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_one),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_one>())).nr_items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_one),
            "::",
            stringify!(nr_items)
        )
    );
}
impl Default for list_lru_one {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct list_lru_memcg {
    pub lru: __IncompleteArrayField<*mut list_lru_one>,
}
#[test]
fn bindgen_test_layout_list_lru_memcg() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_memcg>(),
        0usize,
        concat!("Size of: ", stringify!(list_lru_memcg))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_memcg>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru_memcg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_memcg>())).lru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_memcg),
            "::",
            stringify!(lru)
        )
    );
}
impl Default for list_lru_memcg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub memcg_lrus: *mut list_lru_memcg,
    pub nr_items: c_types::c_long,
}
#[test]
fn bindgen_test_layout_list_lru_node() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_node>(),
        64usize,
        concat!("Size of: ", stringify!(list_lru_node))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_node>(),
        64usize,
        concat!("Alignment of ", stringify!(list_lru_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).lru as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).memcg_lrus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(memcg_lrus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).nr_items as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(nr_items)
        )
    );
}
impl Default for list_lru_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub memcg_aware: bool_,
}
#[test]
fn bindgen_test_layout_list_lru() {
    assert_eq!(
        ::core::mem::size_of::<list_lru>(),
        32usize,
        concat!("Size of: ", stringify!(list_lru))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).memcg_aware as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(memcg_aware)
        )
    );
}
impl Default for list_lru {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const pid_type_PIDTYPE_PID: pid_type = 0;
pub const pid_type_PIDTYPE_PGID: pid_type = 1;
pub const pid_type_PIDTYPE_SID: pid_type = 2;
pub const pid_type_PIDTYPE_MAX: pid_type = 3;
pub const pid_type___PIDTYPE_TGID: pid_type = 4;
pub type pid_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upid {
    pub nr: c_types::c_int,
    pub ns: *mut pid_namespace,
}
#[test]
fn bindgen_test_layout_upid() {
    assert_eq!(
        ::core::mem::size_of::<upid>(),
        16usize,
        concat!("Size of: ", stringify!(upid))
    );
    assert_eq!(
        ::core::mem::align_of::<upid>(),
        8usize,
        concat!("Alignment of ", stringify!(upid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<upid>())).nr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(upid), "::", stringify!(nr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<upid>())).ns as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(upid), "::", stringify!(ns))
    );
}
impl Default for upid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid {
    pub count: atomic_t,
    pub level: c_types::c_uint,
    pub tasks: [hlist_head; 3usize],
    pub rcu: callback_head,
    pub numbers: [upid; 1usize],
}
#[test]
fn bindgen_test_layout_pid() {
    assert_eq!(
        ::core::mem::size_of::<pid>(),
        64usize,
        concat!("Size of: ", stringify!(pid))
    );
    assert_eq!(
        ::core::mem::align_of::<pid>(),
        8usize,
        concat!("Alignment of ", stringify!(pid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).tasks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).rcu as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(pid), "::", stringify!(rcu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).numbers as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(numbers)
        )
    );
}
impl Default for pid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid_link {
    pub node: hlist_node,
    pub pid: *mut pid,
}
#[test]
fn bindgen_test_layout_pid_link() {
    assert_eq!(
        ::core::mem::size_of::<pid_link>(),
        24usize,
        concat!("Size of: ", stringify!(pid_link))
    );
    assert_eq!(
        ::core::mem::align_of::<pid_link>(),
        8usize,
        concat!("Alignment of ", stringify!(pid_link))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid_link>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pid_link),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid_link>())).pid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pid_link),
            "::",
            stringify!(pid)
        )
    );
}
impl Default for pid_link {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
}
#[test]
fn bindgen_test_layout_arch_tlbflush_unmap_batch() {
    assert_eq!(
        ::core::mem::size_of::<arch_tlbflush_unmap_batch>(),
        1024usize,
        concat!("Size of: ", stringify!(arch_tlbflush_unmap_batch))
    );
    assert_eq!(
        ::core::mem::align_of::<arch_tlbflush_unmap_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_tlbflush_unmap_batch))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arch_tlbflush_unmap_batch>())).cpumask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_tlbflush_unmap_batch),
            "::",
            stringify!(cpumask)
        )
    );
}
impl Default for arch_tlbflush_unmap_batch {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmacache {
    pub seqnum: u64,
    pub vmas: [*mut vm_area_struct; 4usize],
}
#[test]
fn bindgen_test_layout_vmacache() {
    assert_eq!(
        ::core::mem::size_of::<vmacache>(),
        40usize,
        concat!("Size of: ", stringify!(vmacache))
    );
    assert_eq!(
        ::core::mem::align_of::<vmacache>(),
        8usize,
        concat!("Alignment of ", stringify!(vmacache))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmacache>())).seqnum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmacache),
            "::",
            stringify!(seqnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmacache>())).vmas as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmacache),
            "::",
            stringify!(vmas)
        )
    );
}
impl Default for vmacache {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_rss_stat {
    pub events: c_types::c_int,
    pub count: [c_types::c_int; 4usize],
}
#[test]
fn bindgen_test_layout_task_rss_stat() {
    assert_eq!(
        ::core::mem::size_of::<task_rss_stat>(),
        20usize,
        concat!("Size of: ", stringify!(task_rss_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<task_rss_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(task_rss_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_rss_stat>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_rss_stat),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_rss_stat>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(task_rss_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mm_rss_stat {
    pub count: [atomic_long_t; 4usize],
}
#[test]
fn bindgen_test_layout_mm_rss_stat() {
    assert_eq!(
        ::core::mem::size_of::<mm_rss_stat>(),
        32usize,
        concat!("Size of: ", stringify!(mm_rss_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_rss_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_rss_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_rss_stat>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_rss_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
#[test]
fn bindgen_test_layout_page_frag() {
    assert_eq!(
        ::core::mem::size_of::<page_frag>(),
        16usize,
        concat!("Size of: ", stringify!(page_frag))
    );
    assert_eq!(
        ::core::mem::align_of::<page_frag>(),
        8usize,
        concat!("Alignment of ", stringify!(page_frag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(size)
        )
    );
}
impl Default for page_frag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
#[test]
fn bindgen_test_layout_tlbflush_unmap_batch() {
    assert_eq!(
        ::core::mem::size_of::<tlbflush_unmap_batch>(),
        1032usize,
        concat!("Size of: ", stringify!(tlbflush_unmap_batch))
    );
    assert_eq!(
        ::core::mem::align_of::<tlbflush_unmap_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(tlbflush_unmap_batch))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tlbflush_unmap_batch>())).arch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tlbflush_unmap_batch>())).flush_required as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(flush_required)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tlbflush_unmap_batch>())).writable as *const _ as usize },
        1025usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(writable)
        )
    );
}
impl Default for tlbflush_unmap_batch {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_scratch_register: c_types::c_ulong,
    pub saved_trap_nr: c_types::c_uint,
    pub saved_tf: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_arch_uprobe_task() {
    assert_eq!(
        ::core::mem::size_of::<arch_uprobe_task>(),
        16usize,
        concat!("Size of: ", stringify!(arch_uprobe_task))
    );
    assert_eq!(
        ::core::mem::align_of::<arch_uprobe_task>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_uprobe_task))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arch_uprobe_task>())).saved_scratch_register as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_scratch_register)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arch_uprobe_task>())).saved_trap_nr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arch_uprobe_task>())).saved_tf as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_tf)
        )
    );
}
pub const uprobe_task_state_UTASK_RUNNING: uprobe_task_state = 0;
pub const uprobe_task_state_UTASK_SSTEP: uprobe_task_state = 1;
pub const uprobe_task_state_UTASK_SSTEP_ACK: uprobe_task_state = 2;
pub const uprobe_task_state_UTASK_SSTEP_TRAPPED: uprobe_task_state = 3;
pub type uprobe_task_state = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: c_types::c_ulong,
    pub return_instances: *mut return_instance,
    pub depth: c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).autask as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(autask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).vaddr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_work
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dup_xol_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_addr
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dup_xol_addr)
        )
    );
}
impl Default for uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(uprobe_task__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_task__bindgen_ty_1))
    );
}
impl Default for uprobe_task__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uprobe_task() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task>(),
        64usize,
        concat!("Size of: ", stringify!(uprobe_task))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_task))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).active_uprobe as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(active_uprobe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).xol_vaddr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(xol_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).return_instances as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(return_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(depth)
        )
    );
}
impl Default for uprobe_task {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct return_instance {
    pub uprobe: *mut uprobe,
    pub func: c_types::c_ulong,
    pub stack: c_types::c_ulong,
    pub orig_ret_vaddr: c_types::c_ulong,
    pub chained: bool_,
    pub next: *mut return_instance,
}
#[test]
fn bindgen_test_layout_return_instance() {
    assert_eq!(
        ::core::mem::size_of::<return_instance>(),
        48usize,
        concat!("Size of: ", stringify!(return_instance))
    );
    assert_eq!(
        ::core::mem::align_of::<return_instance>(),
        8usize,
        concat!("Alignment of ", stringify!(return_instance))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).uprobe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(uprobe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).orig_ret_vaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(orig_ret_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).chained as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(chained)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(next)
        )
    );
}
impl Default for return_instance {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xol_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
#[test]
fn bindgen_test_layout_uprobes_state() {
    assert_eq!(
        ::core::mem::size_of::<uprobes_state>(),
        8usize,
        concat!("Size of: ", stringify!(uprobes_state))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobes_state>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobes_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobes_state>())).xol_area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobes_state),
            "::",
            stringify!(xol_area)
        )
    );
}
impl Default for uprobes_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmm {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: c_types::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_4,
    pub __bindgen_anon_5: page__bindgen_ty_5,
    pub mem_cgroup: *mut mem_cgroup,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub mapping: *mut address_space,
    pub s_mem: *mut c_types::c_void,
    pub compound_mapcount: atomic_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_1>())).mapping as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1),
            "::",
            stringify!(mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_1>())).s_mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1),
            "::",
            stringify!(s_mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1>())).compound_mapcount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1),
            "::",
            stringify!(compound_mapcount)
        )
    );
}
impl Default for page__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub index: c_types::c_ulong,
    pub freelist: *mut c_types::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>())).freelist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(freelist)
        )
    );
}
impl Default for page__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_3 {
    pub counters: c_types::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub _refcount: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub _mapcount: atomic_t,
    pub active: c_types::c_uint,
    pub __bindgen_anon_1: page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub units: c_types::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inuse(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inuse(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn objects(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_objects(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inuse: c_types::c_uint,
        objects: c_types::c_uint,
        frozen: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let inuse: u32 = unsafe { ::core::mem::transmute(inuse) };
            inuse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let objects: u32 = unsafe { ::core::mem::transmute(objects) };
            objects as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()))._mapcount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mapcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>())).active
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>())).units
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(units)
        )
    );
}
impl Default for page__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_3__bindgen_ty_1>()))._refcount as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(_refcount)
        )
    );
}
impl Default for page__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_3>())).counters as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_3),
            "::",
            stringify!(counters)
        )
    );
}
impl Default for page__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_4 {
    pub lru: list_head,
    pub pgmap: *mut dev_pagemap,
    pub __bindgen_anon_1: page__bindgen_ty_4__bindgen_ty_1,
    pub callback_head: callback_head,
    pub __bindgen_anon_2: page__bindgen_ty_4__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_4__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_4__bindgen_ty_1 {
    pub next: *mut page,
    pub pages: c_types::c_int,
    pub pobjects: c_types::c_int,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_4__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4__bindgen_ty_1>())).next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4__bindgen_ty_1>())).pages as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4__bindgen_ty_1>())).pobjects as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(pobjects)
        )
    );
}
impl Default for page__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct page__bindgen_ty_4__bindgen_ty_2 {
    pub compound_head: c_types::c_ulong,
    pub compound_dtor: c_types::c_uint,
    pub compound_order: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_4__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_4__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_4__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4__bindgen_ty_2>())).compound_head as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(compound_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4__bindgen_ty_2>())).compound_dtor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(compound_dtor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4__bindgen_ty_2>())).compound_order as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(compound_order)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_4__bindgen_ty_3 {
    pub __pad: c_types::c_ulong,
    pub pmd_huge_pte: pgtable_t,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_4__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_4__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_4__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_4__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_4__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4__bindgen_ty_3>())).__pad as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4__bindgen_ty_3),
            "::",
            stringify!(__pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4__bindgen_ty_3>())).pmd_huge_pte as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4__bindgen_ty_3),
            "::",
            stringify!(pmd_huge_pte)
        )
    );
}
impl Default for page__bindgen_ty_4__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_4>())).lru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4),
            "::",
            stringify!(lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_4>())).pgmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4),
            "::",
            stringify!(pgmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_4>())).callback_head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_4),
            "::",
            stringify!(callback_head)
        )
    );
}
impl Default for page__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_5 {
    pub private: c_types::c_ulong,
    pub ptl: spinlock_t,
    pub slab_cache: *mut kmem_cache,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_5>())).private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_5),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_5>())).ptl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_5),
            "::",
            stringify!(ptl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_5>())).slab_cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_5),
            "::",
            stringify!(slab_cache)
        )
    );
}
impl Default for page__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page() {
    assert_eq!(
        ::core::mem::size_of::<page>(),
        64usize,
        concat!("Size of: ", stringify!(page))
    );
    assert_eq!(
        ::core::mem::align_of::<page>(),
        16usize,
        concat!("Alignment of ", stringify!(page))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page>())).mem_cgroup as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(mem_cgroup)
        )
    );
}
impl Default for page {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_userfaultfd_ctx {
    pub ctx: *mut userfaultfd_ctx,
}
#[test]
fn bindgen_test_layout_vm_userfaultfd_ctx() {
    assert_eq!(
        ::core::mem::size_of::<vm_userfaultfd_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(vm_userfaultfd_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_userfaultfd_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_userfaultfd_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_userfaultfd_ctx>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_userfaultfd_ctx),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for vm_userfaultfd_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct {
    pub vm_start: c_types::c_ulong,
    pub vm_end: c_types::c_ulong,
    pub vm_next: *mut vm_area_struct,
    pub vm_prev: *mut vm_area_struct,
    pub vm_rb: rb_node,
    pub rb_subtree_gap: c_types::c_ulong,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub vm_flags: c_types::c_ulong,
    pub shared: vm_area_struct__bindgen_ty_1,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: c_types::c_ulong,
    pub vm_file: *mut file,
    pub vm_prfile: *mut file,
    pub vm_private_data: *mut c_types::c_void,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1 {
    pub rb: rb_node,
    pub rb_subtree_last: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_vm_area_struct__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<vm_area_struct__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(vm_area_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_area_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1>())).rb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1),
            "::",
            stringify!(rb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1>())).rb_subtree_last as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1),
            "::",
            stringify!(rb_subtree_last)
        )
    );
}
impl Default for vm_area_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_vm_area_struct() {
    assert_eq!(
        ::core::mem::size_of::<vm_area_struct>(),
        208usize,
        concat!("Size of: ", stringify!(vm_area_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_area_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_rb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_rb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).rb_subtree_gap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(rb_subtree_gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_mm as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_page_prot as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_page_prot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).shared as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).anon_vma_chain as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).anon_vma as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_pgoff as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_pgoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_file as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_prfile as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_prfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_private_data as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_private_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct>())).swap_readahead_info as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(swap_readahead_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_policy as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct>())).vm_userfaultfd_ctx as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_userfaultfd_ctx)
        )
    );
}
impl Default for vm_area_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
#[test]
fn bindgen_test_layout_core_thread() {
    assert_eq!(
        ::core::mem::size_of::<core_thread>(),
        16usize,
        concat!("Size of: ", stringify!(core_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<core_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(core_thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_thread>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_thread),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_thread>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_thread),
            "::",
            stringify!(next)
        )
    );
}
impl Default for core_thread {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
#[test]
fn bindgen_test_layout_core_state() {
    assert_eq!(
        ::core::mem::size_of::<core_state>(),
        56usize,
        concat!("Size of: ", stringify!(core_state))
    );
    assert_eq!(
        ::core::mem::align_of::<core_state>(),
        8usize,
        concat!("Alignment of ", stringify!(core_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).nr_threads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(nr_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).dumper as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(dumper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).startup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(startup)
        )
    );
}
impl Default for core_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct {
    pub mmap: *mut vm_area_struct,
    pub mm_rb: rb_root,
    pub vmacache_seqnum: u64,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            addr: c_types::c_ulong,
            len: c_types::c_ulong,
            pgoff: c_types::c_ulong,
            flags: c_types::c_ulong,
        ) -> c_types::c_ulong,
    >,
    pub mmap_base: c_types::c_ulong,
    pub mmap_legacy_base: c_types::c_ulong,
    pub mmap_compat_base: c_types::c_ulong,
    pub mmap_compat_legacy_base: c_types::c_ulong,
    pub task_size: c_types::c_ulong,
    pub highest_vm_end: c_types::c_ulong,
    pub pgd: *mut pgd_t,
    #[doc = " @mm_users: The number of users including userspace."]
    #[doc = ""]
    #[doc = " Use mmget()/mmget_not_zero()/mmput() to modify. When this drops"]
    #[doc = " to 0 (i.e. when the task exits and there are no other temporary"]
    #[doc = " reference holders), we also release a reference on @mm_count"]
    #[doc = " (which may then free the &struct mm_struct if @mm_count also"]
    #[doc = " drops to 0)."]
    pub mm_users: atomic_t,
    #[doc = " @mm_count: The number of references to &struct mm_struct"]
    #[doc = " (@mm_users count as 1)."]
    #[doc = ""]
    #[doc = " Use mmgrab()/mmdrop() to modify. When this drops to 0, the"]
    #[doc = " &struct mm_struct is freed."]
    pub mm_count: atomic_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: c_types::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_sem: rw_semaphore,
    pub mmlist: list_head,
    pub hiwater_rss: c_types::c_ulong,
    pub hiwater_vm: c_types::c_ulong,
    pub total_vm: c_types::c_ulong,
    pub locked_vm: c_types::c_ulong,
    pub pinned_vm: c_types::c_ulong,
    pub data_vm: c_types::c_ulong,
    pub exec_vm: c_types::c_ulong,
    pub stack_vm: c_types::c_ulong,
    pub def_flags: c_types::c_ulong,
    pub start_code: c_types::c_ulong,
    pub end_code: c_types::c_ulong,
    pub start_data: c_types::c_ulong,
    pub end_data: c_types::c_ulong,
    pub start_brk: c_types::c_ulong,
    pub brk: c_types::c_ulong,
    pub start_stack: c_types::c_ulong,
    pub arg_start: c_types::c_ulong,
    pub arg_end: c_types::c_ulong,
    pub env_start: c_types::c_ulong,
    pub env_end: c_types::c_ulong,
    pub saved_auxv: [c_types::c_ulong; 46usize],
    pub rss_stat: mm_rss_stat,
    pub binfmt: *mut linux_binfmt,
    pub cpu_vm_mask_var: cpumask_var_t,
    pub context: mm_context_t,
    pub flags: c_types::c_ulong,
    pub core_state: *mut core_state,
    pub membarrier_state: atomic_t,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub mmu_notifier_mm: *mut mmu_notifier_mm,
    pub cpumask_allocation: cpumask,
    pub numa_next_scan: c_types::c_ulong,
    pub numa_scan_offset: c_types::c_ulong,
    pub numa_scan_seq: c_types::c_int,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: bool_,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
    pub hmm: *mut hmm,
}
#[test]
fn bindgen_test_layout_mm_struct() {
    assert_eq!(
        ::core::mem::size_of::<mm_struct>(),
        2056usize,
        concat!("Size of: ", stringify!(mm_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mm_rb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mm_rb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).vmacache_seqnum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(vmacache_seqnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).get_unmapped_area as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(get_unmapped_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mmap_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mmap_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mmap_legacy_base as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mmap_legacy_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mmap_compat_base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mmap_compat_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct>())).mmap_compat_legacy_base as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mmap_compat_legacy_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).task_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(task_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).highest_vm_end as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(highest_vm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).pgd as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(pgd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mm_users as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mm_users)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mm_count as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mm_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).pgtables_bytes as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(pgtables_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).map_count as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(map_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).page_table_lock as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(page_table_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mmap_sem as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mmap_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mmlist as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mmlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).hiwater_rss as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(hiwater_rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).hiwater_vm as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(hiwater_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).total_vm as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(total_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).locked_vm as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(locked_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).pinned_vm as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(pinned_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).data_vm as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(data_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).exec_vm as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(exec_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).stack_vm as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(stack_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).def_flags as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(def_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).start_code as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(start_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).end_code as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(end_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).start_data as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(start_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).end_data as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(end_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).start_brk as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(start_brk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).brk as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(brk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).start_stack as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(start_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).arg_start as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(arg_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).arg_end as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(arg_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).env_start as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(env_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).env_end as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(env_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).saved_auxv as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(saved_auxv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).rss_stat as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(rss_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).binfmt as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(binfmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).cpu_vm_mask_var as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(cpu_vm_mask_var)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).context as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).flags as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).core_state as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(core_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).membarrier_state as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(membarrier_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).ioctx_lock as *const _ as usize },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(ioctx_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).ioctx_table as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(ioctx_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).owner as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).user_ns as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).exe_file as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(exe_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).mmu_notifier_mm as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(mmu_notifier_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).cpumask_allocation as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(cpumask_allocation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).numa_next_scan as *const _ as usize },
        1968usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(numa_next_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).numa_scan_offset as *const _ as usize },
        1976usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(numa_scan_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).numa_scan_seq as *const _ as usize },
        1984usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(numa_scan_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).tlb_flush_pending as *const _ as usize },
        1988usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(tlb_flush_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).tlb_flush_batched as *const _ as usize },
        1992usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(tlb_flush_batched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).uprobes_state as *const _ as usize },
        2000usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(uprobes_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).hugetlb_usage as *const _ as usize },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(hugetlb_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).async_put_work as *const _ as usize },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(async_put_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).hmm as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(hmm)
        )
    );
}
impl Default for mm_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_cap_struct {
    pub cap: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_kernel_cap_struct() {
    assert_eq!(
        ::core::mem::size_of::<kernel_cap_struct>(),
        8usize,
        concat!("Size of: ", stringify!(kernel_cap_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_cap_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(kernel_cap_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_cap_struct>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_cap_struct),
            "::",
            stringify!(cap)
        )
    );
}
pub type kernel_cap_t = kernel_cap_struct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fiemap_extent {
    pub fe_logical: __u64,
    pub fe_physical: __u64,
    pub fe_length: __u64,
    pub fe_reserved64: [__u64; 2usize],
    pub fe_flags: __u32,
    pub fe_reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_fiemap_extent() {
    assert_eq!(
        ::core::mem::size_of::<fiemap_extent>(),
        56usize,
        concat!("Size of: ", stringify!(fiemap_extent))
    );
    assert_eq!(
        ::core::mem::align_of::<fiemap_extent>(),
        8usize,
        concat!("Alignment of ", stringify!(fiemap_extent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_logical as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_logical)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_physical as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_physical)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_reserved64 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_reserved64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_reserved)
        )
    );
}
pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
pub const migrate_mode_MIGRATE_SYNC_NO_COPY: migrate_mode = 3;
pub type migrate_mode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
#[test]
fn bindgen_test_layout_rcuwait() {
    assert_eq!(
        ::core::mem::size_of::<rcuwait>(),
        8usize,
        concat!("Size of: ", stringify!(rcuwait))
    );
    assert_eq!(
        ::core::mem::align_of::<rcuwait>(),
        8usize,
        concat!("Alignment of ", stringify!(rcuwait))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcuwait>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcuwait),
            "::",
            stringify!(task)
        )
    );
}
impl Default for rcuwait {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const rcu_sync_type_RCU_SYNC: rcu_sync_type = 0;
pub const rcu_sync_type_RCU_SCHED_SYNC: rcu_sync_type = 1;
pub const rcu_sync_type_RCU_BH_SYNC: rcu_sync_type = 2;
pub type rcu_sync_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: c_types::c_int,
    pub gp_count: c_types::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_state: c_types::c_int,
    pub cb_head: callback_head,
    pub gp_type: rcu_sync_type,
}
#[test]
fn bindgen_test_layout_rcu_sync() {
    assert_eq!(
        ::core::mem::size_of::<rcu_sync>(),
        64usize,
        concat!("Size of: ", stringify!(rcu_sync))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_sync>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_sync))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).cb_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(cb_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).cb_head as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(cb_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_type as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_type)
        )
    );
}
impl Default for rcu_sync {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut c_types::c_uint,
    pub rw_sem: rw_semaphore,
    pub writer: rcuwait,
    pub readers_block: c_types::c_int,
}
#[test]
fn bindgen_test_layout_percpu_rw_semaphore() {
    assert_eq!(
        ::core::mem::size_of::<percpu_rw_semaphore>(),
        128usize,
        concat!("Size of: ", stringify!(percpu_rw_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<percpu_rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).rss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).read_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(read_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).rw_sem as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(rw_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).writer as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<percpu_rw_semaphore>())).readers_block as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(readers_block)
        )
    );
}
impl Default for percpu_rw_semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
    pub arg: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_delayed_call() {
    assert_eq!(
        ::core::mem::size_of::<delayed_call>(),
        16usize,
        concat!("Size of: ", stringify!(delayed_call))
    );
    assert_eq!(
        ::core::mem::align_of::<delayed_call>(),
        8usize,
        concat!("Alignment of ", stringify!(delayed_call))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_call>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_call),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_call>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_call),
            "::",
            stringify!(arg)
        )
    );
}
impl Default for delayed_call {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_uuid_t() {
    assert_eq!(
        ::core::mem::size_of::<uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(uuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uuid_t>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uuid_t), "::", stringify!(b))
    );
}
pub type errseq_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hd_geometry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct poll_table_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swap_info_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iattr {
    pub ia_valid: c_types::c_uint,
    pub ia_mode: umode_t,
    pub ia_uid: kuid_t,
    pub ia_gid: kgid_t,
    pub ia_size: loff_t,
    pub ia_atime: timespec,
    pub ia_mtime: timespec,
    pub ia_ctime: timespec,
    pub ia_file: *mut file,
}
#[test]
fn bindgen_test_layout_iattr() {
    assert_eq!(
        ::core::mem::size_of::<iattr>(),
        80usize,
        concat!("Size of: ", stringify!(iattr))
    );
    assert_eq!(
        ::core::mem::align_of::<iattr>(),
        8usize,
        concat!("Alignment of ", stringify!(iattr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_uid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_gid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_atime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_mtime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_ctime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_file as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_file)
        )
    );
}
impl Default for iattr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
#[test]
fn bindgen_test_layout_percpu_counter() {
    assert_eq!(
        ::core::mem::size_of::<percpu_counter>(),
        40usize,
        concat!("Size of: ", stringify!(percpu_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<percpu_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_counter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_counter>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_counter>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_counter>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_counter>())).counters as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(counters)
        )
    );
}
impl Default for percpu_counter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
#[test]
fn bindgen_test_layout_kprojid_t() {
    assert_eq!(
        ::core::mem::size_of::<kprojid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kprojid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kprojid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kprojid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kprojid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kprojid_t),
            "::",
            stringify!(val)
        )
    );
}
pub const quota_type_USRQUOTA: quota_type = 0;
pub const quota_type_GRPQUOTA: quota_type = 1;
pub const quota_type_PRJQUOTA: quota_type = 2;
pub type quota_type = u32;
pub type qsize_t = c_types::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_kqid__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kqid__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(kqid__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kqid__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(kqid__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).uid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).gid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).projid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(projid)
        )
    );
}
impl Default for kqid__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kqid() {
    assert_eq!(
        ::core::mem::size_of::<kqid>(),
        8usize,
        concat!("Size of: ", stringify!(kqid))
    );
    assert_eq!(
        ::core::mem::align_of::<kqid>(),
        4usize,
        concat!("Alignment of ", stringify!(kqid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for kqid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[test]
fn bindgen_test_layout_mem_dqblk() {
    assert_eq!(
        ::core::mem::size_of::<mem_dqblk>(),
        72usize,
        concat!("Size of: ", stringify!(mem_dqblk))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_bhardlimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_bhardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_bsoftlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_bsoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_curspace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_curspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_rsvspace as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_rsvspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_ihardlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_ihardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_isoftlimit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_isoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_curinodes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_curinodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_btime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_itime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_itime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: c_types::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: c_types::c_ulong,
    pub dqi_bgrace: c_types::c_uint,
    pub dqi_igrace: c_types::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_mem_dqinfo() {
    assert_eq!(
        ::core::mem::size_of::<mem_dqinfo>(),
        72usize,
        concat!("Size of: ", stringify!(mem_dqinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_dqinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_dqinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_fmt_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_dirty_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_dirty_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_bgrace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_bgrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_igrace as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_igrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_max_spc_limit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_max_spc_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_max_ino_limit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_max_ino_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_priv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_priv)
        )
    );
}
impl Default for mem_dqinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: c_types::c_ulong,
    pub dq_dqb: mem_dqblk,
}
#[test]
fn bindgen_test_layout_dquot() {
    assert_eq!(
        ::core::mem::size_of::<dquot>(),
        208usize,
        concat!("Size of: ", stringify!(dquot))
    );
    assert_eq!(
        ::core::mem::align_of::<dquot>(),
        8usize,
        concat!("Alignment of ", stringify!(dquot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_inuse as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_inuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dirty as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dqb_lock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dqb_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_count as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_sb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_id as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_off as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dqb as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dqb)
        )
    );
}
impl Default for dquot {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub read_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub commit_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_quota_format_ops() {
    assert_eq!(
        ::core::mem::size_of::<quota_format_ops>(),
        64usize,
        concat!("Size of: ", stringify!(quota_format_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_format_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_format_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).check_quota_file as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(check_quota_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).read_file_info as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(read_file_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).write_file_info as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(write_file_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).free_file_info as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(free_file_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).read_dqblk as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(read_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).commit_dqblk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(commit_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).release_dqblk as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(release_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).get_next_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(get_next_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub release_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub mark_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> c_types::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> c_types::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_dquot_operations() {
    assert_eq!(
        ::core::mem::size_of::<dquot_operations>(),
        88usize,
        concat!("Size of: ", stringify!(dquot_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<dquot_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(dquot_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).write_dquot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(write_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).alloc_dquot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(alloc_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).destroy_dquot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(destroy_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).acquire_dquot as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(acquire_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).release_dquot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(release_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).mark_dirty as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(mark_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).write_info as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(write_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dquot_operations>())).get_reserved_space as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_reserved_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).get_projid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_projid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dquot_operations>())).get_inode_usage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_inode_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).get_next_id as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_next_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: c_types::c_int,
    pub d_spc_hardlimit: u64,
    pub d_spc_softlimit: u64,
    pub d_ino_hardlimit: u64,
    pub d_ino_softlimit: u64,
    pub d_space: u64,
    pub d_ino_count: u64,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: c_types::c_int,
    pub d_spc_warns: c_types::c_int,
    pub d_rt_spc_hardlimit: u64,
    pub d_rt_spc_softlimit: u64,
    pub d_rt_space: u64,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: c_types::c_int,
}
#[test]
fn bindgen_test_layout_qc_dqblk() {
    assert_eq!(
        ::core::mem::size_of::<qc_dqblk>(),
        120usize,
        concat!("Size of: ", stringify!(qc_dqblk))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_fieldmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_hardlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_softlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_hardlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_softlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_space as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_timer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_timer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_warns as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_warns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_warns as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_warns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_hardlimit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_softlimit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_space as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_timer as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_warns as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_warns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_type_state {
    pub flags: c_types::c_uint,
    pub spc_timelimit: c_types::c_uint,
    pub ino_timelimit: c_types::c_uint,
    pub rt_spc_timelimit: c_types::c_uint,
    pub spc_warnlimit: c_types::c_uint,
    pub ino_warnlimit: c_types::c_uint,
    pub rt_spc_warnlimit: c_types::c_uint,
    pub ino: c_types::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[test]
fn bindgen_test_layout_qc_type_state() {
    assert_eq!(
        ::core::mem::size_of::<qc_type_state>(),
        56usize,
        concat!("Size of: ", stringify!(qc_type_state))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_type_state>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_type_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).spc_timelimit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino_timelimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).rt_spc_timelimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(rt_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).spc_warnlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino_warnlimit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).rt_spc_warnlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(rt_spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).blocks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).nextents as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(nextents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: c_types::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[test]
fn bindgen_test_layout_qc_state() {
    assert_eq!(
        ::core::mem::size_of::<qc_state>(),
        176usize,
        concat!("Size of: ", stringify!(qc_state))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_state>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_state>())).s_incoredqs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_state),
            "::",
            stringify!(s_incoredqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_state>())).s_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_state),
            "::",
            stringify!(s_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: c_types::c_int,
    pub i_flags: c_types::c_uint,
    pub i_spc_timelimit: c_types::c_uint,
    pub i_ino_timelimit: c_types::c_uint,
    pub i_rt_spc_timelimit: c_types::c_uint,
    pub i_spc_warnlimit: c_types::c_uint,
    pub i_ino_warnlimit: c_types::c_uint,
    pub i_rt_spc_warnlimit: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_qc_info() {
    assert_eq!(
        ::core::mem::size_of::<qc_info>(),
        32usize,
        concat!("Size of: ", stringify!(qc_info))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_info>(),
        4usize,
        concat!("Alignment of ", stringify!(qc_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_fieldmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_spc_timelimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_ino_timelimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_ino_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_rt_spc_timelimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_rt_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_spc_warnlimit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_ino_warnlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_ino_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_rt_spc_warnlimit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_rt_spc_warnlimit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: c_types::c_int,
            arg4: *const path,
        ) -> c_types::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *mut qc_info,
        ) -> c_types::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> c_types::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_quotactl_ops() {
    assert_eq!(
        ::core::mem::size_of::<quotactl_ops>(),
        88usize,
        concat!("Size of: ", stringify!(quotactl_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<quotactl_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(quotactl_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_on as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_enable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_disable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_sync as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).set_info as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(set_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_dqblk as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_nextdqblk as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_nextdqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).set_dqblk as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(set_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).rm_xquota as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(rm_xquota)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: c_types::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
#[test]
fn bindgen_test_layout_quota_format_type() {
    assert_eq!(
        ::core::mem::size_of::<quota_format_type>(),
        32usize,
        concat!("Size of: ", stringify!(quota_format_type))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_format_type>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_format_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_fmt_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_owner as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_next)
        )
    );
}
impl Default for quota_format_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: c_types::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
#[test]
fn bindgen_test_layout_quota_info() {
    assert_eq!(
        ::core::mem::size_of::<quota_info>(),
        312usize,
        concat!("Size of: ", stringify!(quota_info))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_info>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).dqio_sem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(dqio_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).files as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).info as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).ops as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for quota_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct writeback_control {
    _unused: [u8; 0],
}
pub const rw_hint_WRITE_LIFE_NOT_SET: rw_hint = 0;
pub const rw_hint_WRITE_LIFE_NONE: rw_hint = 1;
pub const rw_hint_WRITE_LIFE_SHORT: rw_hint = 2;
pub const rw_hint_WRITE_LIFE_MEDIUM: rw_hint = 3;
pub const rw_hint_WRITE_LIFE_LONG: rw_hint = 4;
pub const rw_hint_WRITE_LIFE_EXTREME: rw_hint = 5;
pub type rw_hint = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete: ::core::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, ret: c_types::c_long, ret2: c_types::c_long),
    >,
    pub private: *mut c_types::c_void,
    pub ki_flags: c_types::c_int,
    pub ki_hint: rw_hint,
}
#[test]
fn bindgen_test_layout_kiocb() {
    assert_eq!(
        ::core::mem::size_of::<kiocb>(),
        40usize,
        concat!("Size of: ", stringify!(kiocb))
    );
    assert_eq!(
        ::core::mem::align_of::<kiocb>(),
        8usize,
        concat!("Alignment of ", stringify!(kiocb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_filp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_filp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_complete as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).private as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_hint as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_hint)
        )
    );
}
impl Default for kiocb {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::core::option::Option<
        unsafe extern "C" fn(page: *mut page, wbc: *mut writeback_control) -> c_types::c_int,
    >,
    pub readpage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut page) -> c_types::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> c_types::c_int,
    >,
    pub set_page_dirty:
        ::core::option::Option<unsafe extern "C" fn(page: *mut page) -> c_types::c_int>,
    pub readpages: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            mapping: *mut address_space,
            pages: *mut list_head,
            nr_pages: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: c_types::c_uint,
            flags: c_types::c_uint,
            pagep: *mut *mut page,
            fsdata: *mut *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: c_types::c_uint,
            copied: c_types::c_uint,
            page: *mut page,
            fsdata: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidatepage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: c_types::c_uint, arg3: c_types::c_uint),
    >,
    pub releasepage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: gfp_t) -> c_types::c_int,
    >,
    pub freepage: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> isize,
    >,
    pub migratepage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut page,
            arg3: *mut page,
            arg4: migrate_mode,
        ) -> c_types::c_int,
    >,
    pub isolate_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: isolate_mode_t) -> bool_,
    >,
    pub putback_page: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub launder_page:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut page) -> c_types::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut page,
            arg2: c_types::c_ulong,
            arg3: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: *mut bool_, arg3: *mut bool_),
    >,
    pub error_remove_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> c_types::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> c_types::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
}
#[test]
fn bindgen_test_layout_address_space_operations() {
    assert_eq!(
        ::core::mem::size_of::<address_space_operations>(),
        168usize,
        concat!("Size of: ", stringify!(address_space_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<address_space_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(address_space_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).writepage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(writepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).readpage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(readpage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).writepages as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(writepages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).set_page_dirty as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(set_page_dirty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).readpages as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(readpages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).write_begin as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(write_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).write_end as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space_operations>())).bmap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(bmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).invalidatepage as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(invalidatepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).releasepage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(releasepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).freepage as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(freepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).direct_IO as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(direct_IO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).migratepage as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(migratepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).isolate_page as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(isolate_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).putback_page as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(putback_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).launder_page as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(launder_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).is_partially_uptodate as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(is_partially_uptodate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).is_dirty_writeback as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(is_dirty_writeback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).error_remove_page as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(error_remove_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).swap_activate as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_activate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).swap_deactivate as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_deactivate)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub page_tree: radix_tree_root,
    pub tree_lock: spinlock_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub i_mmap_rwsem: rw_semaphore,
    pub nrpages: c_types::c_ulong,
    pub nrexceptional: c_types::c_ulong,
    pub writeback_index: c_types::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: c_types::c_ulong,
    pub private_lock: spinlock_t,
    pub gfp_mask: gfp_t,
    pub private_list: list_head,
    pub private_data: *mut c_types::c_void,
    pub wb_err: errseq_t,
}
#[test]
fn bindgen_test_layout_address_space() {
    assert_eq!(
        ::core::mem::size_of::<address_space>(),
        168usize,
        concat!("Size of: ", stringify!(address_space))
    );
    assert_eq!(
        ::core::mem::align_of::<address_space>(),
        8usize,
        concat!("Alignment of ", stringify!(address_space))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).host as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).page_tree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(page_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).tree_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(tree_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap_writable as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap_writable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap_rwsem as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).nrpages as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(nrpages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).nrexceptional as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(nrexceptional)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).writeback_index as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(writeback_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).a_ops as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(a_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).flags as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_lock as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).gfp_mask as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_data as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).wb_err as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(wb_err)
        )
    );
}
impl Default for address_space {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_dev: dev_t,
    pub bd_openers: c_types::c_int,
    pub bd_inode: *mut inode,
    pub bd_super: *mut super_block,
    pub bd_mutex: mutex,
    pub bd_claiming: *mut c_types::c_void,
    pub bd_holder: *mut c_types::c_void,
    pub bd_holders: c_types::c_int,
    pub bd_write_holder: bool_,
    pub bd_holder_disks: list_head,
    pub bd_contains: *mut block_device,
    pub bd_block_size: c_types::c_uint,
    pub bd_partno: u8,
    pub bd_part: *mut hd_struct,
    pub bd_part_count: c_types::c_uint,
    pub bd_invalidated: c_types::c_int,
    pub bd_disk: *mut gendisk,
    pub bd_queue: *mut request_queue,
    pub bd_bdi: *mut backing_dev_info,
    pub bd_list: list_head,
    pub bd_private: c_types::c_ulong,
    pub bd_fsfreeze_count: c_types::c_int,
    pub bd_fsfreeze_mutex: mutex,
}
#[test]
fn bindgen_test_layout_block_device() {
    assert_eq!(
        ::core::mem::size_of::<block_device>(),
        216usize,
        concat!("Size of: ", stringify!(block_device))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_openers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_openers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_inode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_super as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_mutex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_claiming as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_claiming)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holders as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_write_holder as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_write_holder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder_disks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holder_disks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_contains as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_contains)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_block_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_partno as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_partno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_part as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_part)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_part_count as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_part_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_invalidated as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_invalidated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_disk as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_queue as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_bdi as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_list as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_private as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_count as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_fsfreeze_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_mutex as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_fsfreeze_mutex)
        )
    );
}
impl Default for block_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: c_types::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: c_types::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut c_types::c_void,
    pub i_ino: c_types::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime: timespec,
    pub i_mtime: timespec,
    pub i_ctime: timespec,
    pub i_lock: spinlock_t,
    pub i_bytes: c_types::c_ushort,
    pub i_blkbits: c_types::c_uint,
    pub i_write_hint: rw_hint,
    pub i_blocks: blkcnt_t,
    pub i_state: c_types::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: c_types::c_ulong,
    pub dirtied_time_when: c_types::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_wb: *mut bdi_writeback,
    pub i_wb_frn_winner: c_types::c_int,
    pub i_wb_frn_avg_time: u16,
    pub i_wb_frn_history: u16,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: u64,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub i_fop: *const file_operations,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_crypt_info: *mut fscrypt_info,
    pub i_private: *mut c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: c_types::c_uint,
    pub __i_nlink: c_types::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_1>())).i_nlink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_1),
            "::",
            stringify!(i_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_1>())).__i_nlink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_1),
            "::",
            stringify!(__i_nlink)
        )
    );
}
impl Default for inode__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_2>())).i_dentry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_2),
            "::",
            stringify!(i_dentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_2>())).i_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_2),
            "::",
            stringify!(i_rcu)
        )
    );
}
impl Default for inode__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_bdev: *mut block_device,
    pub i_cdev: *mut cdev,
    pub i_link: *mut c_types::c_char,
    pub i_dir_seq: c_types::c_uint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_pipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_bdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_bdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_cdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_cdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_dir_seq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_dir_seq)
        )
    );
}
impl Default for inode__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_inode() {
    assert_eq!(
        ::core::mem::size_of::<inode>(),
        608usize,
        concat!("Size of: ", stringify!(inode))
    );
    assert_eq!(
        ::core::mem::align_of::<inode>(),
        8usize,
        concat!("Alignment of ", stringify!(inode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_opflags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_opflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_acl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_default_acl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_default_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_op as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mapping as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_security as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_ino as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_rdev as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_atime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mtime as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_ctime as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_bytes as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_blkbits as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_blkbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_write_hint as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_blocks as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_state as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_rwsem as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).dirtied_when as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(dirtied_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).dirtied_time_when as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(dirtied_time_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_hash as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_io_list as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_io_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_winner as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_winner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_avg_time as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_avg_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_history as *const _ as usize },
        270usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_history)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_lru as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sb_list as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_list as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_version as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sequence as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_count as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_dio_count as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_dio_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_writecount as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_writecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_readcount as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_readcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_fop as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_flctx as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_flctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_data as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_devices as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_generation as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_fsnotify_mask as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fsnotify_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_fsnotify_marks as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fsnotify_marks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_crypt_info as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_crypt_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_private as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_private)
        )
    );
}
impl Default for inode {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: c_types::c_int,
}
#[test]
fn bindgen_test_layout_fown_struct() {
    assert_eq!(
        ::core::mem::size_of::<fown_struct>(),
        32usize,
        concat!("Size of: ", stringify!(fown_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<fown_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(fown_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).pid_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(pid_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).euid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).signum as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(signum)
        )
    );
}
impl Default for fown_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_ra_state {
    pub start: c_types::c_ulong,
    pub size: c_types::c_uint,
    pub async_size: c_types::c_uint,
    pub ra_pages: c_types::c_uint,
    pub mmap_miss: c_types::c_uint,
    pub prev_pos: loff_t,
}
#[test]
fn bindgen_test_layout_file_ra_state() {
    assert_eq!(
        ::core::mem::size_of::<file_ra_state>(),
        32usize,
        concat!("Size of: ", stringify!(file_ra_state))
    );
    assert_eq!(
        ::core::mem::align_of::<file_ra_state>(),
        8usize,
        concat!("Alignment of ", stringify!(file_ra_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).async_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(async_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).ra_pages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(ra_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).mmap_miss as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(mmap_miss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).prev_pos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(prev_pos)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub f_u: file__bindgen_ty_1,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_lock: spinlock_t,
    pub f_write_hint: rw_hint,
    pub f_count: atomic_long_t,
    pub f_flags: c_types::c_uint,
    pub f_mode: fmode_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_version: u64,
    pub f_security: *mut c_types::c_void,
    pub private_data: *mut c_types::c_void,
    pub f_ep_links: list_head,
    pub f_tfile_llink: list_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub fu_llist: llist_node,
    pub fu_rcuhead: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_file__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(file__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<file__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(file__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file__bindgen_ty_1>())).fu_llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(fu_llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file__bindgen_ty_1>())).fu_rcuhead as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(fu_rcuhead)
        )
    );
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file() {
    assert_eq!(
        ::core::mem::size_of::<file>(),
        256usize,
        concat!("Size of: ", stringify!(file))
    );
    assert_eq!(
        ::core::mem::align_of::<file>(),
        8usize,
        concat!("Alignment of ", stringify!(file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_u as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(file), "::", stringify!(f_u))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_path as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_inode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_op as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_write_hint as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_mode as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_pos_lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_pos_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_pos as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_owner as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_cred as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_ra as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_ra)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_version as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_security as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).private_data as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_ep_links as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_ep_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_tfile_llink as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_tfile_llink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_mapping as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_wb_err as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_wb_err)
        )
    );
}
impl Default for file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type fl_owner_t = *mut c_types::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_lock_operations {
    pub fl_copy_lock:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock)>,
    pub fl_release_private: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
}
#[test]
fn bindgen_test_layout_file_lock_operations() {
    assert_eq!(
        ::core::mem::size_of::<file_lock_operations>(),
        16usize,
        concat!("Size of: ", stringify!(file_lock_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock_operations>())).fl_copy_lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_operations),
            "::",
            stringify!(fl_copy_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock_operations>())).fl_release_private as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_operations),
            "::",
            stringify!(fl_release_private)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lock_manager_operations {
    pub lm_compare_owner: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock) -> c_types::c_int,
    >,
    pub lm_owner_key:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> c_types::c_ulong>,
    pub lm_get_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t) -> fl_owner_t>,
    pub lm_put_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t)>,
    pub lm_notify: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
    pub lm_grant: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub lm_break: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: c_types::c_int,
            arg3: *mut list_head,
        ) -> c_types::c_int,
    >,
    pub lm_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut *mut c_types::c_void),
    >,
}
#[test]
fn bindgen_test_layout_lock_manager_operations() {
    assert_eq!(
        ::core::mem::size_of::<lock_manager_operations>(),
        72usize,
        concat!("Size of: ", stringify!(lock_manager_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_manager_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_manager_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_compare_owner as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_compare_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_owner_key as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_owner_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_get_owner as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_get_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_put_owner as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_put_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_notify as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_notify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_grant as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_grant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_break as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_break)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_change as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_setup as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_setup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlm_lockowner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_lock_info {
    pub state: u32,
    pub owner: *mut nlm_lockowner,
    pub list: list_head,
}
#[test]
fn bindgen_test_layout_nfs_lock_info() {
    assert_eq!(
        ::core::mem::size_of::<nfs_lock_info>(),
        32usize,
        concat!("Size of: ", stringify!(nfs_lock_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nfs_lock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nfs_lock_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(list)
        )
    );
}
impl Default for nfs_lock_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_info {
    pub owner: *mut nfs4_lock_state,
}
#[test]
fn bindgen_test_layout_nfs4_lock_info() {
    assert_eq!(
        ::core::mem::size_of::<nfs4_lock_info>(),
        8usize,
        concat!("Size of: ", stringify!(nfs4_lock_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nfs4_lock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nfs4_lock_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs4_lock_info>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs4_lock_info),
            "::",
            stringify!(owner)
        )
    );
}
impl Default for nfs4_lock_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    pub fl_next: *mut file_lock,
    pub fl_list: list_head,
    pub fl_link: hlist_node,
    pub fl_block: list_head,
    pub fl_owner: fl_owner_t,
    pub fl_flags: c_types::c_uint,
    pub fl_type: c_types::c_uchar,
    pub fl_pid: c_types::c_uint,
    pub fl_link_cpu: c_types::c_int,
    pub fl_wait: wait_queue_head_t,
    pub fl_file: *mut file,
    pub fl_start: loff_t,
    pub fl_end: loff_t,
    pub fl_fasync: *mut fasync_struct,
    pub fl_break_time: c_types::c_ulong,
    pub fl_downgrade_time: c_types::c_ulong,
    pub fl_ops: *const file_lock_operations,
    pub fl_lmops: *const lock_manager_operations,
    pub fl_u: file_lock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file_lock__bindgen_ty_1 {
    pub nfs_fl: nfs_lock_info,
    pub nfs4_fl: nfs4_lock_info,
    pub afs: file_lock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock__bindgen_ty_1__bindgen_ty_1 {
    pub link: list_head,
    pub state: c_types::c_int,
}
#[test]
fn bindgen_test_layout_file_lock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file_lock__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).link as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).state as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
}
impl Default for file_lock__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file_lock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file_lock__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(file_lock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).nfs_fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(nfs_fl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).nfs4_fl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(nfs4_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).afs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(afs)
        )
    );
}
impl Default for file_lock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file_lock() {
    assert_eq!(
        ::core::mem::size_of::<file_lock>(),
        200usize,
        concat!("Size of: ", stringify!(file_lock))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_link as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_block as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_owner as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_type as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_pid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_link_cpu as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_link_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_wait as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_file as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_start as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_end as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_fasync as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_fasync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_break_time as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_break_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_downgrade_time as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_downgrade_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_ops as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_lmops as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_lmops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_u as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_u)
        )
    );
}
impl Default for file_lock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock_context {
    pub flc_lock: spinlock_t,
    pub flc_flock: list_head,
    pub flc_posix: list_head,
    pub flc_lease: list_head,
}
#[test]
fn bindgen_test_layout_file_lock_context() {
    assert_eq!(
        ::core::mem::size_of::<file_lock_context>(),
        56usize,
        concat!("Size of: ", stringify!(file_lock_context))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock_context>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_flock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_flock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_posix as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_posix)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_lease as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_lease)
        )
    );
}
impl Default for file_lock_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct files_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: spinlock_t,
    pub magic: c_types::c_int,
    pub fa_fd: c_types::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
#[test]
fn bindgen_test_layout_fasync_struct() {
    assert_eq!(
        ::core::mem::size_of::<fasync_struct>(),
        48usize,
        concat!("Size of: ", stringify!(fasync_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<fasync_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(fasync_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).magic as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_file as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_rcu)
        )
    );
}
impl Default for fasync_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: c_types::c_int,
    pub wait_unfrozen: wait_queue_head_t,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
#[test]
fn bindgen_test_layout_sb_writers() {
    assert_eq!(
        ::core::mem::size_of::<sb_writers>(),
        416usize,
        concat!("Size of: ", stringify!(sb_writers))
    );
    assert_eq!(
        ::core::mem::align_of::<sb_writers>(),
        8usize,
        concat!("Alignment of ", stringify!(sb_writers))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).frozen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(frozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).wait_unfrozen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(wait_unfrozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).rw_sem as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(rw_sem)
        )
    );
}
impl Default for sb_writers {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: c_types::c_uchar,
    pub s_blocksize: c_types::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: c_types::c_ulong,
    pub s_iflags: c_types::c_ulong,
    pub s_magic: c_types::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: c_types::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut c_types::c_void,
    pub s_xattr: *mut *mut xattr_handler,
    pub s_cop: *const fscrypt_operations,
    pub s_anon: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: c_types::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_id: [c_types::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_fs_info: *mut c_types::c_void,
    pub s_max_links: c_types::c_uint,
    pub s_mode: fmode_t,
    pub s_time_gran: u32,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *mut c_types::c_char,
    pub s_d_op: *const dentry_operations,
    pub cleancache_poolid: c_types::c_int,
    pub s_shrink: shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_readonly_remount: c_types::c_int,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub __bindgen_padding_0: [u64; 4usize],
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: c_types::c_int,
    pub __bindgen_padding_1: [u32; 3usize],
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
}
#[test]
fn bindgen_test_layout_super_block() {
    assert_eq!(
        ::core::mem::size_of::<super_block>(),
        1472usize,
        concat!("Size of: ", stringify!(super_block))
    );
    assert_eq!(
        ::core::mem::align_of::<super_block>(),
        64usize,
        concat!("Alignment of ", stringify!(super_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_blocksize_bits as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_blocksize_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_blocksize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_blocksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_maxbytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_maxbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_op as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).dq_op as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(dq_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_qcop as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_qcop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_export_op as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_export_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_iflags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_iflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_magic as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_root as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_umount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_umount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_count as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_active as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_security as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_xattr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_xattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_cop as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_cop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_anon as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_anon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mounts as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mounts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_bdev as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_bdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_bdi as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mtd as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mtd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_instances as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_quota_types as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_quota_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dquot as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_writers as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_id as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_uuid as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_fs_info as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fs_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_max_links as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_max_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mode as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_time_gran as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_time_gran)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_vfs_rename_mutex as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_vfs_rename_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_subtype as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_d_op as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_d_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).cleancache_poolid as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(cleancache_poolid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_shrink as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_shrink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_remove_count as *const _ as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_remove_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_readonly_remount as *const _ as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_readonly_remount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dio_done_wq as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dio_done_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_pins as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_pins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_user_ns as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dentry_lru as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dentry_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inode_lru as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).rcu as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).destroy_work as *const _ as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(destroy_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_sync_lock as *const _ as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_sync_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_stack_depth as *const _ as usize },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_stack_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inode_list_lock as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inodes as *const _ as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inodes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_block>())).s_inode_wblist_lock as *const _ as usize
        },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_wblist_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inodes_wb as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inodes_wb)
        )
    );
}
impl Default for super_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent_info {
    pub fi_flags: c_types::c_uint,
    pub fi_extents_mapped: c_types::c_uint,
    pub fi_extents_max: c_types::c_uint,
    pub fi_extents_start: *mut fiemap_extent,
}
#[test]
fn bindgen_test_layout_fiemap_extent_info() {
    assert_eq!(
        ::core::mem::size_of::<fiemap_extent_info>(),
        24usize,
        concat!("Size of: ", stringify!(fiemap_extent_info))
    );
    assert_eq!(
        ::core::mem::align_of::<fiemap_extent_info>(),
        8usize,
        concat!("Alignment of ", stringify!(fiemap_extent_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent_info>())).fi_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_mapped as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_mapped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_max as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_start as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_start)
        )
    );
}
impl Default for fiemap_extent_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const c_types::c_char,
        arg3: c_types::c_int,
        arg4: loff_t,
        arg5: u64,
        arg6: c_types::c_uint,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
#[test]
fn bindgen_test_layout_dir_context() {
    assert_eq!(
        ::core::mem::size_of::<dir_context>(),
        16usize,
        concat!("Size of: ", stringify!(dir_context))
    );
    assert_eq!(
        ::core::mem::align_of::<dir_context>(),
        8usize,
        concat!("Alignment of ", stringify!(dir_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dir_context>())).actor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_context),
            "::",
            stringify!(actor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dir_context>())).pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_context),
            "::",
            stringify!(pos)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: c_types::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const c_types::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: c_types::c_int) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut c_types::c_char,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: bool_,
        ) -> c_types::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> c_types::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *const c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry, arg3: umode_t) -> c_types::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: dev_t,
        ) -> c_types::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut inode,
            arg4: *mut dentry,
            arg5: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut iattr) -> c_types::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const path,
            arg2: *mut kstat,
            arg3: u32,
            arg4: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut c_types::c_char, arg3: usize) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64,
            len: u64,
        ) -> c_types::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut timespec,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: c_types::c_uint,
            create_mode: umode_t,
            opened: *mut c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry, arg3: umode_t) -> c_types::c_int,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut posix_acl,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_inode_operations() {
    assert_eq!(
        ::core::mem::size_of::<inode_operations>(),
        192usize,
        concat!("Size of: ", stringify!(inode_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<inode_operations>(),
        64usize,
        concat!("Alignment of ", stringify!(inode_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).lookup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).get_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(get_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).permission as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(permission)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).get_acl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(get_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).readlink as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(readlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).create as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).link as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).unlink as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(unlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).symlink as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(symlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).mkdir as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).rmdir as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).mknod as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(mknod)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).rename as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).setattr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(setattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).getattr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(getattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).listxattr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(listxattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).fiemap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(fiemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).update_time as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(update_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).atomic_open as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(atomic_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).tmpfile as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(tmpfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).set_acl as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(set_acl)
        )
    );
}
impl Default for inode_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: c_types::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> c_types::c_int,
    >,
    pub drop_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> c_types::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, wait: c_types::c_int) -> c_types::c_int,
    >,
    pub freeze_super:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub freeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub thaw_super:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub unfreeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> c_types::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut c_types::c_int,
            arg3: *mut c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub quota_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *mut c_types::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub quota_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *const c_types::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub get_dquots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub bdev_try_to_free_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut page,
            arg3: gfp_t,
        ) -> c_types::c_int,
    >,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> c_types::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> c_types::c_long,
    >,
    pub real_loop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> *mut file>,
}
#[test]
fn bindgen_test_layout_super_operations() {
    assert_eq!(
        ::core::mem::size_of::<super_operations>(),
        208usize,
        concat!("Size of: ", stringify!(super_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<super_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(super_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).alloc_inode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(alloc_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).destroy_inode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(destroy_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).dirty_inode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(dirty_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).write_inode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(write_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).drop_inode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(drop_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).evict_inode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(evict_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).put_super as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(put_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).sync_fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(sync_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).freeze_super as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(freeze_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).freeze_fs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(freeze_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).thaw_super as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(thaw_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).unfreeze_fs as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(unfreeze_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).statfs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(statfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).remount_fs as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(remount_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).umount_begin as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(umount_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_options as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_devname as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_devname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_path as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_stats as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).quota_read as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(quota_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).quota_write as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(quota_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).get_dquots as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(get_dquots)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).bdev_try_to_free_page as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(bdev_try_to_free_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).nr_cached_objects as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(nr_cached_objects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).free_cached_objects as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(free_cached_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).real_loop as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(real_loop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_system_type {
    pub name: *const c_types::c_char,
    pub fs_flags: c_types::c_int,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: c_types::c_int,
            arg3: *const c_types::c_char,
            arg4: *mut c_types::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
#[test]
fn bindgen_test_layout_file_system_type() {
    assert_eq!(
        ::core::mem::size_of::<file_system_type>(),
        56usize,
        concat!("Size of: ", stringify!(file_system_type))
    );
    assert_eq!(
        ::core::mem::align_of::<file_system_type>(),
        8usize,
        concat!("Alignment of ", stringify!(file_system_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).fs_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(fs_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).mount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(mount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).kill_sb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(kill_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).fs_supers as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(fs_supers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_lock_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_umount_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_umount_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_system_type>())).s_vfs_rename_key as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_vfs_rename_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_writers_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_writers_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).i_lock_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).i_mutex_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_mutex_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_system_type>())).i_mutex_dir_key as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_mutex_dir_key)
        )
    );
}
impl Default for file_system_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mount_nodev(
        fs_type: *mut file_system_type,
        flags: c_types::c_int,
        data: *mut c_types::c_void,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut c_types::c_void,
                arg3: c_types::c_int,
            ) -> c_types::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn kill_litter_super(sb: *mut super_block);
}
extern "C" {
    pub fn register_filesystem(arg1: *mut file_system_type) -> c_types::c_int;
}
extern "C" {
    pub fn unregister_filesystem(arg1: *mut file_system_type) -> c_types::c_int;
}
extern "C" {
    pub fn alloc_chrdev_region(
        arg1: *mut dev_t,
        arg2: c_types::c_uint,
        arg3: c_types::c_uint,
        arg4: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn unregister_chrdev_region(arg1: dev_t, arg2: c_types::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsproxy {
    _unused: [u8; 0],
}
pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        ctl: *mut ctl_table,
        write: c_types::c_int,
        buffer: *mut c_types::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_ctl_table_poll() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_poll>(),
        32usize,
        concat!("Size of: ", stringify!(ctl_table_poll))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_poll>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_poll))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_poll>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_poll),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_poll>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_poll),
            "::",
            stringify!(wait)
        )
    );
}
impl Default for ctl_table_poll {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table {
    pub procname: *const c_types::c_char,
    pub data: *mut c_types::c_void,
    pub maxlen: c_types::c_int,
    pub mode: umode_t,
    pub child: *mut ctl_table,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut c_types::c_void,
    pub extra2: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_ctl_table() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table>(),
        64usize,
        concat!("Size of: ", stringify!(ctl_table))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).procname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(procname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).maxlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).child as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).proc_handler as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(proc_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).poll as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).extra1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).extra2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(extra2)
        )
    );
}
impl Default for ctl_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
#[test]
fn bindgen_test_layout_ctl_node() {
    assert_eq!(
        ::core::mem::size_of::<ctl_node>(),
        32usize,
        concat!("Size of: ", stringify!(ctl_node))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_node>())).header as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_node),
            "::",
            stringify!(header)
        )
    );
}
impl Default for ctl_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub used: c_types::c_int,
    pub count: c_types::c_int,
    pub nreg: c_types::c_int,
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).ctl_table
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ctl_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).used
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).count
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).nreg
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nreg)
        )
    );
}
impl Default for ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(ctl_table_header__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1>())).rcu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for ctl_table_header__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ctl_table_header() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header>(),
        80usize,
        concat!("Size of: ", stringify!(ctl_table_header))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).unregistering as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(unregistering)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).ctl_table_arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(ctl_table_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).set as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).parent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).node as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).inodes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(inodes)
        )
    );
}
impl Default for ctl_table_header {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
#[test]
fn bindgen_test_layout_ctl_dir() {
    assert_eq!(
        ::core::mem::size_of::<ctl_dir>(),
        88usize,
        concat!("Size of: ", stringify!(ctl_dir))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_dir>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_dir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_dir>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_dir),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_dir>())).root as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_dir),
            "::",
            stringify!(root)
        )
    );
}
impl Default for ctl_dir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctl_table_set) -> c_types::c_int>,
    pub dir: ctl_dir,
}
#[test]
fn bindgen_test_layout_ctl_table_set() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_set>(),
        96usize,
        concat!("Size of: ", stringify!(ctl_table_set))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_set>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_set>())).is_seen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_set),
            "::",
            stringify!(is_seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_set>())).dir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_set),
            "::",
            stringify!(dir)
        )
    );
}
impl Default for ctl_table_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(head: *mut ctl_table_header, table: *mut ctl_table) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_ctl_table_root() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_root>(),
        120usize,
        concat!("Size of: ", stringify!(ctl_table_root))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_root>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).default_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(default_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).lookup as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).set_ownership as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(set_ownership)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).permissions as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(permissions)
        )
    );
}
impl Default for ctl_table_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn register_sysctl(
        path: *const c_types::c_char,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn unregister_sysctl_table(table: *mut ctl_table_header);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_assoc_array() {
    assert_eq!(
        ::core::mem::size_of::<assoc_array>(),
        16usize,
        concat!("Size of: ", stringify!(assoc_array))
    );
    assert_eq!(
        ::core::mem::align_of::<assoc_array>(),
        8usize,
        concat!("Alignment of ", stringify!(assoc_array))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<assoc_array>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<assoc_array>())).nr_leaves_on_tree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array),
            "::",
            stringify!(nr_leaves_on_tree)
        )
    );
}
impl Default for assoc_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keyring_index_key {
    pub type_: *mut key_type,
    pub description: *const c_types::c_char,
    pub desc_len: usize,
}
#[test]
fn bindgen_test_layout_keyring_index_key() {
    assert_eq!(
        ::core::mem::size_of::<keyring_index_key>(),
        24usize,
        concat!("Size of: ", stringify!(keyring_index_key))
    );
    assert_eq!(
        ::core::mem::align_of::<keyring_index_key>(),
        8usize,
        concat!("Alignment of ", stringify!(keyring_index_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<keyring_index_key>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<keyring_index_key>())).description as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<keyring_index_key>())).desc_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(desc_len)
        )
    );
}
impl Default for keyring_index_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut c_types::c_void,
    pub data: [*mut c_types::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_key_payload() {
    assert_eq!(
        ::core::mem::size_of::<key_payload>(),
        32usize,
        concat!("Size of: ", stringify!(key_payload))
    );
    assert_eq!(
        ::core::mem::align_of::<key_payload>(),
        8usize,
        concat!("Alignment of ", stringify!(key_payload))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_payload>())).rcu_data0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_payload),
            "::",
            stringify!(rcu_data0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_payload>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_payload),
            "::",
            stringify!(data)
        )
    );
}
impl Default for key_payload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        dest_keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
#[test]
fn bindgen_test_layout_key_restriction() {
    assert_eq!(
        ::core::mem::size_of::<key_restriction>(),
        24usize,
        concat!("Size of: ", stringify!(key_restriction))
    );
    assert_eq!(
        ::core::mem::align_of::<key_restriction>(),
        8usize,
        concat!("Alignment of ", stringify!(key_restriction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_restriction>())).check as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_restriction>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_restriction>())).keytype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(keytype)
        )
    );
}
impl Default for key_restriction {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut c_types::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: c_types::c_ushort,
    pub datalen: c_types::c_ushort,
    pub state: c_types::c_short,
    pub flags: c_types::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_1>())).graveyard_link as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_1),
            "::",
            stringify!(graveyard_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_1>())).serial_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_1),
            "::",
            stringify!(serial_node)
        )
    );
}
impl Default for key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_2>())).expiry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_2),
            "::",
            stringify!(expiry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_2>())).revoked_at as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_2),
            "::",
            stringify!(revoked_at)
        )
    );
}
impl Default for key__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub type_: *mut key_type,
    pub description: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_3__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).description as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(description)
        )
    );
}
impl Default for key__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_3>(),
        24usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_3>())).index_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3),
            "::",
            stringify!(index_key)
        )
    );
}
impl Default for key__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_4__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_4__bindgen_ty_1>())).name_link as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(name_link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_4__bindgen_ty_1>())).keys as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(keys)
        )
    );
}
impl Default for key__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_4>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for key__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_key() {
    assert_eq!(
        ::core::mem::size_of::<key>(),
        200usize,
        concat!("Size of: ", stringify!(key))
    );
    assert_eq!(
        ::core::mem::align_of::<key>(),
        8usize,
        concat!("Alignment of ", stringify!(key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).serial as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).sem as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(sem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).user as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(user))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).security as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).last_used_at as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(last_used_at)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).uid as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(uid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).gid as *const _ as usize },
        108usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(gid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).perm as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(perm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).quotalen as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(quotalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).datalen as *const _ as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).state as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).restrict_link as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(restrict_link)
        )
    );
}
impl Default for key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
#[test]
fn bindgen_test_layout_sysv_sem() {
    assert_eq!(
        ::core::mem::size_of::<sysv_sem>(),
        8usize,
        concat!("Size of: ", stringify!(sysv_sem))
    );
    assert_eq!(
        ::core::mem::align_of::<sysv_sem>(),
        8usize,
        concat!("Alignment of ", stringify!(sysv_sem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysv_sem>())).undo_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysv_sem),
            "::",
            stringify!(undo_list)
        )
    );
}
impl Default for sysv_sem {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
#[test]
fn bindgen_test_layout_sysv_shm() {
    assert_eq!(
        ::core::mem::size_of::<sysv_shm>(),
        16usize,
        concat!("Size of: ", stringify!(sysv_shm))
    );
    assert_eq!(
        ::core::mem::align_of::<sysv_shm>(),
        8usize,
        concat!("Alignment of ", stringify!(sysv_shm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysv_shm>())).shm_clist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysv_shm),
            "::",
            stringify!(shm_clist)
        )
    );
}
impl Default for sysv_shm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_node {
    pub prio: c_types::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
#[test]
fn bindgen_test_layout_plist_node() {
    assert_eq!(
        ::core::mem::size_of::<plist_node>(),
        40usize,
        concat!("Size of: ", stringify!(plist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<plist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(plist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).prio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).prio_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(prio_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).node_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(node_list)
        )
    );
}
impl Default for plist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
#[test]
fn bindgen_test_layout_timerqueue_node() {
    assert_eq!(
        ::core::mem::size_of::<timerqueue_node>(),
        32usize,
        concat!("Size of: ", stringify!(timerqueue_node))
    );
    assert_eq!(
        ::core::mem::align_of::<timerqueue_node>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_node>())).expires as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(expires)
        )
    );
}
impl Default for timerqueue_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_head {
    pub head: rb_root,
    pub next: *mut timerqueue_node,
}
#[test]
fn bindgen_test_layout_timerqueue_head() {
    assert_eq!(
        ::core::mem::size_of::<timerqueue_head>(),
        16usize,
        concat!("Size of: ", stringify!(timerqueue_head))
    );
    assert_eq!(
        ::core::mem::align_of::<timerqueue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_head),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_head>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_head),
            "::",
            stringify!(next)
        )
    );
}
impl Default for timerqueue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = i32;
#[doc = " struct hrtimer - the basic hrtimer structure"]
#[doc = " @node:\ttimerqueue node, which also manages node.expires,"]
#[doc = "\t\tthe absolute expiry time in the hrtimers internal"]
#[doc = "\t\trepresentation. The time is related to the clock on"]
#[doc = "\t\twhich the timer is based. Is setup by adding"]
#[doc = "\t\tslack to the _softexpires value. For non range timers"]
#[doc = "\t\tidentical to _softexpires."]
#[doc = " @_softexpires: the absolute earliest expiry time of the hrtimer."]
#[doc = "\t\tThe time which was given as expiry time when the timer"]
#[doc = "\t\twas armed."]
#[doc = " @function:\ttimer expiry callback function"]
#[doc = " @base:\tpointer to the timer base (per cpu and per clock)"]
#[doc = " @state:\tstate information (See bit values above)"]
#[doc = " @is_rel:\tSet if the timer was armed relative"]
#[doc = ""]
#[doc = " The hrtimer structure must be initialized by hrtimer_init()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8,
    pub is_rel: u8,
}
#[test]
fn bindgen_test_layout_hrtimer() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer>(),
        8usize,
        concat!("Alignment of ", stringify!(hrtimer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>()))._softexpires as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(_softexpires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).function as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).is_rel as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_rel)
        )
    );
}
impl Default for hrtimer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct hrtimer_clock_base - the timer base for a specific clock"]
#[doc = " @cpu_base:\t\tper cpu clock base"]
#[doc = " @index:\t\tclock type index for per_cpu support when moving a"]
#[doc = "\t\t\ttimer to a base on another cpu."]
#[doc = " @clockid:\t\tclock id for per_cpu support"]
#[doc = " @active:\t\tred black tree root node for the active timers"]
#[doc = " @get_time:\t\tfunction to retrieve the current time of the clock"]
#[doc = " @offset:\t\toffset of this clock to the monotonic base"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: c_types::c_int,
    pub clockid: clockid_t,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
#[test]
fn bindgen_test_layout_hrtimer_clock_base() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Alignment of ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).cpu_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(cpu_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).clockid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).active as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).get_time as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(get_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).offset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for hrtimer_clock_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub seq: seqcount_t,
    pub running: *mut hrtimer,
    pub cpu: c_types::c_uint,
    pub active_bases: c_types::c_uint,
    pub clock_was_set_seq: c_types::c_uint,
    pub migration_enabled: bool_,
    pub nohz_active: bool_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub nr_events: c_types::c_uint,
    pub nr_retries: c_types::c_uint,
    pub nr_hangs: c_types::c_uint,
    pub max_hang_time: c_types::c_uint,
    pub clock_base: [hrtimer_clock_base; 4usize],
}
#[test]
fn bindgen_test_layout_hrtimer_cpu_base() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer_cpu_base>(),
        320usize,
        concat!("Size of: ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer_cpu_base>(),
        64usize,
        concat!("Alignment of ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).running as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).cpu as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).active_bases as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(active_bases)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hrtimer_cpu_base>())).clock_was_set_seq as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_was_set_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hrtimer_cpu_base>())).migration_enabled as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(migration_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nohz_active as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nohz_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).expires_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(expires_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).next_timer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(next_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_events as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_retries as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_hangs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_hangs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).max_hang_time as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(max_hang_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).clock_base as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_base)
        )
    );
}
impl Default for hrtimer_cpu_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn in_hrtirq(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hres_active(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_hrtirq: c_types::c_uint,
        hres_active: c_types::c_uint,
        hang_detected: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_filter {
    _unused: [u8; 0],
}
#[doc = " struct seccomp - the state of a seccomp'ed process"]
#[doc = ""]
#[doc = " @mode:  indicates one of the valid values above for controlled"]
#[doc = "         system calls available to a process."]
#[doc = " @filter: must always point to a valid seccomp-filter or NULL as it is"]
#[doc = "          accessed without locking during system call entry."]
#[doc = ""]
#[doc = "          @filter must only be accessed from the context of current as there"]
#[doc = "          is no read locking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp {
    pub mode: c_types::c_int,
    pub filter: *mut seccomp_filter,
}
#[test]
fn bindgen_test_layout_seccomp() {
    assert_eq!(
        ::core::mem::size_of::<seccomp>(),
        16usize,
        concat!("Size of: ", stringify!(seccomp))
    );
    assert_eq!(
        ::core::mem::align_of::<seccomp>(),
        8usize,
        concat!("Alignment of ", stringify!(seccomp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seccomp>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seccomp>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(filter)
        )
    );
}
impl Default for seccomp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigset_t {
    pub sig: [c_types::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<sigset_t>(),
        8usize,
        concat!("Size of: ", stringify!(sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigset_t>())).sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigset_t),
            "::",
            stringify!(sig)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: c_types::c_int,
    pub sival_ptr: *mut c_types::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::core::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::core::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
impl Default for sigval {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sigval_t = sigval;
#[repr(C)]
pub struct siginfo {
    pub si_signo: c_types::c_int,
    pub si_errno: c_types::c_int,
    pub si_code: c_types::c_int,
    pub _sifields: siginfo__bindgen_ty_1,
}
#[repr(C)]
pub struct siginfo__bindgen_ty_1 {
    pub _pad: __BindgenUnionField<[c_types::c_int; 28usize]>,
    pub _kill: __BindgenUnionField<siginfo__bindgen_ty_1__bindgen_ty_1>,
    pub _timer: __BindgenUnionField<siginfo__bindgen_ty_1__bindgen_ty_2>,
    pub _rt: __BindgenUnionField<siginfo__bindgen_ty_1__bindgen_ty_3>,
    pub _sigchld: __BindgenUnionField<siginfo__bindgen_ty_1__bindgen_ty_4>,
    pub _sigfault: __BindgenUnionField<siginfo__bindgen_ty_1__bindgen_ty_5>,
    pub _sigpoll: __BindgenUnionField<siginfo__bindgen_ty_1__bindgen_ty_6>,
    pub _sigsys: __BindgenUnionField<siginfo__bindgen_ty_1__bindgen_ty_7>,
    pub bindgen_union_field: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>()))._pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>()))._uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_uid)
        )
    );
}
#[repr(C)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: c_types::c_int,
    pub _pad: __IncompleteArrayField<c_types::c_char>,
    pub _sigval: sigval_t,
    pub _sys_private: c_types::c_int,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._tid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._pad as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_sigval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._sys_private
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_sys_private)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_3>()))._pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_3>()))._uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_3>()))._sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_sigval)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: c_types::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._utime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._stime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub _addr: *mut c_types::c_void,
    pub _addr_lsb: c_types::c_short,
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __u32,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut c_types::c_void,
    pub _upper: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & (* (:: core :: ptr :: null :: < siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > ())) . _lower as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            & (* (:: core :: ptr :: null :: < siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > ())) . _upper as * const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._addr_bnd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_5>()))._addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_5>()))._addr_lsb as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_addr_lsb)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_6 {
    pub _band: c_types::c_long,
    pub _fd: c_types::c_int,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_6>()))._band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_6>()))._fd as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut c_types::c_void,
    pub _syscall: c_types::c_int,
    pub _arch: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._sigchld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._sigfault as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._sigpoll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
impl Default for siginfo__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo() {
    assert_eq!(
        ::core::mem::size_of::<siginfo>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(_sifields)
        )
    );
}
impl Default for siginfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
#[test]
fn bindgen_test_layout_sigpending() {
    assert_eq!(
        ::core::mem::size_of::<sigpending>(),
        24usize,
        concat!("Size of: ", stringify!(sigpending))
    );
    assert_eq!(
        ::core::mem::align_of::<sigpending>(),
        8usize,
        concat!("Alignment of ", stringify!(sigpending))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigpending>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigpending),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigpending>())).signal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigpending),
            "::",
            stringify!(signal)
        )
    );
}
impl Default for sigpending {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_io_accounting {
    pub rchar: u64,
    pub wchar: u64,
    pub syscr: u64,
    pub syscw: u64,
    pub read_bytes: u64,
    pub write_bytes: u64,
    pub cancelled_write_bytes: u64,
}
#[test]
fn bindgen_test_layout_task_io_accounting() {
    assert_eq!(
        ::core::mem::size_of::<task_io_accounting>(),
        56usize,
        concat!("Size of: ", stringify!(task_io_accounting))
    );
    assert_eq!(
        ::core::mem::align_of::<task_io_accounting>(),
        8usize,
        concat!("Alignment of ", stringify!(task_io_accounting))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).rchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(rchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).wchar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).syscr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(syscr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).syscw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(syscw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).read_bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(read_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).write_bytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(write_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_io_accounting>())).cancelled_write_bytes as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(cancelled_write_bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfs_rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_pi_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reclaim_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sighand_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_delay_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_group {
    _unused: [u8; 0],
}
#[doc = " struct prev_cputime - snapshot of system and user cputime"]
#[doc = " @utime: time spent in user mode"]
#[doc = " @stime: time spent in system mode"]
#[doc = " @lock: protects the above two fields"]
#[doc = ""]
#[doc = " Stores previous user/system time values such that we can guarantee"]
#[doc = " monotonicity."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64,
    pub stime: u64,
    pub lock: raw_spinlock_t,
}
#[test]
fn bindgen_test_layout_prev_cputime() {
    assert_eq!(
        ::core::mem::size_of::<prev_cputime>(),
        24usize,
        concat!("Size of: ", stringify!(prev_cputime))
    );
    assert_eq!(
        ::core::mem::align_of::<prev_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(prev_cputime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for prev_cputime {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct task_cputime - collected CPU time counts"]
#[doc = " @utime:\t\ttime spent in user mode, in nanoseconds"]
#[doc = " @stime:\t\ttime spent in kernel mode, in nanoseconds"]
#[doc = " @sum_exec_runtime:\ttotal time spent on the CPU, in nanoseconds"]
#[doc = ""]
#[doc = " This structure groups together three kinds of CPU time that are tracked for"]
#[doc = " threads and thread groups.  Most things considering CPU time want to group"]
#[doc = " these counts together and treat all three of them in parallel."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_cputime {
    pub utime: u64,
    pub stime: u64,
    pub sum_exec_runtime: c_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_task_cputime() {
    assert_eq!(
        ::core::mem::size_of::<task_cputime>(),
        24usize,
        concat!("Size of: ", stringify!(task_cputime))
    );
    assert_eq!(
        ::core::mem::align_of::<task_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(task_cputime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).sum_exec_runtime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_info {
    pub pcount: c_types::c_ulong,
    pub run_delay: c_types::c_ulonglong,
    pub last_arrival: c_types::c_ulonglong,
    pub last_queued: c_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_sched_info() {
    assert_eq!(
        ::core::mem::size_of::<sched_info>(),
        32usize,
        concat!("Size of: ", stringify!(sched_info))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).pcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(pcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).run_delay as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(run_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).last_arrival as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(last_arrival)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).last_queued as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(last_queued)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct load_weight {
    pub weight: c_types::c_ulong,
    pub inv_weight: u32,
}
#[test]
fn bindgen_test_layout_load_weight() {
    assert_eq!(
        ::core::mem::size_of::<load_weight>(),
        16usize,
        concat!("Size of: ", stringify!(load_weight))
    );
    assert_eq!(
        ::core::mem::align_of::<load_weight>(),
        8usize,
        concat!("Alignment of ", stringify!(load_weight))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<load_weight>())).weight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(load_weight),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<load_weight>())).inv_weight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(load_weight),
            "::",
            stringify!(inv_weight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64,
    pub load_sum: u64,
    pub runnable_load_sum: u64,
    pub util_sum: u32,
    pub period_contrib: u32,
    pub load_avg: c_types::c_ulong,
    pub runnable_load_avg: c_types::c_ulong,
    pub util_avg: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_sched_avg() {
    assert_eq!(
        ::core::mem::size_of::<sched_avg>(),
        56usize,
        concat!("Size of: ", stringify!(sched_avg))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_avg>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_avg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).last_update_time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(last_update_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).load_sum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(load_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).runnable_load_sum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(runnable_load_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).util_sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).period_contrib as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(period_contrib)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).load_avg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(load_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).runnable_load_avg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(runnable_load_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).util_avg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_avg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_statistics {
    pub wait_start: u64,
    pub wait_max: u64,
    pub wait_count: u64,
    pub wait_sum: u64,
    pub iowait_count: u64,
    pub iowait_sum: u64,
    pub sleep_start: u64,
    pub sleep_max: u64,
    pub sum_sleep_runtime: s64,
    pub block_start: u64,
    pub block_max: u64,
    pub exec_max: u64,
    pub slice_max: u64,
    pub nr_migrations_cold: u64,
    pub nr_failed_migrations_affine: u64,
    pub nr_failed_migrations_running: u64,
    pub nr_failed_migrations_hot: u64,
    pub nr_forced_migrations: u64,
    pub nr_wakeups: u64,
    pub nr_wakeups_sync: u64,
    pub nr_wakeups_migrate: u64,
    pub nr_wakeups_local: u64,
    pub nr_wakeups_remote: u64,
    pub nr_wakeups_affine: u64,
    pub nr_wakeups_affine_attempts: u64,
    pub nr_wakeups_passive: u64,
    pub nr_wakeups_idle: u64,
}
#[test]
fn bindgen_test_layout_sched_statistics() {
    assert_eq!(
        ::core::mem::size_of::<sched_statistics>(),
        216usize,
        concat!("Size of: ", stringify!(sched_statistics))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_statistics>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_statistics))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).iowait_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(iowait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).iowait_sum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(iowait_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).sleep_start as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sleep_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).sleep_max as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sleep_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).sum_sleep_runtime as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sum_sleep_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).block_start as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(block_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).block_max as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).exec_max as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(exec_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).slice_max as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(slice_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_migrations_cold as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_migrations_cold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_affine as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_affine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_running as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_running)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_hot as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_hot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_forced_migrations as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_forced_migrations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_sync as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_migrate as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_migrate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_local as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_local)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_remote as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_remote)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_affine as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_affine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_affine_attempts as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_affine_attempts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_passive as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_passive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_idle as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_idle)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub runnable_weight: c_types::c_ulong,
    pub run_node: rb_node,
    pub group_node: list_head,
    pub on_rq: c_types::c_uint,
    pub exec_start: u64,
    pub sum_exec_runtime: u64,
    pub vruntime: u64,
    pub prev_sum_exec_runtime: u64,
    pub nr_migrations: u64,
    pub statistics: sched_statistics,
    pub depth: c_types::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub __bindgen_padding_0: [u64; 3usize],
    pub avg: sched_avg,
}
#[test]
fn bindgen_test_layout_sched_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_entity>(),
        448usize,
        concat!("Size of: ", stringify!(sched_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_entity>(),
        64usize,
        concat!("Alignment of ", stringify!(sched_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).load as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).runnable_weight as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(runnable_weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).run_node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(run_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).group_node as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(group_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).on_rq as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).exec_start as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(exec_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).sum_exec_runtime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).vruntime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(vruntime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_entity>())).prev_sum_exec_runtime as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(prev_sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).nr_migrations as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(nr_migrations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).statistics as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).depth as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).parent as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).cfs_rq as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(cfs_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).my_q as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(my_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).avg as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(avg)
        )
    );
}
impl Default for sched_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: c_types::c_ulong,
    pub watchdog_stamp: c_types::c_ulong,
    pub time_slice: c_types::c_uint,
    pub on_rq: c_types::c_ushort,
    pub on_list: c_types::c_ushort,
    pub back: *mut sched_rt_entity,
}
#[test]
fn bindgen_test_layout_sched_rt_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_rt_entity>(),
        48usize,
        concat!("Size of: ", stringify!(sched_rt_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_rt_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_rt_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).run_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(run_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).timeout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).watchdog_stamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(watchdog_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).time_slice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(time_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).on_rq as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).on_list as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(on_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).back as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(back)
        )
    );
}
impl Default for sched_rt_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64,
    pub dl_deadline: u64,
    pub dl_period: u64,
    pub dl_bw: u64,
    pub dl_density: u64,
    pub runtime: s64,
    pub deadline: u64,
    pub flags: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
}
#[test]
fn bindgen_test_layout_sched_dl_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_dl_entity>(),
        216usize,
        concat!("Size of: ", stringify!(sched_dl_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_dl_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_dl_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_runtime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_deadline as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_bw as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_density as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_density)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).runtime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).deadline as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_timer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).inactive_timer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(inactive_timer)
        )
    );
}
impl Default for sched_dl_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_boosted(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_boosted(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: c_types::c_uint,
        dl_boosted: c_types::c_uint,
        dl_yielded: c_types::c_uint,
        dl_non_contending: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_boosted: u32 = unsafe { ::core::mem::transmute(dl_boosted) };
            dl_boosted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
#[test]
fn bindgen_test_layout_wake_q_node() {
    assert_eq!(
        ::core::mem::size_of::<wake_q_node>(),
        8usize,
        concat!("Size of: ", stringify!(wake_q_node))
    );
    assert_eq!(
        ::core::mem::align_of::<wake_q_node>(),
        8usize,
        concat!("Alignment of ", stringify!(wake_q_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wake_q_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wake_q_node),
            "::",
            stringify!(next)
        )
    );
}
impl Default for wake_q_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct task_struct {
    pub thread_info: thread_info,
    pub state: c_types::c_long,
    pub stack: *mut c_types::c_void,
    pub usage: atomic_t,
    pub flags: c_types::c_uint,
    pub ptrace: c_types::c_uint,
    pub wake_entry: llist_node,
    pub on_cpu: c_types::c_int,
    pub cpu: c_types::c_uint,
    pub wakee_flips: c_types::c_uint,
    pub wakee_flip_decay_ts: c_types::c_ulong,
    pub last_wakee: *mut task_struct,
    pub wake_cpu: c_types::c_int,
    pub on_rq: c_types::c_int,
    pub prio: c_types::c_int,
    pub static_prio: c_types::c_int,
    pub normal_prio: c_types::c_int,
    pub rt_priority: c_types::c_uint,
    pub sched_class: *mut sched_class,
    pub __bindgen_padding_0: u64,
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub sched_task_group: *mut task_group,
    pub dl: sched_dl_entity,
    pub preempt_notifiers: hlist_head,
    pub btrace_seq: c_types::c_uint,
    pub policy: c_types::c_uint,
    pub nr_cpus_allowed: c_types::c_int,
    pub cpus_allowed: cpumask_t,
    pub rcu_tasks_nvcsw: c_types::c_ulong,
    pub rcu_tasks_holdout: u8,
    pub rcu_tasks_idx: u8,
    pub rcu_tasks_idle_cpu: c_types::c_int,
    pub rcu_tasks_holdout_list: list_head,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub vmacache: vmacache,
    pub rss_stat: task_rss_stat,
    pub exit_state: c_types::c_int,
    pub exit_code: c_types::c_int,
    pub exit_signal: c_types::c_int,
    pub pdeath_signal: c_types::c_int,
    pub jobctl: c_types::c_ulong,
    pub personality: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize], u8>,
    pub atomic_flags: c_types::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: c_types::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub pids: [pid_link; 3usize],
    pub thread_group: list_head,
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut c_types::c_int,
    pub clear_child_tid: *mut c_types::c_int,
    pub utime: u64,
    pub stime: u64,
    pub gtime: u64,
    pub prev_cputime: prev_cputime,
    pub nvcsw: c_types::c_ulong,
    pub nivcsw: c_types::c_ulong,
    pub start_time: u64,
    pub real_start_time: u64,
    pub min_flt: c_types::c_ulong,
    pub maj_flt: c_types::c_ulong,
    pub cputime_expires: task_cputime,
    pub cpu_timers: [list_head; 3usize],
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub comm: [c_types::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub last_switch_count: c_types::c_ulong,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: c_types::c_ulong,
    pub sas_ss_size: usize,
    pub sas_ss_flags: c_types::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: c_types::c_uint,
    pub seccomp: seccomp,
    pub parent_exec_id: u64,
    pub self_exec_id: u64,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub journal_info: *mut c_types::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub backing_dev_info: *mut backing_dev_info,
    pub io_context: *mut io_context,
    pub ptrace_message: c_types::c_ulong,
    pub last_siginfo: *mut siginfo_t,
    pub ioac: task_io_accounting,
    pub acct_rss_mem1: u64,
    pub acct_vm_mem1: u64,
    pub acct_timexpd: u64,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_t,
    pub cpuset_mem_spread_rotor: c_types::c_int,
    pub cpuset_slab_spread_rotor: c_types::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub closid: u32,
    pub rmid: u32,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: c_types::c_uint,
    pub perf_event_ctxp: [*mut perf_event_context; 2usize],
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub mempolicy: *mut mempolicy,
    pub il_prev: c_types::c_short,
    pub pref_node_fork: c_types::c_short,
    pub numa_scan_seq: c_types::c_int,
    pub numa_scan_period: c_types::c_uint,
    pub numa_scan_period_max: c_types::c_uint,
    pub numa_preferred_nid: c_types::c_int,
    pub numa_migrate_retry: c_types::c_ulong,
    pub node_stamp: u64,
    pub last_task_numa_placement: u64,
    pub last_sum_exec_runtime: u64,
    pub numa_work: callback_head,
    pub numa_entry: list_head,
    pub numa_group: *mut numa_group,
    pub numa_faults: *mut c_types::c_ulong,
    pub total_numa_faults: c_types::c_ulong,
    pub numa_faults_locality: [c_types::c_ulong; 3usize],
    pub numa_pages_migrated: c_types::c_ulong,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub rcu: callback_head,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub delays: *mut task_delay_info,
    pub nr_dirtied: c_types::c_int,
    pub nr_dirtied_pause: c_types::c_int,
    pub dirty_paused_when: c_types::c_ulong,
    pub timer_slack_ns: u64,
    pub default_timer_slack_ns: u64,
    pub curr_ret_stack: c_types::c_int,
    pub curr_ret_depth: c_types::c_int,
    pub ret_stack: *mut ftrace_ret_stack,
    pub ftrace_timestamp: c_types::c_ulonglong,
    pub trace_overrun: atomic_t,
    pub tracing_graph_pause: atomic_t,
    pub trace: c_types::c_ulong,
    pub trace_recursion: c_types::c_ulong,
    pub memcg_in_oom: *mut mem_cgroup,
    pub memcg_oom_gfp_mask: gfp_t,
    pub memcg_oom_order: c_types::c_int,
    pub memcg_nr_pages_over_high: c_types::c_uint,
    pub utask: *mut uprobe_task,
    pub sequential_io: c_types::c_uint,
    pub sequential_io_avg: c_types::c_uint,
    pub pagefault_disabled: c_types::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: atomic_t,
    pub patch_state: c_types::c_int,
    pub security: *mut c_types::c_void,
    pub __bindgen_padding_1: [u64; 4usize],
    pub thread: thread_struct,
}
#[test]
fn bindgen_test_layout_task_struct() {
    assert_eq!(
        ::core::mem::size_of::<task_struct>(),
        9152usize,
        concat!("Size of: ", stringify!(task_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<task_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(task_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).usage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_entry as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).on_cpu as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(on_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpu as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wakee_flips as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wakee_flips)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).wakee_flip_decay_ts as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wakee_flip_decay_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_wakee as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_wakee)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_cpu as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).on_rq as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).prio as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).static_prio as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(static_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).normal_prio as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(normal_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rt_priority as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rt_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_class as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).se as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(se)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rt as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_task_group as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_task_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).dl as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(dl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).preempt_notifiers as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(preempt_notifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).btrace_seq as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(btrace_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).policy as *const _ as usize },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_cpus_allowed as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_cpus_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpus_allowed as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpus_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_nvcsw as *const _ as usize },
        1896usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_holdout as *const _ as usize },
        1904usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_holdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_idx as *const _ as usize },
        1905usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_idle_cpu as *const _ as usize },
        1908usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_idle_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).rcu_tasks_holdout_list as *const _ as usize
        },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_holdout_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_info as *const _ as usize },
        1928usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tasks as *const _ as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pushable_tasks as *const _ as usize },
        1976usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pushable_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pushable_dl_tasks as *const _ as usize },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pushable_dl_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mm as *const _ as usize },
        2040usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).active_mm as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(active_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).vmacache as *const _ as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(vmacache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rss_stat as *const _ as usize },
        2096usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rss_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_state as *const _ as usize },
        2116usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_code as *const _ as usize },
        2120usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_signal as *const _ as usize },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pdeath_signal as *const _ as usize },
        2128usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pdeath_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).jobctl as *const _ as usize },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(jobctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).personality as *const _ as usize },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(personality)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).atomic_flags as *const _ as usize },
        2160usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(atomic_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).restart_block as *const _ as usize },
        2168usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(restart_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pid as *const _ as usize },
        2216usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tgid as *const _ as usize },
        2220usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_canary as *const _ as usize },
        2224usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_parent as *const _ as usize },
        2232usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).parent as *const _ as usize },
        2240usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).children as *const _ as usize },
        2248usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sibling as *const _ as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).group_leader as *const _ as usize },
        2280usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(group_leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptraced as *const _ as usize },
        2288usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptraced)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace_entry as *const _ as usize },
        2304usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pids as *const _ as usize },
        2320usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pids)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_group as *const _ as usize },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_node as *const _ as usize },
        2408usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).vfork_done as *const _ as usize },
        2424usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(vfork_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).set_child_tid as *const _ as usize },
        2432usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(set_child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).clear_child_tid as *const _ as usize },
        2440usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(clear_child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).utime as *const _ as usize },
        2448usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stime as *const _ as usize },
        2456usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).gtime as *const _ as usize },
        2464usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(gtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).prev_cputime as *const _ as usize },
        2472usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(prev_cputime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nvcsw as *const _ as usize },
        2496usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nivcsw as *const _ as usize },
        2504usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).start_time as *const _ as usize },
        2512usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_start_time as *const _ as usize },
        2520usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).min_flt as *const _ as usize },
        2528usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(min_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).maj_flt as *const _ as usize },
        2536usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(maj_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cputime_expires as *const _ as usize },
        2544usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cputime_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpu_timers as *const _ as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpu_timers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptracer_cred as *const _ as usize },
        2616usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptracer_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_cred as *const _ as usize },
        2624usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cred as *const _ as usize },
        2632usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).comm as *const _ as usize },
        2640usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(comm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nameidata as *const _ as usize },
        2656usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nameidata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sysvsem as *const _ as usize },
        2664usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sysvsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sysvshm as *const _ as usize },
        2672usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sysvshm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_switch_count as *const _ as usize },
        2688usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_switch_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).fs as *const _ as usize },
        2696usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).files as *const _ as usize },
        2704usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nsproxy as *const _ as usize },
        2712usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nsproxy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).signal as *const _ as usize },
        2720usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sighand as *const _ as usize },
        2728usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sighand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).blocked as *const _ as usize },
        2736usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_blocked as *const _ as usize },
        2744usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).saved_sigmask as *const _ as usize },
        2752usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(saved_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pending as *const _ as usize },
        2760usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_sp as *const _ as usize },
        2784usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_size as *const _ as usize },
        2792usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_flags as *const _ as usize },
        2800usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).task_works as *const _ as usize },
        2808usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(task_works)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).audit_context as *const _ as usize },
        2816usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(audit_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).loginuid as *const _ as usize },
        2824usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(loginuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sessionid as *const _ as usize },
        2828usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sessionid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).seccomp as *const _ as usize },
        2832usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(seccomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).parent_exec_id as *const _ as usize },
        2848usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(parent_exec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).self_exec_id as *const _ as usize },
        2856usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(self_exec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).alloc_lock as *const _ as usize },
        2864usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(alloc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_lock as *const _ as usize },
        2868usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_q as *const _ as usize },
        2872usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_waiters as *const _ as usize },
        2880usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_waiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_top_task as *const _ as usize },
        2896usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_top_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_blocked_on as *const _ as usize },
        2904usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_blocked_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).journal_info as *const _ as usize },
        2912usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(journal_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).bio_list as *const _ as usize },
        2920usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(bio_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).plug as *const _ as usize },
        2928usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).reclaim_state as *const _ as usize },
        2936usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(reclaim_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).backing_dev_info as *const _ as usize },
        2944usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(backing_dev_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).io_context as *const _ as usize },
        2952usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(io_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace_message as *const _ as usize },
        2960usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace_message)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_siginfo as *const _ as usize },
        2968usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_siginfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ioac as *const _ as usize },
        2976usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ioac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_rss_mem1 as *const _ as usize },
        3032usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_rss_mem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_vm_mem1 as *const _ as usize },
        3040usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_vm_mem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_timexpd as *const _ as usize },
        3048usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_timexpd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mems_allowed as *const _ as usize },
        3056usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mems_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mems_allowed_seq as *const _ as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mems_allowed_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).cpuset_mem_spread_rotor as *const _ as usize
        },
        3188usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpuset_mem_spread_rotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).cpuset_slab_spread_rotor as *const _ as usize
        },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpuset_slab_spread_rotor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cgroups as *const _ as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cgroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cg_list as *const _ as usize },
        3208usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).closid as *const _ as usize },
        3224usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(closid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rmid as *const _ as usize },
        3228usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rmid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).robust_list as *const _ as usize },
        3232usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(robust_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).compat_robust_list as *const _ as usize },
        3240usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(compat_robust_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_state_list as *const _ as usize },
        3248usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_state_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_state_cache as *const _ as usize },
        3264usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_state_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).futex_exit_mutex as *const _ as usize },
        3272usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(futex_exit_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).futex_state as *const _ as usize },
        3304usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(futex_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_ctxp as *const _ as usize },
        3312usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_ctxp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_mutex as *const _ as usize },
        3328usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_list as *const _ as usize },
        3360usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mempolicy as *const _ as usize },
        3376usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mempolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).il_prev as *const _ as usize },
        3384usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(il_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pref_node_fork as *const _ as usize },
        3386usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pref_node_fork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_scan_seq as *const _ as usize },
        3388usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_scan_period as *const _ as usize },
        3392usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_scan_period_max as *const _ as usize
        },
        3396usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_period_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_preferred_nid as *const _ as usize },
        3400usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_preferred_nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_migrate_retry as *const _ as usize },
        3408usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_migrate_retry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).node_stamp as *const _ as usize },
        3416usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(node_stamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).last_task_numa_placement as *const _ as usize
        },
        3424usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_task_numa_placement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).last_sum_exec_runtime as *const _ as usize
        },
        3432usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_work as *const _ as usize },
        3440usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_entry as *const _ as usize },
        3456usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_group as *const _ as usize },
        3472usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_faults as *const _ as usize },
        3480usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_faults)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).total_numa_faults as *const _ as usize },
        3488usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(total_numa_faults)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_faults_locality as *const _ as usize
        },
        3496usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_faults_locality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_pages_migrated as *const _ as usize
        },
        3520usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_pages_migrated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tlb_ubc as *const _ as usize },
        3528usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tlb_ubc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu as *const _ as usize },
        4560usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).splice_pipe as *const _ as usize },
        4576usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(splice_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).task_frag as *const _ as usize },
        4584usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(task_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).delays as *const _ as usize },
        4600usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(delays)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_dirtied as *const _ as usize },
        4608usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_dirtied)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_dirtied_pause as *const _ as usize },
        4612usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_dirtied_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).dirty_paused_when as *const _ as usize },
        4616usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(dirty_paused_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).timer_slack_ns as *const _ as usize },
        4624usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(timer_slack_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).default_timer_slack_ns as *const _ as usize
        },
        4632usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(default_timer_slack_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).curr_ret_stack as *const _ as usize },
        4640usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(curr_ret_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).curr_ret_depth as *const _ as usize },
        4644usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(curr_ret_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ret_stack as *const _ as usize },
        4648usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ret_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ftrace_timestamp as *const _ as usize },
        4656usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ftrace_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace_overrun as *const _ as usize },
        4664usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).tracing_graph_pause as *const _ as usize
        },
        4668usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tracing_graph_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace as *const _ as usize },
        4672usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace_recursion as *const _ as usize },
        4680usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace_recursion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_in_oom as *const _ as usize },
        4688usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_in_oom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_oom_gfp_mask as *const _ as usize },
        4696usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_oom_gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_oom_order as *const _ as usize },
        4700usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_oom_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).memcg_nr_pages_over_high as *const _ as usize
        },
        4704usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_nr_pages_over_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).utask as *const _ as usize },
        4712usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(utask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sequential_io as *const _ as usize },
        4720usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sequential_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sequential_io_avg as *const _ as usize },
        4724usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sequential_io_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pagefault_disabled as *const _ as usize },
        4728usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pagefault_disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).oom_reaper_list as *const _ as usize },
        4736usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(oom_reaper_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_vm_area as *const _ as usize },
        4744usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_vm_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_refcount as *const _ as usize },
        4752usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).patch_state as *const _ as usize },
        4756usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(patch_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).security as *const _ as usize },
        4760usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread as *const _ as usize },
        4800usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread)
        )
    );
}
impl Default for task_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_execve(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restore_sigmask(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restore_sigmask(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memcg_may_oom(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memcg_may_oom(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memcg_kmem_skip_account(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memcg_kmem_skip_account(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_reset_on_fork: c_types::c_uint,
        sched_contributes_to_load: c_types::c_uint,
        sched_migrated: c_types::c_uint,
        sched_remote_wakeup: c_types::c_uint,
        in_execve: c_types::c_uint,
        in_iowait: c_types::c_uint,
        restore_sigmask: c_types::c_uint,
        memcg_may_oom: c_types::c_uint,
        memcg_kmem_skip_account: c_types::c_uint,
        no_cgroup_migration: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let restore_sigmask: u32 = unsafe { ::core::mem::transmute(restore_sigmask) };
            restore_sigmask as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let memcg_may_oom: u32 = unsafe { ::core::mem::transmute(memcg_may_oom) };
            memcg_may_oom as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let memcg_kmem_skip_account: u32 =
                unsafe { ::core::mem::transmute(memcg_kmem_skip_account) };
            memcg_kmem_skip_account as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_struct {
    pub __count: atomic_t,
    pub processes: atomic_t,
    pub sigpending: atomic_t,
    pub fanotify_listeners: atomic_t,
    pub epoll_watches: atomic_long_t,
    pub mq_bytes: c_types::c_ulong,
    pub locked_shm: c_types::c_ulong,
    pub unix_inflight: c_types::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uid_keyring: *mut key,
    pub session_keyring: *mut key,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
}
#[test]
fn bindgen_test_layout_user_struct() {
    assert_eq!(
        ::core::mem::size_of::<user_struct>(),
        104usize,
        concat!("Size of: ", stringify!(user_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<user_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(user_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).processes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(processes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).sigpending as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(sigpending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).fanotify_listeners as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(fanotify_listeners)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).epoll_watches as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(epoll_watches)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).mq_bytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(mq_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).locked_shm as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(locked_shm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).unix_inflight as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(unix_inflight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).pipe_bufs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(pipe_bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).uid_keyring as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(uid_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).session_keyring as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(session_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).uidhash_node as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(uidhash_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).uid as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).locked_vm as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(locked_vm)
        )
    );
}
impl Default for user_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct group_info {
    pub usage: atomic_t,
    pub ngroups: c_types::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
#[test]
fn bindgen_test_layout_group_info() {
    assert_eq!(
        ::core::mem::size_of::<group_info>(),
        8usize,
        concat!("Size of: ", stringify!(group_info))
    );
    assert_eq!(
        ::core::mem::align_of::<group_info>(),
        4usize,
        concat!("Alignment of ", stringify!(group_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<group_info>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<group_info>())).ngroups as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(ngroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<group_info>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: c_types::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: c_types::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut c_types::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: c_types::c_int,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_cred__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cred__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cred__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cred__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cred__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred__bindgen_ty_1>())).non_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred__bindgen_ty_1),
            "::",
            stringify!(non_rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred__bindgen_ty_1>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for cred__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_cred() {
    assert_eq!(
        ::core::mem::size_of::<cred>(),
        168usize,
        concat!("Size of: ", stringify!(cred))
    );
    assert_eq!(
        ::core::mem::align_of::<cred>(),
        8usize,
        concat!("Alignment of ", stringify!(cred))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).uid as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cred), "::", stringify!(uid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).gid as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cred), "::", stringify!(gid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).suid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(suid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).sgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).euid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).egid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(egid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).fsuid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(fsuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).fsgid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(fsgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).securebits as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(securebits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_inheritable as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_inheritable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_permitted as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_permitted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_effective as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_effective)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_bset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_bset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_ambient as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_ambient)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).jit_keyring as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(jit_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).session_keyring as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(session_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).process_keyring as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(process_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).thread_keyring as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(thread_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).request_key_auth as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(request_key_auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).security as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).user as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).user_ns as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).group_info as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(group_info)
        )
    );
}
impl Default for cred {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    pub buf: *mut c_types::c_char,
    pub size: usize,
    pub from: usize,
    pub count: usize,
    pub pad_until: usize,
    pub index: loff_t,
    pub read_pos: loff_t,
    pub version: u64,
    pub lock: mutex,
    pub op: *const seq_operations,
    pub poll_event: c_types::c_int,
    pub file: *const file,
    pub private: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_seq_file() {
    assert_eq!(
        ::core::mem::size_of::<seq_file>(),
        128usize,
        concat!("Size of: ", stringify!(seq_file))
    );
    assert_eq!(
        ::core::mem::align_of::<seq_file>(),
        8usize,
        concat!("Alignment of ", stringify!(seq_file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).from as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).pad_until as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(pad_until)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).read_pos as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(read_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).version as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).op as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).poll_event as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(poll_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).file as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).private as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(private)
        )
    );
}
impl Default for seq_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pinctrl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pinctrl_state {
    _unused: [u8; 0],
}
#[doc = " struct dev_pin_info - pin state container for devices"]
#[doc = " @p: pinctrl handle for the containing device"]
#[doc = " @default_state: the default state for the handle, if found"]
#[doc = " @init_state: the state at probe time, if found"]
#[doc = " @sleep_state: the state at suspend time, if found"]
#[doc = " @idle_state: the state at idle (runtime suspend) time, if found"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pin_info {
    pub p: *mut pinctrl,
    pub default_state: *mut pinctrl_state,
    pub init_state: *mut pinctrl_state,
    pub sleep_state: *mut pinctrl_state,
    pub idle_state: *mut pinctrl_state,
}
#[test]
fn bindgen_test_layout_dev_pin_info() {
    assert_eq!(
        ::core::mem::size_of::<dev_pin_info>(),
        40usize,
        concat!("Size of: ", stringify!(dev_pin_info))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pin_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pin_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pin_info>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pin_info),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pin_info>())).default_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pin_info),
            "::",
            stringify!(default_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pin_info>())).init_state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pin_info),
            "::",
            stringify!(init_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pin_info>())).sleep_state as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pin_info),
            "::",
            stringify!(sleep_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pin_info>())).idle_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pin_info),
            "::",
            stringify!(idle_state)
        )
    );
}
impl Default for dev_pin_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pm_message {
    pub event: c_types::c_int,
}
#[test]
fn bindgen_test_layout_pm_message() {
    assert_eq!(
        ::core::mem::size_of::<pm_message>(),
        4usize,
        concat!("Size of: ", stringify!(pm_message))
    );
    assert_eq!(
        ::core::mem::align_of::<pm_message>(),
        4usize,
        concat!("Alignment of ", stringify!(pm_message))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_message>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_message),
            "::",
            stringify!(event)
        )
    );
}
pub type pm_message_t = pm_message;
#[doc = " struct dev_pm_ops - device PM callbacks."]
#[doc = ""]
#[doc = " @prepare: The principal role of this callback is to prevent new children of"]
#[doc = "\tthe device from being registered after it has returned (the driver's"]
#[doc = "\tsubsystem and generally the rest of the kernel is supposed to prevent"]
#[doc = "\tnew calls to the probe method from being made too once @prepare() has"]
#[doc = "\tsucceeded).  If @prepare() detects a situation it cannot handle (e.g."]
#[doc = "\tregistration of a child already in progress), it may return -EAGAIN, so"]
#[doc = "\tthat the PM core can execute it once again (e.g. after a new child has"]
#[doc = "\tbeen registered) to recover from the race condition."]
#[doc = "\tThis method is executed for all kinds of suspend transitions and is"]
#[doc = "\tfollowed by one of the suspend callbacks: @suspend(), @freeze(), or"]
#[doc = "\t@poweroff().  If the transition is a suspend to memory or standby (that"]
#[doc = "\tis, not related to hibernation), the return value of @prepare() may be"]
#[doc = "\tused to indicate to the PM core to leave the device in runtime suspend"]
#[doc = "\tif applicable.  Namely, if @prepare() returns a positive number, the PM"]
#[doc = "\tcore will understand that as a declaration that the device appears to be"]
#[doc = "\truntime-suspended and it may be left in that state during the entire"]
#[doc = "\ttransition and during the subsequent resume if all of its descendants"]
#[doc = "\tare left in runtime suspend too.  If that happens, @complete() will be"]
#[doc = "\texecuted directly after @prepare() and it must ensure the proper"]
#[doc = "\tfunctioning of the device after the system resume."]
#[doc = "\tThe PM core executes subsystem-level @prepare() for all devices before"]
#[doc = "\tstarting to invoke suspend callbacks for any of them, so generally"]
#[doc = "\tdevices may be assumed to be functional or to respond to runtime resume"]
#[doc = "\trequests while @prepare() is being executed.  However, device drivers"]
#[doc = "\tmay NOT assume anything about the availability of user space at that"]
#[doc = "\ttime and it is NOT valid to request firmware from within @prepare()"]
#[doc = "\t(it's too late to do that).  It also is NOT valid to allocate"]
#[doc = "\tsubstantial amounts of memory from @prepare() in the GFP_KERNEL mode."]
#[doc = "\t[To work around these limitations, drivers may register suspend and"]
#[doc = "\thibernation notifiers to be executed before the freezing of tasks.]"]
#[doc = ""]
#[doc = " @complete: Undo the changes made by @prepare().  This method is executed for"]
#[doc = "\tall kinds of resume transitions, following one of the resume callbacks:"]
#[doc = "\t@resume(), @thaw(), @restore().  Also called if the state transition"]
#[doc = "\tfails before the driver's suspend callback: @suspend(), @freeze() or"]
#[doc = "\t@poweroff(), can be executed (e.g. if the suspend callback fails for one"]
#[doc = "\tof the other devices that the PM core has unsuccessfully attempted to"]
#[doc = "\tsuspend earlier)."]
#[doc = "\tThe PM core executes subsystem-level @complete() after it has executed"]
#[doc = "\tthe appropriate resume callbacks for all devices.  If the corresponding"]
#[doc = "\t@prepare() at the beginning of the suspend transition returned a"]
#[doc = "\tpositive number and the device was left in runtime suspend (without"]
#[doc = "\texecuting any suspend and resume callbacks for it), @complete() will be"]
#[doc = "\tthe only callback executed for the device during resume.  In that case,"]
#[doc = "\t@complete() must be prepared to do whatever is necessary to ensure the"]
#[doc = "\tproper functioning of the device after the system resume.  To this end,"]
#[doc = "\t@complete() can check the power.direct_complete flag of the device to"]
#[doc = "\tlearn whether (unset) or not (set) the previous suspend and resume"]
#[doc = "\tcallbacks have been executed for it."]
#[doc = ""]
#[doc = " @suspend: Executed before putting the system into a sleep state in which the"]
#[doc = "\tcontents of main memory are preserved.  The exact action to perform"]
#[doc = "\tdepends on the device's subsystem (PM domain, device type, class or bus"]
#[doc = "\ttype), but generally the device must be quiescent after subsystem-level"]
#[doc = "\t@suspend() has returned, so that it doesn't do any I/O or DMA."]
#[doc = "\tSubsystem-level @suspend() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @prepare() for all of them."]
#[doc = ""]
#[doc = " @suspend_late: Continue operations started by @suspend().  For a number of"]
#[doc = "\tdevices @suspend_late() may point to the same callback routine as the"]
#[doc = "\truntime suspend callback."]
#[doc = ""]
#[doc = " @resume: Executed after waking the system up from a sleep state in which the"]
#[doc = "\tcontents of main memory were preserved.  The exact action to perform"]
#[doc = "\tdepends on the device's subsystem, but generally the driver is expected"]
#[doc = "\tto start working again, responding to hardware events and software"]
#[doc = "\trequests (the device itself may be left in a low-power state, waiting"]
#[doc = "\tfor a runtime resume to occur).  The state of the device at the time its"]
#[doc = "\tdriver's @resume() callback is run depends on the platform and subsystem"]
#[doc = "\tthe device belongs to.  On most platforms, there are no restrictions on"]
#[doc = "\tavailability of resources like clocks during @resume()."]
#[doc = "\tSubsystem-level @resume() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @resume_noirq() for all of them."]
#[doc = ""]
#[doc = " @resume_early: Prepare to execute @resume().  For a number of devices"]
#[doc = "\t@resume_early() may point to the same callback routine as the runtime"]
#[doc = "\tresume callback."]
#[doc = ""]
#[doc = " @freeze: Hibernation-specific, executed before creating a hibernation image."]
#[doc = "\tAnalogous to @suspend(), but it should not enable the device to signal"]
#[doc = "\twakeup events or change its power state.  The majority of subsystems"]
#[doc = "\t(with the notable exception of the PCI bus type) expect the driver-level"]
#[doc = "\t@freeze() to save the device settings in memory to be used by @restore()"]
#[doc = "\tduring the subsequent resume from hibernation."]
#[doc = "\tSubsystem-level @freeze() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @prepare() for all of them."]
#[doc = ""]
#[doc = " @freeze_late: Continue operations started by @freeze().  Analogous to"]
#[doc = "\t@suspend_late(), but it should not enable the device to signal wakeup"]
#[doc = "\tevents or change its power state."]
#[doc = ""]
#[doc = " @thaw: Hibernation-specific, executed after creating a hibernation image OR"]
#[doc = "\tif the creation of an image has failed.  Also executed after a failing"]
#[doc = "\tattempt to restore the contents of main memory from such an image."]
#[doc = "\tUndo the changes made by the preceding @freeze(), so the device can be"]
#[doc = "\toperated in the same way as immediately before the call to @freeze()."]
#[doc = "\tSubsystem-level @thaw() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @thaw_noirq() for all of them.  It also may be executed"]
#[doc = "\tdirectly after @freeze() in case of a transition error."]
#[doc = ""]
#[doc = " @thaw_early: Prepare to execute @thaw().  Undo the changes made by the"]
#[doc = "\tpreceding @freeze_late()."]
#[doc = ""]
#[doc = " @poweroff: Hibernation-specific, executed after saving a hibernation image."]
#[doc = "\tAnalogous to @suspend(), but it need not save the device's settings in"]
#[doc = "\tmemory."]
#[doc = "\tSubsystem-level @poweroff() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @prepare() for all of them."]
#[doc = ""]
#[doc = " @poweroff_late: Continue operations started by @poweroff().  Analogous to"]
#[doc = "\t@suspend_late(), but it need not save the device's settings in memory."]
#[doc = ""]
#[doc = " @restore: Hibernation-specific, executed after restoring the contents of main"]
#[doc = "\tmemory from a hibernation image, analogous to @resume()."]
#[doc = ""]
#[doc = " @restore_early: Prepare to execute @restore(), analogous to @resume_early()."]
#[doc = ""]
#[doc = " @suspend_noirq: Complete the actions started by @suspend().  Carry out any"]
#[doc = "\tadditional operations required for suspending the device that might be"]
#[doc = "\tracing with its driver's interrupt handler, which is guaranteed not to"]
#[doc = "\trun while @suspend_noirq() is being executed."]
#[doc = "\tIt generally is expected that the device will be in a low-power state"]
#[doc = "\t(appropriate for the target system sleep state) after subsystem-level"]
#[doc = "\t@suspend_noirq() has returned successfully.  If the device can generate"]
#[doc = "\tsystem wakeup signals and is enabled to wake up the system, it should be"]
#[doc = "\tconfigured to do so at that time.  However, depending on the platform"]
#[doc = "\tand device's subsystem, @suspend() or @suspend_late() may be allowed to"]
#[doc = "\tput the device into the low-power state and configure it to generate"]
#[doc = "\twakeup signals, in which case it generally is not necessary to define"]
#[doc = "\t@suspend_noirq()."]
#[doc = ""]
#[doc = " @resume_noirq: Prepare for the execution of @resume() by carrying out any"]
#[doc = "\toperations required for resuming the device that might be racing with"]
#[doc = "\tits driver's interrupt handler, which is guaranteed not to run while"]
#[doc = "\t@resume_noirq() is being executed."]
#[doc = ""]
#[doc = " @freeze_noirq: Complete the actions started by @freeze().  Carry out any"]
#[doc = "\tadditional operations required for freezing the device that might be"]
#[doc = "\tracing with its driver's interrupt handler, which is guaranteed not to"]
#[doc = "\trun while @freeze_noirq() is being executed."]
#[doc = "\tThe power state of the device should not be changed by either @freeze(),"]
#[doc = "\tor @freeze_late(), or @freeze_noirq() and it should not be configured to"]
#[doc = "\tsignal system wakeup by any of these callbacks."]
#[doc = ""]
#[doc = " @thaw_noirq: Prepare for the execution of @thaw() by carrying out any"]
#[doc = "\toperations required for thawing the device that might be racing with its"]
#[doc = "\tdriver's interrupt handler, which is guaranteed not to run while"]
#[doc = "\t@thaw_noirq() is being executed."]
#[doc = ""]
#[doc = " @poweroff_noirq: Complete the actions started by @poweroff().  Analogous to"]
#[doc = "\t@suspend_noirq(), but it need not save the device's settings in memory."]
#[doc = ""]
#[doc = " @restore_noirq: Prepare for the execution of @restore() by carrying out any"]
#[doc = "\toperations required for thawing the device that might be racing with its"]
#[doc = "\tdriver's interrupt handler, which is guaranteed not to run while"]
#[doc = "\t@restore_noirq() is being executed.  Analogous to @resume_noirq()."]
#[doc = ""]
#[doc = " @runtime_suspend: Prepare the device for a condition in which it won't be"]
#[doc = "\table to communicate with the CPU(s) and RAM due to power management."]
#[doc = "\tThis need not mean that the device should be put into a low-power state."]
#[doc = "\tFor example, if the device is behind a link which is about to be turned"]
#[doc = "\toff, the device may remain at full power.  If the device does go to low"]
#[doc = "\tpower and is capable of generating runtime wakeup events, remote wakeup"]
#[doc = "\t(i.e., a hardware mechanism allowing the device to request a change of"]
#[doc = "\tits power state via an interrupt) should be enabled for it."]
#[doc = ""]
#[doc = " @runtime_resume: Put the device into the fully active state in response to a"]
#[doc = "\twakeup event generated by hardware or at the request of software.  If"]
#[doc = "\tnecessary, put the device into the full-power state and restore its"]
#[doc = "\tregisters, so that it is fully operational."]
#[doc = ""]
#[doc = " @runtime_idle: Device appears to be inactive and it might be put into a"]
#[doc = "\tlow-power state if all of the necessary conditions are satisfied."]
#[doc = "\tCheck these conditions, and return 0 if it's appropriate to let the PM"]
#[doc = "\tcore queue a suspend request for the device."]
#[doc = ""]
#[doc = " Several device power state transitions are externally visible, affecting"]
#[doc = " the state of pending I/O queues and (for drivers that touch hardware)"]
#[doc = " interrupts, wakeups, DMA, and other hardware state.  There may also be"]
#[doc = " internal transitions to various low-power modes which are transparent"]
#[doc = " to the rest of the driver stack (such as a driver that's ON gating off"]
#[doc = " clocks which are not in active use)."]
#[doc = ""]
#[doc = " The externally visible transitions are handled with the help of callbacks"]
#[doc = " included in this structure in such a way that, typically, two levels of"]
#[doc = " callbacks are involved.  First, the PM core executes callbacks provided by PM"]
#[doc = " domains, device types, classes and bus types.  They are the subsystem-level"]
#[doc = " callbacks expected to execute callbacks provided by device drivers, although"]
#[doc = " they may choose not to do that.  If the driver callbacks are executed, they"]
#[doc = " have to collaborate with the subsystem-level callbacks to achieve the goals"]
#[doc = " appropriate for the given system transition, given transition phase and the"]
#[doc = " subsystem the device belongs to."]
#[doc = ""]
#[doc = " All of the above callbacks, except for @complete(), return error codes."]
#[doc = " However, the error codes returned by @resume(), @thaw(), @restore(),"]
#[doc = " @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do not cause the PM"]
#[doc = " core to abort the resume transition during which they are returned.  The"]
#[doc = " error codes returned in those cases are only printed to the system logs for"]
#[doc = " debugging purposes.  Still, it is recommended that drivers only return error"]
#[doc = " codes from their resume methods in case of an unrecoverable failure (i.e."]
#[doc = " when the device being handled refuses to resume and becomes unusable) to"]
#[doc = " allow the PM core to be modified in the future, so that it can avoid"]
#[doc = " attempting to handle devices that failed to resume and their children."]
#[doc = ""]
#[doc = " It is allowed to unregister devices while the above callbacks are being"]
#[doc = " executed.  However, a callback routine MUST NOT try to unregister the device"]
#[doc = " it was called for, although it may unregister children of that device (for"]
#[doc = " example, if it detects that a child was unplugged while the system was"]
#[doc = " asleep)."]
#[doc = ""]
#[doc = " There also are callbacks related to runtime power management of devices."]
#[doc = " Again, as a rule these callbacks are executed by the PM core for subsystems"]
#[doc = " (PM domains, device types, classes and bus types) and the subsystem-level"]
#[doc = " callbacks are expected to invoke the driver callbacks.  Moreover, the exact"]
#[doc = " actions to be performed by a device driver's callbacks generally depend on"]
#[doc = " the platform and subsystem the device belongs to."]
#[doc = ""]
#[doc = " Refer to Documentation/power/runtime_pm.txt for more information about the"]
#[doc = " role of the @runtime_suspend(), @runtime_resume() and @runtime_idle()"]
#[doc = " callbacks in device runtime power management."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub freeze: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub thaw: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub poweroff: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub restore: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub suspend_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub resume_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub freeze_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub thaw_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub poweroff_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub restore_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub suspend_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub resume_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub freeze_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub thaw_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub restore_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub runtime_idle:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
}
#[test]
fn bindgen_test_layout_dev_pm_ops() {
    assert_eq!(
        ::core::mem::size_of::<dev_pm_ops>(),
        184usize,
        concat!("Size of: ", stringify!(dev_pm_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pm_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pm_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).prepare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).complete as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(freeze)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(thaw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(poweroff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(restore)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend_late as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(suspend_late)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume_early as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(resume_early)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze_late as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(freeze_late)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw_early as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(thaw_early)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff_late as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(poweroff_late)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore_early as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(restore_early)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend_noirq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(suspend_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume_noirq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(resume_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze_noirq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(freeze_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw_noirq as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(thaw_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff_noirq as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(poweroff_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore_noirq as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(restore_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_suspend as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(runtime_suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_resume as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(runtime_resume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_idle as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(runtime_idle)
        )
    );
}
pub const rpm_status_RPM_ACTIVE: rpm_status = 0;
pub const rpm_status_RPM_RESUMING: rpm_status = 1;
pub const rpm_status_RPM_SUSPENDED: rpm_status = 2;
pub const rpm_status_RPM_SUSPENDING: rpm_status = 3;
pub type rpm_status = u32;
pub const rpm_request_RPM_REQ_NONE: rpm_request = 0;
pub const rpm_request_RPM_REQ_IDLE: rpm_request = 1;
pub const rpm_request_RPM_REQ_SUSPEND: rpm_request = 2;
pub const rpm_request_RPM_REQ_AUTOSUSPEND: rpm_request = 3;
pub const rpm_request_RPM_REQ_RESUME: rpm_request = 4;
pub type rpm_request = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_irq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_domain_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: c_types::c_uint,
    pub clock_list: list_head,
    pub domain_data: *mut pm_domain_data,
}
#[test]
fn bindgen_test_layout_pm_subsys_data() {
    assert_eq!(
        ::core::mem::size_of::<pm_subsys_data>(),
        32usize,
        concat!("Size of: ", stringify!(pm_subsys_data))
    );
    assert_eq!(
        ::core::mem::align_of::<pm_subsys_data>(),
        8usize,
        concat!("Alignment of ", stringify!(pm_subsys_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_subsys_data),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).refcount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_subsys_data),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).clock_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_subsys_data),
            "::",
            stringify!(clock_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).domain_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_subsys_data),
            "::",
            stringify!(domain_data)
        )
    );
}
impl Default for pm_subsys_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub driver_flags: u32,
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub suspend_timer: timer_list,
    pub timer_expires: c_types::c_ulong,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub links_count: c_types::c_uint,
    pub request: rpm_request,
    pub runtime_status: rpm_status,
    pub runtime_error: c_types::c_int,
    pub autosuspend_delay: c_types::c_int,
    pub last_busy: c_types::c_ulong,
    pub active_jiffies: c_types::c_ulong,
    pub suspended_jiffies: c_types::c_ulong,
    pub accounting_timestamp: c_types::c_ulong,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
}
#[test]
fn bindgen_test_layout_dev_pm_info() {
    assert_eq!(
        ::core::mem::size_of::<dev_pm_info>(),
        280usize,
        concat!("Size of: ", stringify!(dev_pm_info))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pm_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pm_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).power_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(power_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).driver_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(driver_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).lock as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).completion as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(completion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wakeup as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(wakeup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).suspend_timer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(suspend_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).timer_expires as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(timer_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).work as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wait_queue as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(wait_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wakeirq as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(wakeirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).usage_count as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(usage_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).child_count as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(child_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).links_count as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(links_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).request as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).runtime_status as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(runtime_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).runtime_error as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(runtime_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).autosuspend_delay as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(autosuspend_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).last_busy as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(last_busy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).active_jiffies as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(active_jiffies)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).suspended_jiffies as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(suspended_jiffies)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dev_pm_info>())).accounting_timestamp as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(accounting_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).subsys_data as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(subsys_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dev_pm_info>())).set_latency_tolerance as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(set_latency_tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).qos as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(qos)
        )
    );
}
impl Default for dev_pm_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: c_types::c_uint,
        async_suspend: c_types::c_uint,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u32 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u32 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn must_resume(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_must_resume(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn may_skip_resume(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_may_skip_resume(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        wakeup_path: bool_,
        syscore: bool_,
        no_pm_callbacks: bool_,
        must_resume: c_types::c_uint,
        may_skip_resume: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
            wakeup_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
            syscore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
            no_pm_callbacks as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let must_resume: u32 = unsafe { ::core::mem::transmute(must_resume) };
            must_resume as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let may_skip_resume: u32 = unsafe { ::core::mem::transmute(may_skip_resume) };
            may_skip_resume as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_pending(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: c_types::c_uint,
        idle_notification: c_types::c_uint,
        request_pending: c_types::c_uint,
        deferred_resume: c_types::c_uint,
        runtime_auto: c_types::c_uint,
        ignore_children: bool_,
        no_callbacks: c_types::c_uint,
        irq_safe: c_types::c_uint,
        use_autosuspend: c_types::c_uint,
        timer_autosuspends: c_types::c_uint,
        memalloc_noio: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u32 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u32 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u32 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let runtime_auto: u32 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let no_callbacks: u32 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let irq_safe: u32 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let use_autosuspend: u32 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timer_autosuspends: u32 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let memalloc_noio: u32 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct dev_pm_domain - power management domain representation."]
#[doc = ""]
#[doc = " @ops: Power management operations associated with this domain."]
#[doc = " @detach: Called when removing a device from the domain."]
#[doc = " @activate: Called before executing probe routines for bus types and drivers."]
#[doc = " @sync: Called after successful driver probe."]
#[doc = " @dismiss: Called after unsuccessful driver probe and after driver removal."]
#[doc = ""]
#[doc = " Power domains provide callbacks that are executed during system suspend,"]
#[doc = " hibernation, system resume and during runtime PM transitions instead of"]
#[doc = " subsystem-level and driver-level callbacks."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub detach: ::core::option::Option<unsafe extern "C" fn(dev: *mut device, power_off: bool_)>,
    pub activate: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
}
#[test]
fn bindgen_test_layout_dev_pm_domain() {
    assert_eq!(
        ::core::mem::size_of::<dev_pm_domain>(),
        216usize,
        concat!("Size of: ", stringify!(dev_pm_domain))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pm_domain>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pm_domain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).detach as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(detach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).activate as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).sync as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).dismiss as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(dismiss)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_archdata {
    pub iommu: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_dev_archdata() {
    assert_eq!(
        ::core::mem::size_of::<dev_archdata>(),
        8usize,
        concat!("Size of: ", stringify!(dev_archdata))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_archdata>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_archdata))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_archdata>())).iommu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_archdata),
            "::",
            stringify!(iommu)
        )
    );
}
impl Default for dev_archdata {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct driver_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct subsys_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_fwspec {
    _unused: [u8; 0],
}
#[doc = " struct bus_type - The bus type of the device"]
#[doc = ""]
#[doc = " @name:\tThe name of the bus."]
#[doc = " @dev_name:\tUsed for subsystems to enumerate devices like (\"foo%u\", dev->id)."]
#[doc = " @dev_root:\tDefault device to use as the parent."]
#[doc = " @bus_groups:\tDefault attributes of the bus."]
#[doc = " @dev_groups:\tDefault attributes of the devices on the bus."]
#[doc = " @drv_groups: Default attributes of the device drivers on the bus."]
#[doc = " @match:\tCalled, perhaps multiple times, whenever a new device or driver"]
#[doc = "\t\tis added for this bus. It should return a positive value if the"]
#[doc = "\t\tgiven device can be handled by the given driver and zero"]
#[doc = "\t\totherwise. It may also return error code if determining that"]
#[doc = "\t\tthe driver supports the device is not possible. In case of"]
#[doc = "\t\t-EPROBE_DEFER it will queue the device for deferred probing."]
#[doc = " @uevent:\tCalled when a device is added, removed, or a few other things"]
#[doc = "\t\tthat generate uevents to add the environment variables."]
#[doc = " @probe:\tCalled when a new device or driver add to this bus, and callback"]
#[doc = "\t\tthe specific driver's probe to initial the matched device."]
#[doc = " @remove:\tCalled when a device removed from this bus."]
#[doc = " @shutdown:\tCalled at shut-down time to quiesce the device."]
#[doc = ""]
#[doc = " @online:\tCalled to put the device back online (after offlining it)."]
#[doc = " @offline:\tCalled to put the device offline for hot-removal. May fail."]
#[doc = ""]
#[doc = " @suspend:\tCalled when a device on this bus wants to go to sleep mode."]
#[doc = " @resume:\tCalled to bring a device on this bus out of sleep mode."]
#[doc = " @num_vf:\tCalled to find out how many virtual functions a device on this"]
#[doc = "\t\tbus supports."]
#[doc = " @pm:\t\tPower management operations of this bus, callback the specific"]
#[doc = "\t\tdevice driver's pm-ops."]
#[doc = " @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU"]
#[doc = "              driver implementations to a bus and allow the driver to do"]
#[doc = "              bus-specific setup"]
#[doc = " @p:\t\tThe private data of the driver core, only the driver core can"]
#[doc = "\t\ttouch this."]
#[doc = " @lock_key:\tLock class key for use by the lock validator"]
#[doc = " @force_dma:\tAssume devices on this bus should be set up by dma_configure()"]
#[doc = " \t\teven if DMA capability is not explicitly described by firmware."]
#[doc = ""]
#[doc = " A bus is a channel between the processor and one or more devices. For the"]
#[doc = " purposes of the device model, all devices are connected via a bus, even if"]
#[doc = " it is an internal, virtual, \"platform\" bus. Buses can plug into each other."]
#[doc = " A USB controller is usually a PCI device, for example. The device model"]
#[doc = " represents the actual connections between buses and the devices they control."]
#[doc = " A bus is represented by the bus_type structure. It contains the name, the"]
#[doc = " default attributes, the bus' methods, PM operations, and the driver core's"]
#[doc = " private data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_type {
    pub name: *const c_types::c_char,
    pub dev_name: *const c_types::c_char,
    pub dev_root: *mut device,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *mut device_driver) -> c_types::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> c_types::c_int,
    >,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub online: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub offline: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> c_types::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub num_vf: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub pm: *const dev_pm_ops,
    pub iommu_ops: *const iommu_ops,
    pub p: *mut subsys_private,
    pub lock_key: lock_class_key,
    pub force_dma: bool_,
}
#[test]
fn bindgen_test_layout_bus_type() {
    assert_eq!(
        ::core::mem::size_of::<bus_type>(),
        160usize,
        concat!("Size of: ", stringify!(bus_type))
    );
    assert_eq!(
        ::core::mem::align_of::<bus_type>(),
        8usize,
        concat!("Alignment of ", stringify!(bus_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).dev_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).dev_root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(dev_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).bus_groups as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(bus_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).dev_groups as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(dev_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).drv_groups as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(drv_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).match_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).uevent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(uevent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).probe as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).remove as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).shutdown as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).online as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(online)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).offline as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(offline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).suspend as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).resume as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).num_vf as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(num_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).pm as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(pm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).iommu_ops as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(iommu_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).p as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).lock_key as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).force_dma as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(force_dma)
        )
    );
}
impl Default for bus_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const probe_type_PROBE_DEFAULT_STRATEGY: probe_type = 0;
pub const probe_type_PROBE_PREFER_ASYNCHRONOUS: probe_type = 1;
pub const probe_type_PROBE_FORCE_SYNCHRONOUS: probe_type = 2;
#[doc = " enum probe_type - device driver probe type to try"]
#[doc = "\tDevice drivers may opt in for special handling of their"]
#[doc = "\trespective probe routines. This tells the core what to"]
#[doc = "\texpect and prefer."]
#[doc = ""]
#[doc = " @PROBE_DEFAULT_STRATEGY: Used by drivers that work equally well"]
#[doc = "\twhether probed synchronously or asynchronously."]
#[doc = " @PROBE_PREFER_ASYNCHRONOUS: Drivers for \"slow\" devices which"]
#[doc = "\tprobing order is not essential for booting the system may"]
#[doc = "\topt into executing their probes asynchronously."]
#[doc = " @PROBE_FORCE_SYNCHRONOUS: Use this to annotate drivers that need"]
#[doc = "\ttheir probe routines to run synchronously with driver and"]
#[doc = "\tdevice registration (with the exception of -EPROBE_DEFER"]
#[doc = "\thandling - re-probing always ends up being done asynchronously)."]
#[doc = ""]
#[doc = " Note that the end goal is to switch the kernel to use asynchronous"]
#[doc = " probing by default, so annotating drivers with"]
#[doc = " %PROBE_PREFER_ASYNCHRONOUS is a temporary measure that allows us"]
#[doc = " to speed up boot process while we are validating the rest of the"]
#[doc = " drivers."]
pub type probe_type = u32;
#[doc = " struct device_driver - The basic device driver structure"]
#[doc = " @name:\tName of the device driver."]
#[doc = " @bus:\tThe bus which the device of this driver belongs to."]
#[doc = " @owner:\tThe module owner."]
#[doc = " @mod_name:\tUsed for built-in modules."]
#[doc = " @suppress_bind_attrs: Disables bind/unbind via sysfs."]
#[doc = " @probe_type:\tType of the probe (synchronous or asynchronous) to use."]
#[doc = " @of_match_table: The open firmware table."]
#[doc = " @acpi_match_table: The ACPI match table."]
#[doc = " @probe:\tCalled to query the existence of a specific device,"]
#[doc = "\t\twhether this driver can work with it, and bind the driver"]
#[doc = "\t\tto a specific device."]
#[doc = " @remove:\tCalled when the device is removed from the system to"]
#[doc = "\t\tunbind a device from this driver."]
#[doc = " @shutdown:\tCalled at shut-down time to quiesce the device."]
#[doc = " @suspend:\tCalled to put the device to sleep mode. Usually to a"]
#[doc = "\t\tlow power state."]
#[doc = " @resume:\tCalled to bring a device from sleep mode."]
#[doc = " @groups:\tDefault attributes that get created by the driver core"]
#[doc = "\t\tautomatically."]
#[doc = " @pm:\t\tPower management operations of the device which matched"]
#[doc = "\t\tthis driver."]
#[doc = " @p:\t\tDriver core's private data, no one other than the driver"]
#[doc = "\t\tcore can touch this."]
#[doc = ""]
#[doc = " The device driver-model tracks all of the drivers known to the system."]
#[doc = " The main reason for this tracking is to enable the driver core to match"]
#[doc = " up drivers with new devices. Once drivers are known objects within the"]
#[doc = " system, however, a number of other things become possible. Device drivers"]
#[doc = " can export information and configuration variables that are independent"]
#[doc = " of any specific device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_driver {
    pub name: *const c_types::c_char,
    pub bus: *mut bus_type,
    pub owner: *mut module,
    pub mod_name: *const c_types::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type,
    pub of_match_table: *const of_device_id,
    pub acpi_match_table: *const acpi_device_id,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> c_types::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub p: *mut driver_private,
}
#[test]
fn bindgen_test_layout_device_driver() {
    assert_eq!(
        ::core::mem::size_of::<device_driver>(),
        120usize,
        concat!("Size of: ", stringify!(device_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<device_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(device_driver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).bus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).owner as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).mod_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(mod_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<device_driver>())).suppress_bind_attrs as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(suppress_bind_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).probe_type as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(probe_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).of_match_table as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(of_match_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).acpi_match_table as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(acpi_match_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).probe as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).remove as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).shutdown as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).suspend as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).resume as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).groups as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).pm as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(pm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).p as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(p)
        )
    );
}
impl Default for device_driver {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct class - device classes"]
#[doc = " @name:\tName of the class."]
#[doc = " @owner:\tThe module owner."]
#[doc = " @class_groups: Default attributes of this class."]
#[doc = " @dev_groups:\tDefault attributes of the devices that belong to the class."]
#[doc = " @dev_kobj:\tThe kobject that represents this class and links it into the hierarchy."]
#[doc = " @dev_uevent:\tCalled when a device is added, removed from this class, or a"]
#[doc = "\t\tfew other things that generate uevents to add the environment"]
#[doc = "\t\tvariables."]
#[doc = " @devnode:\tCallback to provide the devtmpfs."]
#[doc = " @class_release: Called to release this class."]
#[doc = " @dev_release: Called to release the device."]
#[doc = " @shutdown_pre: Called at shut-down time before driver shutdown."]
#[doc = " @ns_type:\tCallbacks so sysfs can detemine namespaces."]
#[doc = " @namespace:\tNamespace of the device belongs to this class."]
#[doc = " @get_ownership: Allows class to specify uid/gid of the sysfs directories"]
#[doc = "\t\tfor the devices belonging to the class. Usually tied to"]
#[doc = "\t\tdevice's namespace."]
#[doc = " @pm:\t\tThe default device power management operations of this class."]
#[doc = " @p:\t\tThe private data of the driver core, no one other than the"]
#[doc = "\t\tdriver core can touch this."]
#[doc = ""]
#[doc = " A class is a higher-level view of a device that abstracts out low-level"]
#[doc = " implementation details. Drivers may see a SCSI disk or an ATA disk, but,"]
#[doc = " at the class level, they are all simply disks. Classes allow user space"]
#[doc = " to work with devices based on what they do, rather than how they are"]
#[doc = " connected or how they work."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct class {
    pub name: *const c_types::c_char,
    pub owner: *mut module,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_kobj: *mut kobject,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> c_types::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, mode: *mut umode_t) -> *mut c_types::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(class: *mut class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown_pre:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> *const c_types::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
    pub p: *mut subsys_private,
}
#[test]
fn bindgen_test_layout_class() {
    assert_eq!(
        ::core::mem::size_of::<class>(),
        120usize,
        concat!("Size of: ", stringify!(class))
    );
    assert_eq!(
        ::core::mem::align_of::<class>(),
        8usize,
        concat!("Alignment of ", stringify!(class))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).class_groups as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(class_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).dev_groups as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(dev_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).dev_kobj as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(dev_kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).dev_uevent as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(dev_uevent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).devnode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(devnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).class_release as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(class_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).dev_release as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(dev_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).shutdown_pre as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(shutdown_pre)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).ns_type as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(ns_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).namespace as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(namespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).get_ownership as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(get_ownership)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).pm as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(class), "::", stringify!(pm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).p as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(class), "::", stringify!(p))
    );
}
impl Default for class {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_type {
    pub name: *const c_types::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> c_types::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            mode: *mut umode_t,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ) -> *mut c_types::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
}
#[test]
fn bindgen_test_layout_device_type() {
    assert_eq!(
        ::core::mem::size_of::<device_type>(),
        48usize,
        concat!("Size of: ", stringify!(device_type))
    );
    assert_eq!(
        ::core::mem::align_of::<device_type>(),
        8usize,
        concat!("Alignment of ", stringify!(device_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).groups as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).uevent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(uevent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).devnode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(devnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).release as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).pm as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(pm)
        )
    );
}
impl Default for device_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: c_types::c_uint,
    pub segment_boundary_mask: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_device_dma_parameters() {
    assert_eq!(
        ::core::mem::size_of::<device_dma_parameters>(),
        16usize,
        concat!("Size of: ", stringify!(device_dma_parameters))
    );
    assert_eq!(
        ::core::mem::align_of::<device_dma_parameters>(),
        8usize,
        concat!("Alignment of ", stringify!(device_dma_parameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<device_dma_parameters>())).max_segment_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_dma_parameters),
            "::",
            stringify!(max_segment_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<device_dma_parameters>())).segment_boundary_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_dma_parameters),
            "::",
            stringify!(segment_boundary_mask)
        )
    );
}
pub const dl_dev_state_DL_DEV_NO_DRIVER: dl_dev_state = 0;
pub const dl_dev_state_DL_DEV_PROBING: dl_dev_state = 1;
pub const dl_dev_state_DL_DEV_DRIVER_BOUND: dl_dev_state = 2;
pub const dl_dev_state_DL_DEV_UNBINDING: dl_dev_state = 3;
#[doc = " enum dl_dev_state - Device driver presence tracking information."]
#[doc = " @DL_DEV_NO_DRIVER: There is no driver attached to the device."]
#[doc = " @DL_DEV_PROBING: A driver is probing."]
#[doc = " @DL_DEV_DRIVER_BOUND: The driver has been bound to the device."]
#[doc = " @DL_DEV_UNBINDING: The driver is unbinding from the device."]
pub type dl_dev_state = u32;
#[doc = " struct dev_links_info - Device data related to device links."]
#[doc = " @suppliers: List of links to supplier devices."]
#[doc = " @consumers: List of links to consumer devices."]
#[doc = " @status: Driver status information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub status: dl_dev_state,
}
#[test]
fn bindgen_test_layout_dev_links_info() {
    assert_eq!(
        ::core::mem::size_of::<dev_links_info>(),
        40usize,
        concat!("Size of: ", stringify!(dev_links_info))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_links_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_links_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_links_info>())).suppliers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_links_info),
            "::",
            stringify!(suppliers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_links_info>())).consumers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_links_info),
            "::",
            stringify!(consumers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_links_info>())).status as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_links_info),
            "::",
            stringify!(status)
        )
    );
}
impl Default for dev_links_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct device - The basic device structure"]
#[doc = " @parent:\tThe device's \"parent\" device, the device to which it is attached."]
#[doc = " \t\tIn most cases, a parent device is some sort of bus or host"]
#[doc = " \t\tcontroller. If parent is NULL, the device, is a top-level device,"]
#[doc = " \t\twhich is not usually what you want."]
#[doc = " @p:\t\tHolds the private data of the driver core portions of the device."]
#[doc = " \t\tSee the comment of the struct device_private for detail."]
#[doc = " @kobj:\tA top-level, abstract class from which other classes are derived."]
#[doc = " @init_name:\tInitial name of the device."]
#[doc = " @type:\tThe type of device."]
#[doc = " \t\tThis identifies the device type and carries type-specific"]
#[doc = " \t\tinformation."]
#[doc = " @mutex:\tMutex to synchronize calls to its driver."]
#[doc = " @bus:\tType of bus device is on."]
#[doc = " @driver:\tWhich driver has allocated this"]
#[doc = " @platform_data: Platform data specific to the device."]
#[doc = " \t\tExample: For devices on custom boards, as typical of embedded"]
#[doc = " \t\tand SOC based hardware, Linux often uses platform_data to point"]
#[doc = " \t\tto board-specific structures describing devices and how they"]
#[doc = " \t\tare wired.  That can include what ports are available, chip"]
#[doc = " \t\tvariants, which GPIO pins act in what additional roles, and so"]
#[doc = " \t\ton.  This shrinks the \"Board Support Packages\" (BSPs) and"]
#[doc = " \t\tminimizes board-specific #ifdefs in drivers."]
#[doc = " @driver_data: Private pointer for driver specific info."]
#[doc = " @links:\tLinks to suppliers and consumers of this device."]
#[doc = " @power:\tFor device power management."]
#[doc = "\t\tSee Documentation/driver-api/pm/devices.rst for details."]
#[doc = " @pm_domain:\tProvide callbacks that are executed during system suspend,"]
#[doc = " \t\thibernation, system resume and during runtime PM transitions"]
#[doc = " \t\talong with subsystem-level and driver-level callbacks."]
#[doc = " @pins:\tFor device pin management."]
#[doc = "\t\tSee Documentation/driver-api/pinctl.rst for details."]
#[doc = " @msi_list:\tHosts MSI descriptors"]
#[doc = " @msi_domain: The generic MSI domain this device is using."]
#[doc = " @numa_node:\tNUMA node this device is close to."]
#[doc = " @dma_ops:    DMA mapping operations for this device."]
#[doc = " @dma_mask:\tDma mask (if dma'ble device)."]
#[doc = " @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all"]
#[doc = " \t\thardware supports 64-bit addresses for consistent allocations"]
#[doc = " \t\tsuch descriptors."]
#[doc = " @dma_pfn_offset: offset of DMA memory range relatively of RAM"]
#[doc = " @dma_parms:\tA low level driver may set these to teach IOMMU code about"]
#[doc = " \t\tsegment limitations."]
#[doc = " @dma_pools:\tDma pools (if dma'ble device)."]
#[doc = " @dma_mem:\tInternal for coherent mem override."]
#[doc = " @cma_area:\tContiguous memory area for dma allocations"]
#[doc = " @archdata:\tFor arch-specific additions."]
#[doc = " @of_node:\tAssociated device tree node."]
#[doc = " @fwnode:\tAssociated device node supplied by platform firmware."]
#[doc = " @devt:\tFor creating the sysfs \"dev\"."]
#[doc = " @id:\t\tdevice instance"]
#[doc = " @devres_lock: Spinlock to protect the resource of the device."]
#[doc = " @devres_head: The resources list of the device."]
#[doc = " @knode_class: The node used to add the device to the class list."]
#[doc = " @class:\tThe class of the device."]
#[doc = " @groups:\tOptional attribute groups."]
#[doc = " @release:\tCallback to free the device after all references have"]
#[doc = " \t\tgone away. This should be set by the allocator of the"]
#[doc = " \t\tdevice (i.e. the bus driver that discovered the device)."]
#[doc = " @iommu_group: IOMMU group the device belongs to."]
#[doc = " @iommu_fwspec: IOMMU-specific properties supplied by firmware."]
#[doc = ""]
#[doc = " @offline_disabled: If set, the device is permanently online."]
#[doc = " @offline:\tSet after successful invocation of bus type's .offline()."]
#[doc = " @of_node_reused: Set if the device-tree node is shared with an ancestor"]
#[doc = "              device."]
#[doc = ""]
#[doc = " At the lowest level, every device in a Linux system is represented by an"]
#[doc = " instance of struct device. The device structure contains the information"]
#[doc = " that the device model core needs to model the system. Most subsystems,"]
#[doc = " however, track additional information about the devices they host. As a"]
#[doc = " result, it is rare for devices to be represented by bare device structures;"]
#[doc = " instead, that structure, like kobject structures, is usually embedded within"]
#[doc = " a higher-level representation of the device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub parent: *mut device,
    pub p: *mut device_private,
    pub kobj: kobject,
    pub init_name: *const c_types::c_char,
    pub type_: *const device_type,
    pub mutex: mutex,
    pub bus: *mut bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut c_types::c_void,
    pub driver_data: *mut c_types::c_void,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub msi_domain: *mut irq_domain,
    pub pins: *mut dev_pin_info,
    pub msi_list: list_head,
    pub numa_node: c_types::c_int,
    pub dma_ops: *const dma_map_ops,
    pub dma_mask: *mut u64,
    pub coherent_dma_mask: u64,
    pub dma_pfn_offset: c_types::c_ulong,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub dma_mem: *mut dma_coherent_mem,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub devt: dev_t,
    pub id: u32,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub knode_class: klist_node,
    pub class: *mut class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu_fwspec: *mut iommu_fwspec,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_device() {
    assert_eq!(
        ::core::mem::size_of::<device>(),
        728usize,
        concat!("Size of: ", stringify!(device))
    );
    assert_eq!(
        ::core::mem::align_of::<device>(),
        8usize,
        concat!("Alignment of ", stringify!(device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).p as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(device), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).kobj as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).init_name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(init_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).type_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).mutex as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).bus as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).driver as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).platform_data as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(platform_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).driver_data as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(driver_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).links as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).power as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(power)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).pm_domain as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(pm_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).msi_domain as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(msi_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).pins as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(pins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).msi_list as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(msi_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).numa_node as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_ops as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_mask as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).coherent_dma_mask as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(coherent_dma_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_pfn_offset as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_pfn_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_parms as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_parms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_pools as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_mem as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).archdata as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(archdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).of_node as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(of_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).fwnode as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(fwnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).devt as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(devt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).id as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).devres_lock as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(devres_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).devres_head as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(devres_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).knode_class as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(knode_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).class as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).groups as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).release as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).iommu_group as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(iommu_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).iommu_fwspec as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(iommu_fwspec)
        )
    );
}
impl Default for device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct wakeup_source - Representation of wakeup sources"]
#[doc = ""]
#[doc = " @name: Name of the wakeup source"]
#[doc = " @entry: Wakeup source list entry"]
#[doc = " @lock: Wakeup source lock"]
#[doc = " @wakeirq: Optional device specific wakeirq"]
#[doc = " @timer: Wakeup timer list"]
#[doc = " @timer_expires: Wakeup timer expiration"]
#[doc = " @total_time: Total time this wakeup source has been active."]
#[doc = " @max_time: Maximum time this wakeup source has been continuously active."]
#[doc = " @last_time: Monotonic clock when the wakeup source's was touched last time."]
#[doc = " @prevent_sleep_time: Total time this source has been preventing autosleep."]
#[doc = " @event_count: Number of signaled wakeup events."]
#[doc = " @active_count: Number of times the wakeup source was activated."]
#[doc = " @relax_count: Number of times the wakeup source was deactivated."]
#[doc = " @expire_count: Number of times the wakeup source's timeout has expired."]
#[doc = " @wakeup_count: Number of times the wakeup source might abort suspend."]
#[doc = " @active: Status of the wakeup source."]
#[doc = " @has_timeout: The wakeup source has been activated with a timeout."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const c_types::c_char,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: c_types::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: c_types::c_ulong,
    pub active_count: c_types::c_ulong,
    pub relax_count: c_types::c_ulong,
    pub expire_count: c_types::c_ulong,
    pub wakeup_count: c_types::c_ulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_wakeup_source() {
    assert_eq!(
        ::core::mem::size_of::<wakeup_source>(),
        176usize,
        concat!("Size of: ", stringify!(wakeup_source))
    );
    assert_eq!(
        ::core::mem::align_of::<wakeup_source>(),
        8usize,
        concat!("Alignment of ", stringify!(wakeup_source))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).wakeirq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(wakeirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).timer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).timer_expires as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(timer_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).total_time as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(total_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).max_time as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(max_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).last_time as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(last_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<wakeup_source>())).start_prevent_time as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(start_prevent_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<wakeup_source>())).prevent_sleep_time as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(prevent_sleep_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).event_count as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(event_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).active_count as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(active_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).relax_count as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(relax_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).expire_count as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(expire_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).wakeup_count as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(wakeup_count)
        )
    );
}
impl Default for wakeup_source {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    pub kobj: kobject,
    pub owner: *mut module,
    pub ops: *const file_operations,
    pub list: list_head,
    pub dev: dev_t,
    pub count: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_cdev() {
    assert_eq!(
        ::core::mem::size_of::<cdev>(),
        104usize,
        concat!("Size of: ", stringify!(cdev))
    );
    assert_eq!(
        ::core::mem::align_of::<cdev>(),
        8usize,
        concat!("Alignment of ", stringify!(cdev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).kobj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).owner as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).ops as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(cdev), "::", stringify!(ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).list as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).dev as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(cdev), "::", stringify!(dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).count as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(count)
        )
    );
}
impl Default for cdev {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn cdev_init(arg1: *mut cdev, arg2: *const file_operations);
}
extern "C" {
    pub fn cdev_add(arg1: *mut cdev, arg2: dev_t, arg3: c_types::c_uint) -> c_types::c_int;
}
extern "C" {
    pub fn cdev_del(arg1: *mut cdev);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdso_image {
    pub data: *mut c_types::c_void,
    pub size: c_types::c_ulong,
    pub alt: c_types::c_ulong,
    pub alt_len: c_types::c_ulong,
    pub sym_vvar_start: c_types::c_long,
    pub sym_vvar_page: c_types::c_long,
    pub sym_hpet_page: c_types::c_long,
    pub sym_pvclock_page: c_types::c_long,
    pub sym_hvclock_page: c_types::c_long,
    pub sym_VDSO32_NOTE_MASK: c_types::c_long,
    pub sym___kernel_sigreturn: c_types::c_long,
    pub sym___kernel_rt_sigreturn: c_types::c_long,
    pub sym___kernel_vsyscall: c_types::c_long,
    pub sym_int80_landing_pad: c_types::c_long,
}
#[test]
fn bindgen_test_layout_vdso_image() {
    assert_eq!(
        ::core::mem::size_of::<vdso_image>(),
        112usize,
        concat!("Size of: ", stringify!(vdso_image))
    );
    assert_eq!(
        ::core::mem::align_of::<vdso_image>(),
        8usize,
        concat!("Alignment of ", stringify!(vdso_image))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).alt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).alt_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(alt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_vvar_start as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_vvar_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_vvar_page as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_vvar_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_hpet_page as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_hpet_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_pvclock_page as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_pvclock_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_hvclock_page as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_hvclock_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym_VDSO32_NOTE_MASK as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_VDSO32_NOTE_MASK)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_sigreturn as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_sigreturn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_rt_sigreturn as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_rt_sigreturn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_vsyscall as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_vsyscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym_int80_landing_pad as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_int80_landing_pad)
        )
    );
}
impl Default for vdso_image {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_Off = __u64;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: c_types::c_uchar,
    pub st_other: c_types::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_sym() {
    assert_eq!(
        ::core::mem::size_of::<elf64_sym>(),
        24usize,
        concat!("Size of: ", stringify!(elf64_sym))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_sym>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_sym))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_other as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_other)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_shndx as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_shndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_size)
        )
    );
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_hdr {
    pub e_ident: [c_types::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
#[test]
fn bindgen_test_layout_elf64_hdr() {
    assert_eq!(
        ::core::mem::size_of::<elf64_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(elf64_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_hdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_ident as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_ident)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_machine as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_machine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phoff as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_ehsize as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_ehsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phentsize as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phentsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phnum as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shentsize as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shentsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shnum as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shstrndx as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shstrndx)
        )
    );
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_shdr() {
    assert_eq!(
        ::core::mem::size_of::<elf64_shdr>(),
        64usize,
        concat!("Size of: ", stringify!(elf64_shdr))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_shdr>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_shdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_link as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_info as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_addralign as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_addralign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_entsize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_entsize)
        )
    );
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: c_types::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            val: *const c_types::c_char,
            kp: *const kernel_param,
        ) -> c_types::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            buffer: *mut c_types::c_char,
            kp: *const kernel_param,
        ) -> c_types::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>,
}
#[test]
fn bindgen_test_layout_kernel_param_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param_ops>(),
        32usize,
        concat!("Size of: ", stringify!(kernel_param_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).set as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(free)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const c_types::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16,
    pub level: s8,
    pub flags: u8,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut c_types::c_void,
    pub str: *const kparam_string,
    pub arr: *const kparam_array,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_kernel_param__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(kernel_param__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
impl Default for kernel_param__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kernel_param() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param>(),
        40usize,
        concat!("Size of: ", stringify!(kernel_param))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).mod_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).perm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).level as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).flags as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for kernel_param {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_string {
    pub maxlen: c_types::c_uint,
    pub string: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_kparam_string() {
    assert_eq!(
        ::core::mem::size_of::<kparam_string>(),
        16usize,
        concat!("Size of: ", stringify!(kparam_string))
    );
    assert_eq!(
        ::core::mem::align_of::<kparam_string>(),
        8usize,
        concat!("Alignment of ", stringify!(kparam_string))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_string>())).maxlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_string),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_string>())).string as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_string),
            "::",
            stringify!(string)
        )
    );
}
impl Default for kparam_string {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_array {
    pub max: c_types::c_uint,
    pub elemsize: c_types::c_uint,
    pub num: *mut c_types::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_kparam_array() {
    assert_eq!(
        ::core::mem::size_of::<kparam_array>(),
        32usize,
        concat!("Size of: ", stringify!(kparam_array))
    );
    assert_eq!(
        ::core::mem::align_of::<kparam_array>(),
        8usize,
        concat!("Alignment of ", stringify!(kparam_array))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).elemsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(elemsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).elem as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(elem)
        )
    );
}
impl Default for kparam_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
#[test]
fn bindgen_test_layout_latch_tree_node() {
    assert_eq!(
        ::core::mem::size_of::<latch_tree_node>(),
        48usize,
        concat!("Size of: ", stringify!(latch_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<latch_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(latch_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<latch_tree_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(latch_tree_node),
            "::",
            stringify!(node)
        )
    );
}
impl Default for latch_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mod_arch_specific {}
#[test]
fn bindgen_test_layout_mod_arch_specific() {
    assert_eq!(
        ::core::mem::size_of::<mod_arch_specific>(),
        0usize,
        concat!("Size of: ", stringify!(mod_arch_specific))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_arch_specific>(),
        1usize,
        concat!("Alignment of ", stringify!(mod_arch_specific))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
#[test]
fn bindgen_test_layout_module_kobject() {
    assert_eq!(
        ::core::mem::size_of::<module_kobject>(),
        96usize,
        concat!("Size of: ", stringify!(module_kobject))
    );
    assert_eq!(
        ::core::mem::align_of::<module_kobject>(),
        8usize,
        concat!("Alignment of ", stringify!(module_kobject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).kobj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).mod_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).drivers_dir as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(drivers_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).mp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).kobj_completion as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(kobj_completion)
        )
    );
}
impl Default for module_kobject {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut c_types::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *const c_types::c_char,
            count: usize,
        ) -> isize,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut module, arg2: *const c_types::c_char),
    >,
    pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> c_types::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
#[test]
fn bindgen_test_layout_module_attribute() {
    assert_eq!(
        ::core::mem::size_of::<module_attribute>(),
        56usize,
        concat!("Size of: ", stringify!(module_attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<module_attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(module_attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).show as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).store as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(store)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).setup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).test as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(test)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(free)
        )
    );
}
impl Default for module_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const module_state_MODULE_STATE_LIVE: module_state = 0;
pub const module_state_MODULE_STATE_COMING: module_state = 1;
pub const module_state_MODULE_STATE_GOING: module_state = 2;
pub const module_state_MODULE_STATE_UNFORMED: module_state = 3;
pub type module_state = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
#[test]
fn bindgen_test_layout_mod_tree_node() {
    assert_eq!(
        ::core::mem::size_of::<mod_tree_node>(),
        56usize,
        concat!("Size of: ", stringify!(mod_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_tree_node>())).mod_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_tree_node),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_tree_node>())).node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_tree_node),
            "::",
            stringify!(node)
        )
    );
}
impl Default for mod_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_layout {
    pub base: *mut c_types::c_void,
    pub size: c_types::c_uint,
    pub text_size: c_types::c_uint,
    pub ro_size: c_types::c_uint,
    pub ro_after_init_size: c_types::c_uint,
    pub mtn: mod_tree_node,
}
#[test]
fn bindgen_test_layout_module_layout() {
    assert_eq!(
        ::core::mem::size_of::<module_layout>(),
        80usize,
        concat!("Size of: ", stringify!(module_layout))
    );
    assert_eq!(
        ::core::mem::align_of::<module_layout>(),
        8usize,
        concat!("Alignment of ", stringify!(module_layout))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).text_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(text_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).ro_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(ro_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<module_layout>())).ro_after_init_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(ro_after_init_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).mtn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(mtn)
        )
    );
}
impl Default for module_layout {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: c_types::c_uint,
    pub strtab: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_mod_kallsyms() {
    assert_eq!(
        ::core::mem::size_of::<mod_kallsyms>(),
        24usize,
        concat!("Size of: ", stringify!(mod_kallsyms))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_kallsyms>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_kallsyms))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).symtab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(symtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).num_symtab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(num_symtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).strtab as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(strtab)
        )
    );
}
impl Default for mod_kallsyms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klp_modinfo {
    pub hdr: Elf64_Ehdr,
    pub sechdrs: *mut Elf64_Shdr,
    pub secstrings: *mut c_types::c_char,
    pub symndx: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_klp_modinfo() {
    assert_eq!(
        ::core::mem::size_of::<klp_modinfo>(),
        88usize,
        concat!("Size of: ", stringify!(klp_modinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<klp_modinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(klp_modinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).sechdrs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(sechdrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).secstrings as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(secstrings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).symndx as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(symndx)
        )
    );
}
impl Default for klp_modinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn add_device_randomness(arg1: *const c_types::c_void, arg2: c_types::c_uint);
}
extern "C" {
    pub fn get_random_bytes(buf: *mut c_types::c_void, nbytes: c_types::c_int);
}
extern "C" {
    pub fn wait_for_random_bytes() -> c_types::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub fn krealloc(arg1: *const c_types::c_void, arg2: usize, arg3: gfp_t)
        -> *mut c_types::c_void;
}
extern "C" {
    pub fn kfree(arg1: *const c_types::c_void);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: c_types::c_int,
    pub fixup: c_types::c_int,
    pub handler: c_types::c_int,
}
#[test]
fn bindgen_test_layout_exception_table_entry() {
    assert_eq!(
        ::core::mem::size_of::<exception_table_entry>(),
        12usize,
        concat!("Size of: ", stringify!(exception_table_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<exception_table_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(exception_table_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).insn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(insn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).fixup as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(fixup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(handler)
        )
    );
}
extern "C" {
    pub fn _copy_from_user(
        arg1: *mut c_types::c_void,
        arg2: *const c_types::c_void,
        arg3: c_types::c_ulong,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn _copy_to_user(
        arg1: *mut c_types::c_void,
        arg2: *const c_types::c_void,
        arg3: c_types::c_ulong,
    ) -> c_types::c_ulong;
}
pub type kernel_ulong_t = c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acpi_device_id {
    pub id: [__u8; 9usize],
    pub driver_data: kernel_ulong_t,
    pub cls: __u32,
    pub cls_msk: __u32,
}
#[test]
fn bindgen_test_layout_acpi_device_id() {
    assert_eq!(
        ::core::mem::size_of::<acpi_device_id>(),
        32usize,
        concat!("Size of: ", stringify!(acpi_device_id))
    );
    assert_eq!(
        ::core::mem::align_of::<acpi_device_id>(),
        8usize,
        concat!("Alignment of ", stringify!(acpi_device_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<acpi_device_id>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acpi_device_id),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<acpi_device_id>())).driver_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acpi_device_id),
            "::",
            stringify!(driver_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<acpi_device_id>())).cls as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acpi_device_id),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<acpi_device_id>())).cls_msk as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(acpi_device_id),
            "::",
            stringify!(cls_msk)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_device_id {
    pub name: [c_types::c_char; 32usize],
    pub type_: [c_types::c_char; 32usize],
    pub compatible: [c_types::c_char; 128usize],
    pub data: *const c_types::c_void,
}
#[test]
fn bindgen_test_layout_of_device_id() {
    assert_eq!(
        ::core::mem::size_of::<of_device_id>(),
        200usize,
        concat!("Size of: ", stringify!(of_device_id))
    );
    assert_eq!(
        ::core::mem::align_of::<of_device_id>(),
        8usize,
        concat!("Alignment of ", stringify!(of_device_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<of_device_id>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(of_device_id),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<of_device_id>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(of_device_id),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<of_device_id>())).compatible as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(of_device_id),
            "::",
            stringify!(compatible)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<of_device_id>())).data as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(of_device_id),
            "::",
            stringify!(data)
        )
    );
}
impl Default for of_device_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref {
    pub count: atomic_long_t,
    pub percpu_count_ptr: c_types::c_ulong,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_percpu_ref() {
    assert_eq!(
        ::core::mem::size_of::<percpu_ref>(),
        56usize,
        concat!("Size of: ", stringify!(percpu_ref))
    );
    assert_eq!(
        ::core::mem::align_of::<percpu_ref>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_ref))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).percpu_count_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(percpu_count_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).confirm_switch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(confirm_switch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).rcu as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for percpu_ref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl percpu_ref {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_atomic: bool_) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct vmem_altmap - pre-allocated storage for vmemmap_populate"]
#[doc = " @base_pfn: base of the entire dev_pagemap mapping"]
#[doc = " @reserve: pages mapped, but reserved for driver use (relative to @base)"]
#[doc = " @free: free pages set aside in the mapping for memmap storage"]
#[doc = " @align: pages reserved to meet allocation alignments"]
#[doc = " @alloc: track pages consumed, private to vmemmap_populate()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: c_types::c_ulong,
    pub reserve: c_types::c_ulong,
    pub free: c_types::c_ulong,
    pub align: c_types::c_ulong,
    pub alloc: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_vmem_altmap() {
    assert_eq!(
        ::core::mem::size_of::<vmem_altmap>(),
        40usize,
        concat!("Size of: ", stringify!(vmem_altmap))
    );
    assert_eq!(
        ::core::mem::align_of::<vmem_altmap>(),
        8usize,
        concat!("Alignment of ", stringify!(vmem_altmap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).base_pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(base_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).reserve as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).align as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(alloc)
        )
    );
}
pub const memory_type_MEMORY_DEVICE_HOST: memory_type = 0;
pub const memory_type_MEMORY_DEVICE_PRIVATE: memory_type = 1;
pub const memory_type_MEMORY_DEVICE_PUBLIC: memory_type = 2;
pub type memory_type = u32;
pub type dev_page_fault_t = ::core::option::Option<
    unsafe extern "C" fn(
        vma: *mut vm_area_struct,
        addr: c_types::c_ulong,
        page: *const page,
        flags: c_types::c_uint,
        pmdp: *mut pmd_t,
    ) -> c_types::c_int,
>;
pub type dev_page_free_t =
    ::core::option::Option<unsafe extern "C" fn(page: *mut page, data: *mut c_types::c_void)>;
#[doc = " struct dev_pagemap - metadata for ZONE_DEVICE mappings"]
#[doc = " @page_fault: callback when CPU fault on an unaddressable device page"]
#[doc = " @page_free: free page callback when page refcount reaches 1"]
#[doc = " @altmap: pre-allocated/reserved memory for vmemmap allocations"]
#[doc = " @res: physical address range covered by @ref"]
#[doc = " @ref: reference count that pins the devm_memremap_pages() mapping"]
#[doc = " @dev: host device of the mapping for debug"]
#[doc = " @data: private data pointer for page_free()"]
#[doc = " @type: memory type: see MEMORY_* in memory_hotplug.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pagemap {
    pub page_fault: dev_page_fault_t,
    pub page_free: dev_page_free_t,
    pub altmap: *mut vmem_altmap,
    pub res: *const resource,
    pub ref_: *mut percpu_ref,
    pub dev: *mut device,
    pub data: *mut c_types::c_void,
    pub type_: memory_type,
}
#[test]
fn bindgen_test_layout_dev_pagemap() {
    assert_eq!(
        ::core::mem::size_of::<dev_pagemap>(),
        64usize,
        concat!("Size of: ", stringify!(dev_pagemap))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pagemap>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pagemap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).page_fault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(page_fault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).page_free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(page_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).altmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(altmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).res as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).ref_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).dev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).type_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for dev_pagemap {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anon_vma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_fault {
    pub vma: *mut vm_area_struct,
    pub flags: c_types::c_uint,
    pub gfp_mask: gfp_t,
    pub pgoff: c_types::c_ulong,
    pub address: c_types::c_ulong,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub orig_pte: pte_t,
    pub cow_page: *mut page,
    pub memcg: *mut mem_cgroup,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
#[test]
fn bindgen_test_layout_vm_fault() {
    assert_eq!(
        ::core::mem::size_of::<vm_fault>(),
        104usize,
        concat!("Size of: ", stringify!(vm_fault))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_fault>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_fault))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).vma as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(vma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).gfp_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).pgoff as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(pgoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).address as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).pmd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(pmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).pud as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(pud)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).orig_pte as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(orig_pte)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).cow_page as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(cow_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).memcg as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(memcg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).page as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).pte as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(pte)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).ptl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(ptl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).prealloc_pte as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(prealloc_pte)
        )
    );
}
impl Default for vm_fault {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const page_entry_size_PE_SIZE_PTE: page_entry_size = 0;
pub const page_entry_size_PE_SIZE_PMD: page_entry_size = 1;
pub const page_entry_size_PE_SIZE_PUD: page_entry_size = 2;
pub type page_entry_size = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub split: ::core::option::Option<
        unsafe extern "C" fn(area: *mut vm_area_struct, addr: c_types::c_ulong) -> c_types::c_int,
    >,
    pub mremap:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> c_types::c_int>,
    pub fault: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> c_types::c_int>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(vmf: *mut vm_fault, pe_size: page_entry_size) -> c_types::c_int,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            vmf: *mut vm_fault,
            start_pgoff: c_types::c_ulong,
            end_pgoff: c_types::c_ulong,
        ),
    >,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> c_types::c_int>,
    pub pfn_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> c_types::c_int>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: c_types::c_ulong,
            buf: *mut c_types::c_void,
            len: c_types::c_int,
            write: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct) -> *const c_types::c_char,
    >,
    pub set_policy: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, new: *mut mempolicy) -> c_types::c_int,
    >,
    pub get_policy: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, addr: c_types::c_ulong) -> *mut mempolicy,
    >,
    pub find_special_page: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, addr: c_types::c_ulong) -> *mut page,
    >,
}
#[test]
fn bindgen_test_layout_vm_operations_struct() {
    assert_eq!(
        ::core::mem::size_of::<vm_operations_struct>(),
        112usize,
        concat!("Size of: ", stringify!(vm_operations_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_operations_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_operations_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).close as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).split as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(split)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).mremap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(mremap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).fault as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(fault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).huge_fault as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(huge_fault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).map_pages as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(map_pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).page_mkwrite as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(page_mkwrite)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).pfn_mkwrite as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(pfn_mkwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).access as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).set_policy as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(set_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).get_policy as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(get_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).find_special_page as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(find_special_page)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scatterlist {
    pub page_link: c_types::c_ulong,
    pub offset: c_types::c_uint,
    pub length: c_types::c_uint,
    pub dma_address: dma_addr_t,
    pub dma_length: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_scatterlist() {
    assert_eq!(
        ::core::mem::size_of::<scatterlist>(),
        32usize,
        concat!("Size of: ", stringify!(scatterlist))
    );
    assert_eq!(
        ::core::mem::align_of::<scatterlist>(),
        8usize,
        concat!("Alignment of ", stringify!(scatterlist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).page_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(page_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).dma_address as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(dma_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).dma_length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(dma_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_table {
    pub sgl: *mut scatterlist,
    pub nents: c_types::c_uint,
    pub orig_nents: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_sg_table() {
    assert_eq!(
        ::core::mem::size_of::<sg_table>(),
        16usize,
        concat!("Size of: ", stringify!(sg_table))
    );
    assert_eq!(
        ::core::mem::align_of::<sg_table>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_table>())).sgl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_table),
            "::",
            stringify!(sgl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_table>())).nents as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_table),
            "::",
            stringify!(nents)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_table>())).orig_nents as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_table),
            "::",
            stringify!(orig_nents)
        )
    );
}
impl Default for sg_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const dma_data_direction_DMA_BIDIRECTIONAL: dma_data_direction = 0;
pub const dma_data_direction_DMA_TO_DEVICE: dma_data_direction = 1;
pub const dma_data_direction_DMA_FROM_DEVICE: dma_data_direction = 2;
pub const dma_data_direction_DMA_NONE: dma_data_direction = 3;
pub type dma_data_direction = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dma_map_ops {
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            size: usize,
            dma_handle: *mut dma_addr_t,
            gfp: gfp_t,
            attrs: c_types::c_ulong,
        ) -> *mut c_types::c_void,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            size: usize,
            vaddr: *mut c_types::c_void,
            dma_handle: dma_addr_t,
            attrs: c_types::c_ulong,
        ),
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut vm_area_struct,
            arg3: *mut c_types::c_void,
            arg4: dma_addr_t,
            arg5: usize,
            attrs: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub get_sgtable: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sgt: *mut sg_table,
            arg1: *mut c_types::c_void,
            arg2: dma_addr_t,
            arg3: usize,
            attrs: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub map_page: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            page: *mut page,
            offset: c_types::c_ulong,
            size: usize,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ) -> dma_addr_t,
    >,
    pub unmap_page: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            dma_handle: dma_addr_t,
            size: usize,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ),
    >,
    pub map_sg: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sg: *mut scatterlist,
            nents: c_types::c_int,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub unmap_sg: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sg: *mut scatterlist,
            nents: c_types::c_int,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ),
    >,
    pub map_resource: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            phys_addr: phys_addr_t,
            size: usize,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ) -> dma_addr_t,
    >,
    pub unmap_resource: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            dma_handle: dma_addr_t,
            size: usize,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ),
    >,
    pub sync_single_for_cpu: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            dma_handle: dma_addr_t,
            size: usize,
            dir: dma_data_direction,
        ),
    >,
    pub sync_single_for_device: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            dma_handle: dma_addr_t,
            size: usize,
            dir: dma_data_direction,
        ),
    >,
    pub sync_sg_for_cpu: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sg: *mut scatterlist,
            nents: c_types::c_int,
            dir: dma_data_direction,
        ),
    >,
    pub sync_sg_for_device: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sg: *mut scatterlist,
            nents: c_types::c_int,
            dir: dma_data_direction,
        ),
    >,
    pub cache_sync: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            vaddr: *mut c_types::c_void,
            size: usize,
            direction: dma_data_direction,
        ),
    >,
    pub mapping_error: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, dma_addr: dma_addr_t) -> c_types::c_int,
    >,
    pub dma_supported:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device, mask: u64) -> c_types::c_int>,
    pub is_phys: c_types::c_int,
}
#[test]
fn bindgen_test_layout_dma_map_ops() {
    assert_eq!(
        ::core::mem::size_of::<dma_map_ops>(),
        144usize,
        concat!("Size of: ", stringify!(dma_map_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<dma_map_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(dma_map_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).mmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).get_sgtable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(get_sgtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).map_page as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(map_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).unmap_page as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(unmap_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).map_sg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(map_sg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).unmap_sg as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(unmap_sg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).map_resource as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(map_resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).unmap_resource as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(unmap_resource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dma_map_ops>())).sync_single_for_cpu as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(sync_single_for_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dma_map_ops>())).sync_single_for_device as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(sync_single_for_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).sync_sg_for_cpu as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(sync_sg_for_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).sync_sg_for_device as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(sync_sg_for_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).cache_sync as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(cache_sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).mapping_error as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(mapping_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).dma_supported as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(dma_supported)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).is_phys as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(is_phys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct disk_stats {
    pub sectors: [c_types::c_ulong; 2usize],
    pub ios: [c_types::c_ulong; 2usize],
    pub merges: [c_types::c_ulong; 2usize],
    pub ticks: [c_types::c_ulong; 2usize],
    pub io_ticks: c_types::c_ulong,
    pub time_in_queue: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_disk_stats() {
    assert_eq!(
        ::core::mem::size_of::<disk_stats>(),
        80usize,
        concat!("Size of: ", stringify!(disk_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<disk_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(disk_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).sectors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).ios as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(ios)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).merges as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(merges)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).ticks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(ticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).io_ticks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(io_ticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).time_in_queue as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(time_in_queue)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct partition_meta_info {
    pub uuid: [c_types::c_char; 37usize],
    pub volname: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_partition_meta_info() {
    assert_eq!(
        ::core::mem::size_of::<partition_meta_info>(),
        101usize,
        concat!("Size of: ", stringify!(partition_meta_info))
    );
    assert_eq!(
        ::core::mem::align_of::<partition_meta_info>(),
        1usize,
        concat!("Alignment of ", stringify!(partition_meta_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<partition_meta_info>())).uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(partition_meta_info),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<partition_meta_info>())).volname as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(partition_meta_info),
            "::",
            stringify!(volname)
        )
    );
}
impl Default for partition_meta_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hd_struct {
    pub start_sect: sector_t,
    pub nr_sects: sector_t,
    pub nr_sects_seq: seqcount_t,
    pub alignment_offset: sector_t,
    pub discard_alignment: c_types::c_uint,
    pub __dev: device,
    pub holder_dir: *mut kobject,
    pub policy: c_types::c_int,
    pub partno: c_types::c_int,
    pub info: *mut partition_meta_info,
    pub stamp: c_types::c_ulong,
    pub in_flight: [atomic_t; 2usize],
    pub dkstats: *mut disk_stats,
    pub ref_: percpu_ref,
    pub rcu_work: rcu_work,
}
#[test]
fn bindgen_test_layout_hd_struct() {
    assert_eq!(
        ::core::mem::size_of::<hd_struct>(),
        928usize,
        concat!("Size of: ", stringify!(hd_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<hd_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(hd_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).start_sect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(start_sect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).nr_sects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(nr_sects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).nr_sects_seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(nr_sects_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).alignment_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(alignment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).discard_alignment as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(discard_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).__dev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(__dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).holder_dir as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(holder_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).policy as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).partno as *const _ as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(partno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).info as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).stamp as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).in_flight as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(in_flight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).dkstats as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(dkstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).ref_ as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).rcu_work as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(rcu_work)
        )
    );
}
impl Default for hd_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct disk_part_tbl {
    pub callback_head: callback_head,
    pub len: c_types::c_int,
    pub last_lookup: *mut hd_struct,
    pub part: __IncompleteArrayField<*mut hd_struct>,
}
#[test]
fn bindgen_test_layout_disk_part_tbl() {
    assert_eq!(
        ::core::mem::size_of::<disk_part_tbl>(),
        32usize,
        concat!("Size of: ", stringify!(disk_part_tbl))
    );
    assert_eq!(
        ::core::mem::align_of::<disk_part_tbl>(),
        8usize,
        concat!("Alignment of ", stringify!(disk_part_tbl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_part_tbl>())).callback_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_part_tbl),
            "::",
            stringify!(callback_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_part_tbl>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_part_tbl),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_part_tbl>())).last_lookup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_part_tbl),
            "::",
            stringify!(last_lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_part_tbl>())).part as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_part_tbl),
            "::",
            stringify!(part)
        )
    );
}
impl Default for disk_part_tbl {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct disk_events {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct badblocks {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity {
    pub profile: *const blk_integrity_profile,
    pub flags: c_types::c_uchar,
    pub tuple_size: c_types::c_uchar,
    pub interval_exp: c_types::c_uchar,
    pub tag_size: c_types::c_uchar,
}
#[test]
fn bindgen_test_layout_blk_integrity() {
    assert_eq!(
        ::core::mem::size_of::<blk_integrity>(),
        16usize,
        concat!("Size of: ", stringify!(blk_integrity))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_integrity>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_integrity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).tuple_size as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(tuple_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).interval_exp as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(interval_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).tag_size as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(tag_size)
        )
    );
}
impl Default for blk_integrity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gendisk {
    pub major: c_types::c_int,
    pub first_minor: c_types::c_int,
    pub minors: c_types::c_int,
    pub disk_name: [c_types::c_char; 32usize],
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(gd: *mut gendisk, mode: *mut umode_t) -> *mut c_types::c_char,
    >,
    pub events: c_types::c_uint,
    pub async_events: c_types::c_uint,
    pub part_tbl: *mut disk_part_tbl,
    pub part0: hd_struct,
    pub fops: *const block_device_operations,
    pub queue: *mut request_queue,
    pub private_data: *mut c_types::c_void,
    pub flags: c_types::c_int,
    pub slave_dir: *mut kobject,
    pub random: *mut timer_rand_state,
    pub sync_io: atomic_t,
    pub ev: *mut disk_events,
    pub integrity_kobj: kobject,
    pub node_id: c_types::c_int,
    pub bb: *mut badblocks,
    pub lockdep_map: lockdep_map,
}
#[test]
fn bindgen_test_layout_gendisk() {
    assert_eq!(
        ::core::mem::size_of::<gendisk>(),
        1144usize,
        concat!("Size of: ", stringify!(gendisk))
    );
    assert_eq!(
        ::core::mem::align_of::<gendisk>(),
        8usize,
        concat!("Alignment of ", stringify!(gendisk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).first_minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(first_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).minors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(minors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).disk_name as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(disk_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).devnode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(devnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).events as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).async_events as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(async_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).part_tbl as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(part_tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).part0 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(part0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).fops as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(fops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).queue as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).private_data as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).flags as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).slave_dir as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(slave_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).random as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(random)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).sync_io as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(sync_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).ev as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(ev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).integrity_kobj as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(integrity_kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).node_id as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).bb as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(bb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).lockdep_map as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(lockdep_map)
        )
    );
}
impl Default for gendisk {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_percpu {
    pub events: percpu_counter,
    pub period: c_types::c_uint,
    pub lock: raw_spinlock_t,
}
#[test]
fn bindgen_test_layout_fprop_local_percpu() {
    assert_eq!(
        ::core::mem::size_of::<fprop_local_percpu>(),
        48usize,
        concat!("Size of: ", stringify!(fprop_local_percpu))
    );
    assert_eq!(
        ::core::mem::align_of::<fprop_local_percpu>(),
        8usize,
        concat!("Alignment of ", stringify!(fprop_local_percpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_local_percpu),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_local_percpu),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).lock as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_local_percpu),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for fprop_local_percpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type congested_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut c_types::c_void, arg2: c_types::c_int) -> c_types::c_int,
>;
pub const wb_reason_WB_REASON_BACKGROUND: wb_reason = 0;
pub const wb_reason_WB_REASON_VMSCAN: wb_reason = 1;
pub const wb_reason_WB_REASON_SYNC: wb_reason = 2;
pub const wb_reason_WB_REASON_PERIODIC: wb_reason = 3;
pub const wb_reason_WB_REASON_LAPTOP_TIMER: wb_reason = 4;
pub const wb_reason_WB_REASON_FREE_MORE_MEM: wb_reason = 5;
pub const wb_reason_WB_REASON_FS_FREE_SPACE: wb_reason = 6;
pub const wb_reason_WB_REASON_FORKER_THREAD: wb_reason = 7;
pub const wb_reason_WB_REASON_MAX: wb_reason = 8;
pub type wb_reason = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bdi_writeback_congested {
    pub state: c_types::c_ulong,
    pub refcnt: atomic_t,
    pub __bdi: *mut backing_dev_info,
    pub blkcg_id: c_types::c_int,
    pub rb_node: rb_node,
}
#[test]
fn bindgen_test_layout_bdi_writeback_congested() {
    assert_eq!(
        ::core::mem::size_of::<bdi_writeback_congested>(),
        56usize,
        concat!("Size of: ", stringify!(bdi_writeback_congested))
    );
    assert_eq!(
        ::core::mem::align_of::<bdi_writeback_congested>(),
        8usize,
        concat!("Alignment of ", stringify!(bdi_writeback_congested))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback_congested>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback_congested>())).refcnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback_congested>())).__bdi as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(__bdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback_congested>())).blkcg_id as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(blkcg_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback_congested>())).rb_node as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(rb_node)
        )
    );
}
impl Default for bdi_writeback_congested {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    pub bdi: *mut backing_dev_info,
    pub state: c_types::c_ulong,
    pub last_old_flush: c_types::c_ulong,
    pub b_dirty: list_head,
    pub b_io: list_head,
    pub b_more_io: list_head,
    pub b_dirty_time: list_head,
    pub list_lock: spinlock_t,
    pub stat: [percpu_counter; 4usize],
    pub congested: *mut bdi_writeback_congested,
    pub bw_time_stamp: c_types::c_ulong,
    pub dirtied_stamp: c_types::c_ulong,
    pub written_stamp: c_types::c_ulong,
    pub write_bandwidth: c_types::c_ulong,
    pub avg_write_bandwidth: c_types::c_ulong,
    pub dirty_ratelimit: c_types::c_ulong,
    pub balanced_dirty_ratelimit: c_types::c_ulong,
    pub completions: fprop_local_percpu,
    pub dirty_exceeded: c_types::c_int,
    pub start_all_reason: wb_reason,
    pub work_lock: spinlock_t,
    pub work_list: list_head,
    pub dwork: delayed_work,
    pub dirty_sleep: c_types::c_ulong,
    pub bdi_node: list_head,
    pub refcnt: percpu_ref,
    pub memcg_completions: fprop_local_percpu,
    pub memcg_css: *mut cgroup_subsys_state,
    pub blkcg_css: *mut cgroup_subsys_state,
    pub memcg_node: list_head,
    pub blkcg_node: list_head,
    pub __bindgen_anon_1: bdi_writeback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bdi_writeback__bindgen_ty_1 {
    pub release_work: work_struct,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_bdi_writeback__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bdi_writeback__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(bdi_writeback__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bdi_writeback__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bdi_writeback__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback__bindgen_ty_1>())).release_work as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback__bindgen_ty_1),
            "::",
            stringify!(release_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback__bindgen_ty_1>())).rcu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for bdi_writeback__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bdi_writeback() {
    assert_eq!(
        ::core::mem::size_of::<bdi_writeback>(),
        696usize,
        concat!("Size of: ", stringify!(bdi_writeback))
    );
    assert_eq!(
        ::core::mem::align_of::<bdi_writeback>(),
        8usize,
        concat!("Alignment of ", stringify!(bdi_writeback))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bdi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).last_old_flush as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(last_old_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_dirty as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(b_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_io as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(b_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_more_io as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(b_more_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_dirty_time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(b_dirty_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).list_lock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).stat as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).congested as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(congested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bw_time_stamp as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(bw_time_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirtied_stamp as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dirtied_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).written_stamp as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(written_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).write_bandwidth as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(write_bandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback>())).avg_write_bandwidth as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(avg_write_bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirty_ratelimit as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dirty_ratelimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback>())).balanced_dirty_ratelimit as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(balanced_dirty_ratelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).completions as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(completions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirty_exceeded as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dirty_exceeded)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).start_all_reason as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(start_all_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).work_lock as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(work_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).work_list as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(work_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dwork as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dwork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirty_sleep as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dirty_sleep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bdi_node as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(bdi_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).refcnt as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback>())).memcg_completions as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(memcg_completions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).memcg_css as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(memcg_css)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).blkcg_css as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(blkcg_css)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).memcg_node as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(memcg_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).blkcg_node as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(blkcg_node)
        )
    );
}
impl Default for bdi_writeback {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    pub bdi_list: list_head,
    pub ra_pages: c_types::c_ulong,
    pub io_pages: c_types::c_ulong,
    pub congested_fn: congested_fn,
    pub congested_data: *mut c_types::c_void,
    pub name: *const c_types::c_char,
    pub refcnt: kref,
    pub capabilities: c_types::c_uint,
    pub min_ratio: c_types::c_uint,
    pub max_ratio: c_types::c_uint,
    pub max_prop_frac: c_types::c_uint,
    pub tot_write_bandwidth: atomic_long_t,
    pub wb: bdi_writeback,
    pub wb_list: list_head,
    pub cgwb_tree: radix_tree_root,
    pub cgwb_congested_tree: rb_root,
    pub cgwb_release_mutex: mutex,
    pub wb_switch_rwsem: rw_semaphore,
    pub wb_waitq: wait_queue_head_t,
    pub dev: *mut device,
    pub owner: *mut device,
    pub laptop_mode_wb_timer: timer_list,
    pub debug_dir: *mut dentry,
    pub debug_stats: *mut dentry,
}
#[test]
fn bindgen_test_layout_backing_dev_info() {
    assert_eq!(
        ::core::mem::size_of::<backing_dev_info>(),
        992usize,
        concat!("Size of: ", stringify!(backing_dev_info))
    );
    assert_eq!(
        ::core::mem::align_of::<backing_dev_info>(),
        8usize,
        concat!("Alignment of ", stringify!(backing_dev_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).bdi_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(bdi_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).ra_pages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(ra_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).io_pages as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(io_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).congested_fn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(congested_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).congested_data as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(congested_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).refcnt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).capabilities as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).min_ratio as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(min_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).max_ratio as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(max_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).max_prop_frac as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(max_prop_frac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).tot_write_bandwidth as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(tot_write_bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(wb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb_list as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(wb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).cgwb_tree as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(cgwb_tree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).cgwb_congested_tree as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(cgwb_congested_tree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).cgwb_release_mutex as *const _ as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(cgwb_release_mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).wb_switch_rwsem as *const _ as usize
        },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(wb_switch_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb_waitq as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(wb_waitq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).dev as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).owner as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).laptop_mode_wb_timer as *const _ as usize
        },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(laptop_mode_wb_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).debug_dir as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(debug_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).debug_stats as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(debug_stats)
        )
    );
}
impl Default for backing_dev_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type mempool_alloc_t = ::core::option::Option<
    unsafe extern "C" fn(gfp_mask: gfp_t, pool_data: *mut c_types::c_void) -> *mut c_types::c_void,
>;
pub type mempool_free_t = ::core::option::Option<
    unsafe extern "C" fn(element: *mut c_types::c_void, pool_data: *mut c_types::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempool_s {
    pub lock: spinlock_t,
    pub min_nr: c_types::c_int,
    pub curr_nr: c_types::c_int,
    pub elements: *mut *mut c_types::c_void,
    pub pool_data: *mut c_types::c_void,
    pub alloc: mempool_alloc_t,
    pub free: mempool_free_t,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_mempool_s() {
    assert_eq!(
        ::core::mem::size_of::<mempool_s>(),
        72usize,
        concat!("Size of: ", stringify!(mempool_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mempool_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mempool_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).min_nr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(min_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).curr_nr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(curr_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).elements as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).pool_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).wait as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(wait)
        )
    );
}
impl Default for mempool_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type mempool_t = mempool_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_io_cq__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<io_cq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(io_cq__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_1>())).q_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_1),
            "::",
            stringify!(q_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<io_cq__bindgen_ty_1>())).__rcu_icq_cache as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_1),
            "::",
            stringify!(__rcu_icq_cache)
        )
    );
}
impl Default for io_cq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_io_cq__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<io_cq__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(io_cq__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_2>())).ioc_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_2),
            "::",
            stringify!(ioc_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_2>())).__rcu_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_2),
            "::",
            stringify!(__rcu_head)
        )
    );
}
impl Default for io_cq__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_io_cq() {
    assert_eq!(
        ::core::mem::size_of::<io_cq>(),
        56usize,
        concat!("Size of: ", stringify!(io_cq))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).q as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(io_cq), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).ioc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq),
            "::",
            stringify!(ioc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for io_cq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub nr_tasks: atomic_t,
    pub lock: spinlock_t,
    pub ioprio: c_types::c_ushort,
    pub nr_batch_requests: c_types::c_int,
    pub last_waited: c_types::c_ulong,
    pub icq_tree: radix_tree_root,
    pub icq_hint: *mut io_cq,
    pub icq_list: hlist_head,
    pub release_work: work_struct,
}
#[test]
fn bindgen_test_layout_io_context() {
    assert_eq!(
        ::core::mem::size_of::<io_context>(),
        104usize,
        concat!("Size of: ", stringify!(io_context))
    );
    assert_eq!(
        ::core::mem::align_of::<io_context>(),
        8usize,
        concat!("Alignment of ", stringify!(io_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).active_ref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(active_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).nr_tasks as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(nr_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).ioprio as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).nr_batch_requests as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(nr_batch_requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).last_waited as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(last_waited)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_tree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_hint as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_list as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).release_work as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(release_work)
        )
    );
}
impl Default for io_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: c_types::c_uint,
    pub bv_offset: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_bio_vec() {
    assert_eq!(
        ::core::mem::size_of::<bio_vec>(),
        16usize,
        concat!("Size of: ", stringify!(bio_vec))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_vec>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_vec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_vec),
            "::",
            stringify!(bv_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_vec),
            "::",
            stringify!(bv_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_vec),
            "::",
            stringify!(bv_offset)
        )
    );
}
impl Default for bio_vec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bvec_iter {
    pub bi_sector: sector_t,
    pub bi_size: c_types::c_uint,
    pub bi_idx: c_types::c_uint,
    pub bi_done: c_types::c_uint,
    pub bi_bvec_done: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_bvec_iter() {
    assert_eq!(
        ::core::mem::size_of::<bvec_iter>(),
        24usize,
        concat!("Size of: ", stringify!(bvec_iter))
    );
    assert_eq!(
        ::core::mem::align_of::<bvec_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(bvec_iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_sector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_idx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_done as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_bvec_done as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_bvec_done)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_subsys_state {
    _unused: [u8; 0],
}
pub type bio_end_io_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>;
pub type blk_status_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_issue_stat {
    pub stat: u64,
}
#[test]
fn bindgen_test_layout_blk_issue_stat() {
    assert_eq!(
        ::core::mem::size_of::<blk_issue_stat>(),
        8usize,
        concat!("Size of: ", stringify!(blk_issue_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_issue_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_issue_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_issue_stat>())).stat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_issue_stat),
            "::",
            stringify!(stat)
        )
    );
}
#[repr(C)]
pub struct bio {
    pub bi_next: *mut bio,
    pub bi_disk: *mut gendisk,
    pub bi_opf: c_types::c_uint,
    pub bi_flags: c_types::c_ushort,
    pub bi_ioprio: c_types::c_ushort,
    pub bi_write_hint: c_types::c_ushort,
    pub bi_status: blk_status_t,
    pub bi_partno: u8,
    pub bi_phys_segments: c_types::c_uint,
    pub bi_seg_front_size: c_types::c_uint,
    pub bi_seg_back_size: c_types::c_uint,
    pub bi_iter: bvec_iter,
    pub __bi_remaining: atomic_t,
    pub bi_end_io: bio_end_io_t,
    pub bi_private: *mut c_types::c_void,
    pub bi_ioc: *mut io_context,
    pub bi_css: *mut cgroup_subsys_state,
    pub __bindgen_anon_1: bio__bindgen_ty_1,
    pub bi_vcnt: c_types::c_ushort,
    pub bi_max_vecs: c_types::c_ushort,
    pub __bi_cnt: atomic_t,
    pub bi_io_vec: *mut bio_vec,
    pub bi_pool: *mut bio_set,
    pub bi_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bio__bindgen_ty_1 {
    pub bi_integrity: *mut bio_integrity_payload,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_bio__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bio__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(bio__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bio__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bio__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio__bindgen_ty_1>())).bi_integrity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio__bindgen_ty_1),
            "::",
            stringify!(bi_integrity)
        )
    );
}
impl Default for bio__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bio() {
    assert_eq!(
        ::core::mem::size_of::<bio>(),
        136usize,
        concat!("Size of: ", stringify!(bio))
    );
    assert_eq!(
        ::core::mem::align_of::<bio>(),
        8usize,
        concat!("Alignment of ", stringify!(bio))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_disk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_opf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_opf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_ioprio as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_write_hint as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_status as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_partno as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_partno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_phys_segments as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_phys_segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_seg_front_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_seg_front_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_seg_back_size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_seg_back_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_iter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).__bi_remaining as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(__bi_remaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_end_io as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_end_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_private as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_ioc as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_ioc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_css as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_css)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_vcnt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_vcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_max_vecs as *const _ as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_max_vecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).__bi_cnt as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(__bi_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_io_vec as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_io_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_pool as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_inline_vecs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_inline_vecs)
        )
    );
}
impl Default for bio {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type blk_qc_t = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_rq_stat {
    pub mean: u64,
    pub min: u64,
    pub max: u64,
    pub nr_samples: u32,
    pub batch: u64,
}
#[test]
fn bindgen_test_layout_blk_rq_stat() {
    assert_eq!(
        ::core::mem::size_of::<blk_rq_stat>(),
        40usize,
        concat!("Size of: ", stringify!(blk_rq_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_rq_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_rq_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).mean as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(mean)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).nr_samples as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(nr_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).batch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(batch)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct bio_integrity_payload {
    pub bip_bio: *mut bio,
    pub bip_iter: bvec_iter,
    pub bip_slab: c_types::c_ushort,
    pub bip_vcnt: c_types::c_ushort,
    pub bip_max_vcnt: c_types::c_ushort,
    pub bip_flags: c_types::c_ushort,
    pub bip_work: work_struct,
    pub bip_vec: *mut bio_vec,
    pub bip_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[test]
fn bindgen_test_layout_bio_integrity_payload() {
    assert_eq!(
        ::core::mem::size_of::<bio_integrity_payload>(),
        80usize,
        concat!("Size of: ", stringify!(bio_integrity_payload))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_integrity_payload>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_integrity_payload))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_bio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_bio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_iter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_slab as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_vcnt as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_vcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bio_integrity_payload>())).bip_max_vcnt as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_max_vcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bio_integrity_payload>())).bip_flags as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_work as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_vec as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bio_integrity_payload>())).bip_inline_vecs as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_inline_vecs)
        )
    );
}
impl Default for bio_integrity_payload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_list {
    pub head: *mut bio,
    pub tail: *mut bio,
}
#[test]
fn bindgen_test_layout_bio_list() {
    assert_eq!(
        ::core::mem::size_of::<bio_list>(),
        16usize,
        concat!("Size of: ", stringify!(bio_list))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_list>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_list>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_list),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_list>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_list),
            "::",
            stringify!(tail)
        )
    );
}
impl Default for bio_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_set {
    pub bio_slab: *mut kmem_cache,
    pub front_pad: c_types::c_uint,
    pub bio_pool: *mut mempool_t,
    pub bvec_pool: *mut mempool_t,
    pub bio_integrity_pool: *mut mempool_t,
    pub bvec_integrity_pool: *mut mempool_t,
    pub rescue_lock: spinlock_t,
    pub rescue_list: bio_list,
    pub rescue_work: work_struct,
    pub rescue_workqueue: *mut workqueue_struct,
}
#[test]
fn bindgen_test_layout_bio_set() {
    assert_eq!(
        ::core::mem::size_of::<bio_set>(),
        112usize,
        concat!("Size of: ", stringify!(bio_set))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_set>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bio_slab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bio_slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).front_pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(front_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bio_pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bio_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bvec_pool as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bvec_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bio_integrity_pool as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bio_integrity_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bvec_integrity_pool as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bvec_integrity_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(rescue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_list as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(rescue_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_work as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(rescue_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_workqueue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(rescue_workqueue)
        )
    );
}
impl Default for bio_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bsg_class_device {
    pub class_dev: *mut device,
    pub parent: *mut device,
    pub minor: c_types::c_int,
    pub queue: *mut request_queue,
    pub ref_: kref,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
}
#[test]
fn bindgen_test_layout_bsg_class_device() {
    assert_eq!(
        ::core::mem::size_of::<bsg_class_device>(),
        48usize,
        concat!("Size of: ", stringify!(bsg_class_device))
    );
    assert_eq!(
        ::core::mem::align_of::<bsg_class_device>(),
        8usize,
        concat!("Alignment of ", stringify!(bsg_class_device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).class_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(class_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).minor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).queue as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).ref_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).release as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(release)
        )
    );
}
impl Default for bsg_class_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_trace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bsg_job {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkcg_gq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_flush_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pr_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq_wb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_queue_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_stat_callback {
    _unused: [u8; 0],
}
pub type rq_end_io_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: blk_status_t)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_list {
    pub q: *mut request_queue,
    pub blkg: *mut blkcg_gq,
    pub count: [c_types::c_int; 2usize],
    pub starved: [c_types::c_int; 2usize],
    pub rq_pool: *mut mempool_t,
    pub wait: [wait_queue_head_t; 2usize],
    pub flags: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_request_list() {
    assert_eq!(
        ::core::mem::size_of::<request_list>(),
        96usize,
        concat!("Size of: ", stringify!(request_list))
    );
    assert_eq!(
        ::core::mem::align_of::<request_list>(),
        8usize,
        concat!("Alignment of ", stringify!(request_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_list>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request_list),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_list>())).blkg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request_list),
            "::",
            stringify!(blkg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_list>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(request_list),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_list>())).starved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request_list),
            "::",
            stringify!(starved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_list>())).rq_pool as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(request_list),
            "::",
            stringify!(rq_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_list>())).wait as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(request_list),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_list>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(request_list),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for request_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type req_flags_t = __u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request {
    pub queuelist: list_head,
    pub __bindgen_anon_1: request__bindgen_ty_1,
    pub q: *mut request_queue,
    pub mq_ctx: *mut blk_mq_ctx,
    pub cpu: c_types::c_int,
    pub cmd_flags: c_types::c_uint,
    pub rq_flags: req_flags_t,
    pub internal_tag: c_types::c_int,
    pub atomic_flags: c_types::c_ulong,
    pub __data_len: c_types::c_uint,
    pub tag: c_types::c_int,
    pub __sector: sector_t,
    pub bio: *mut bio,
    pub biotail: *mut bio,
    pub __bindgen_anon_2: request__bindgen_ty_2,
    pub __bindgen_anon_3: request__bindgen_ty_3,
    pub __bindgen_anon_4: request__bindgen_ty_4,
    pub rq_disk: *mut gendisk,
    pub part: *mut hd_struct,
    pub start_time: c_types::c_ulong,
    pub issue_stat: blk_issue_stat,
    pub rl: *mut request_list,
    pub start_time_ns: c_types::c_ulonglong,
    pub io_start_time_ns: c_types::c_ulonglong,
    pub nr_phys_segments: c_types::c_ushort,
    pub nr_integrity_segments: c_types::c_ushort,
    pub ioprio: c_types::c_ushort,
    pub timeout: c_types::c_uint,
    pub special: *mut c_types::c_void,
    pub extra_len: c_types::c_uint,
    pub write_hint: c_types::c_ushort,
    pub deadline: c_types::c_ulong,
    pub timeout_list: list_head,
    pub end_io: rq_end_io_fn,
    pub end_io_data: *mut c_types::c_void,
    pub next_rq: *mut request,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_1 {
    pub csd: __call_single_data,
    pub fifo_time: u64,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(request__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_1>())).csd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_1),
            "::",
            stringify!(csd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_1>())).fifo_time as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_1),
            "::",
            stringify!(fifo_time)
        )
    );
}
impl Default for request__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_2 {
    pub hash: hlist_node,
    pub ipi_list: list_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(request__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_2>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_2),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_2>())).ipi_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_2),
            "::",
            stringify!(ipi_list)
        )
    );
}
impl Default for request__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_3 {
    pub rb_node: rb_node,
    pub special_vec: bio_vec,
    pub completion_data: *mut c_types::c_void,
    pub error_count: c_types::c_int,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_3>(),
        24usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(request__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_3>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_3>())).special_vec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3),
            "::",
            stringify!(special_vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_3>())).completion_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3),
            "::",
            stringify!(completion_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_3>())).error_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3),
            "::",
            stringify!(error_count)
        )
    );
}
impl Default for request__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_4 {
    pub elv: request__bindgen_ty_4__bindgen_ty_1,
    pub flush: request__bindgen_ty_4__bindgen_ty_2,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request__bindgen_ty_4__bindgen_ty_1 {
    pub icq: *mut io_cq,
    pub priv_: [*mut c_types::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_4__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(request__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_4__bindgen_ty_1>())).icq as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(icq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_4__bindgen_ty_1>())).priv_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for request__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request__bindgen_ty_4__bindgen_ty_2 {
    pub seq: c_types::c_uint,
    pub list: list_head,
    pub saved_end_io: rq_end_io_fn,
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_4__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_4__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_4__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(request__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_4__bindgen_ty_2>())).seq as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_4__bindgen_ty_2>())).list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_4__bindgen_ty_2>())).saved_end_io
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(saved_end_io)
        )
    );
}
impl Default for request__bindgen_ty_4__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(request__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_4>())).elv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4),
            "::",
            stringify!(elv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_4>())).flush as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4),
            "::",
            stringify!(flush)
        )
    );
}
impl Default for request__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_request() {
    assert_eq!(
        ::core::mem::size_of::<request>(),
        328usize,
        concat!("Size of: ", stringify!(request))
    );
    assert_eq!(
        ::core::mem::align_of::<request>(),
        8usize,
        concat!("Alignment of ", stringify!(request))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).queuelist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(queuelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).q as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).mq_ctx as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(mq_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).cpu as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).cmd_flags as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(cmd_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).rq_flags as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(rq_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).internal_tag as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(internal_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).atomic_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(atomic_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).__data_len as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(__data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).tag as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).__sector as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(__sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).bio as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(bio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).biotail as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(biotail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).rq_disk as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(rq_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).part as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(part)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).start_time as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).issue_stat as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(issue_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).rl as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(rl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).start_time_ns as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(start_time_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).io_start_time_ns as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(io_start_time_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).nr_phys_segments as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(nr_phys_segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).nr_integrity_segments as *const _ as usize },
        250usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(nr_integrity_segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).ioprio as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).timeout as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).special as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(special)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).extra_len as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(extra_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).write_hint as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).deadline as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).timeout_list as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(timeout_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).end_io as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(end_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).end_io_data as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(end_io_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).next_rq as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(next_rq)
        )
    );
}
impl Default for request {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_debugfs_attr {
    _unused: [u8; 0],
}
pub const elv_merge_ELEVATOR_NO_MERGE: elv_merge = 0;
pub const elv_merge_ELEVATOR_FRONT_MERGE: elv_merge = 1;
pub const elv_merge_ELEVATOR_BACK_MERGE: elv_merge = 2;
pub const elv_merge_ELEVATOR_DISCARD_MERGE: elv_merge = 3;
pub type elv_merge = u32;
pub type elevator_merge_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut request_queue,
        arg2: *mut *mut request,
        arg3: *mut bio,
    ) -> elv_merge,
>;
pub type elevator_merge_req_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut request),
>;
pub type elevator_merged_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: elv_merge),
>;
pub type elevator_allow_bio_merge_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut request_queue,
        arg2: *mut request,
        arg3: *mut bio,
    ) -> c_types::c_int,
>;
pub type elevator_allow_rq_merge_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut request_queue,
        arg2: *mut request,
        arg3: *mut request,
    ) -> c_types::c_int,
>;
pub type elevator_bio_merged_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut bio),
>;
pub type elevator_dispatch_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request_queue, arg2: c_types::c_int) -> c_types::c_int,
>;
pub type elevator_add_req_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request)>;
pub type elevator_request_list_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
>;
pub type elevator_completed_req_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request)>;
pub type elevator_may_queue_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request_queue, arg2: c_types::c_uint) -> c_types::c_int,
>;
pub type elevator_init_icq_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>;
pub type elevator_exit_icq_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>;
pub type elevator_set_req_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut request_queue,
        arg2: *mut request,
        arg3: *mut bio,
        arg4: gfp_t,
    ) -> c_types::c_int,
>;
pub type elevator_put_req_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>;
pub type elevator_activate_req_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request)>;
pub type elevator_deactivate_req_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request)>;
pub type elevator_init_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request_queue, e: *mut elevator_type) -> c_types::c_int,
>;
pub type elevator_exit_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut elevator_queue)>;
pub type elevator_registered_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elevator_ops {
    pub elevator_merge_fn: elevator_merge_fn,
    pub elevator_merged_fn: elevator_merged_fn,
    pub elevator_merge_req_fn: elevator_merge_req_fn,
    pub elevator_allow_bio_merge_fn: elevator_allow_bio_merge_fn,
    pub elevator_allow_rq_merge_fn: elevator_allow_rq_merge_fn,
    pub elevator_bio_merged_fn: elevator_bio_merged_fn,
    pub elevator_dispatch_fn: elevator_dispatch_fn,
    pub elevator_add_req_fn: elevator_add_req_fn,
    pub elevator_activate_req_fn: elevator_activate_req_fn,
    pub elevator_deactivate_req_fn: elevator_deactivate_req_fn,
    pub elevator_completed_req_fn: elevator_completed_req_fn,
    pub elevator_former_req_fn: elevator_request_list_fn,
    pub elevator_latter_req_fn: elevator_request_list_fn,
    pub elevator_init_icq_fn: elevator_init_icq_fn,
    pub elevator_exit_icq_fn: elevator_exit_icq_fn,
    pub elevator_set_req_fn: elevator_set_req_fn,
    pub elevator_put_req_fn: elevator_put_req_fn,
    pub elevator_may_queue_fn: elevator_may_queue_fn,
    pub elevator_init_fn: elevator_init_fn,
    pub elevator_exit_fn: elevator_exit_fn,
    pub elevator_registered_fn: elevator_registered_fn,
}
#[test]
fn bindgen_test_layout_elevator_ops() {
    assert_eq!(
        ::core::mem::size_of::<elevator_ops>(),
        168usize,
        concat!("Size of: ", stringify!(elevator_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<elevator_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(elevator_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_ops>())).elevator_merge_fn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_merge_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_merged_fn as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_merged_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_merge_req_fn as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_merge_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_allow_bio_merge_fn as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_allow_bio_merge_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_allow_rq_merge_fn as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_allow_rq_merge_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_bio_merged_fn as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_bio_merged_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_dispatch_fn as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_dispatch_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_add_req_fn as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_add_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_activate_req_fn as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_activate_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_deactivate_req_fn as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_deactivate_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_completed_req_fn as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_completed_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_former_req_fn as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_former_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_latter_req_fn as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_latter_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_init_icq_fn as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_init_icq_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_exit_icq_fn as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_exit_icq_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_set_req_fn as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_set_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_put_req_fn as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_put_req_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_may_queue_fn as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_may_queue_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_ops>())).elevator_init_fn as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_init_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_ops>())).elevator_exit_fn as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_exit_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_ops>())).elevator_registered_fn as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_ops),
            "::",
            stringify!(elevator_registered_fn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_alloc_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elevator_mq_ops {
    pub init_sched: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut elevator_type) -> c_types::c_int,
    >,
    pub exit_sched: ::core::option::Option<unsafe extern "C" fn(arg1: *mut elevator_queue)>,
    pub init_hctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub exit_hctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: c_types::c_uint),
    >,
    pub allow_merge: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut bio) -> bool_,
    >,
    pub bio_merge: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: *mut bio) -> bool_,
    >,
    pub request_merge: ::core::option::Option<
        unsafe extern "C" fn(
            q: *mut request_queue,
            arg1: *mut *mut request,
            arg2: *mut bio,
        ) -> c_types::c_int,
    >,
    pub request_merged: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: elv_merge),
    >,
    pub requests_merged: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut request),
    >,
    pub limit_depth: ::core::option::Option<
        unsafe extern "C" fn(arg1: c_types::c_uint, arg2: *mut blk_mq_alloc_data),
    >,
    pub prepare_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, bio: *mut bio)>,
    pub finish_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub insert_requests: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: *mut list_head, arg3: bool_),
    >,
    pub dispatch_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> *mut request>,
    pub has_work: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> bool_>,
    pub completed_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub started_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub requeue_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub former_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
    >,
    pub next_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
    >,
    pub init_icq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>,
    pub exit_icq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>,
}
#[test]
fn bindgen_test_layout_elevator_mq_ops() {
    assert_eq!(
        ::core::mem::size_of::<elevator_mq_ops>(),
        176usize,
        concat!("Size of: ", stringify!(elevator_mq_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<elevator_mq_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(elevator_mq_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).init_sched as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(init_sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).exit_sched as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(exit_sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).init_hctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(init_hctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).exit_hctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(exit_hctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).allow_merge as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(allow_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).bio_merge as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(bio_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).request_merge as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(request_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).request_merged as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(request_merged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).requests_merged as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(requests_merged)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).limit_depth as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(limit_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).prepare_request as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(prepare_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).finish_request as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(finish_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).insert_requests as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(insert_requests)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).dispatch_request as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(dispatch_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).has_work as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(has_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).completed_request as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(completed_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).started_request as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(started_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).requeue_request as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(requeue_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).former_request as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(former_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).next_request as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(next_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).init_icq as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(init_icq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).exit_icq as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(exit_icq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elv_fs_entry {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut elevator_queue, arg2: *mut c_types::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut elevator_queue,
            arg2: *const c_types::c_char,
            arg3: usize,
        ) -> isize,
    >,
}
#[test]
fn bindgen_test_layout_elv_fs_entry() {
    assert_eq!(
        ::core::mem::size_of::<elv_fs_entry>(),
        32usize,
        concat!("Size of: ", stringify!(elv_fs_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<elv_fs_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(elv_fs_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elv_fs_entry>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elv_fs_entry),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elv_fs_entry>())).show as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elv_fs_entry),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elv_fs_entry>())).store as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elv_fs_entry),
            "::",
            stringify!(store)
        )
    );
}
impl Default for elv_fs_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elevator_type {
    pub icq_cache: *mut kmem_cache,
    pub ops: elevator_type__bindgen_ty_1,
    pub icq_size: usize,
    pub icq_align: usize,
    pub elevator_attrs: *mut elv_fs_entry,
    pub elevator_name: [c_types::c_char; 16usize],
    pub elevator_alias: *const c_types::c_char,
    pub elevator_owner: *mut module,
    pub uses_mq: bool_,
    pub queue_debugfs_attrs: *const blk_mq_debugfs_attr,
    pub hctx_debugfs_attrs: *const blk_mq_debugfs_attr,
    pub icq_cache_name: [c_types::c_char; 22usize],
    pub list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union elevator_type__bindgen_ty_1 {
    pub sq: elevator_ops,
    pub mq: elevator_mq_ops,
    _bindgen_union_align: [u64; 22usize],
}
#[test]
fn bindgen_test_layout_elevator_type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<elevator_type__bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(elevator_type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<elevator_type__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(elevator_type__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type__bindgen_ty_1>())).sq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type__bindgen_ty_1),
            "::",
            stringify!(sq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type__bindgen_ty_1>())).mq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type__bindgen_ty_1),
            "::",
            stringify!(mq)
        )
    );
}
impl Default for elevator_type__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_elevator_type() {
    assert_eq!(
        ::core::mem::size_of::<elevator_type>(),
        304usize,
        concat!("Size of: ", stringify!(elevator_type))
    );
    assert_eq!(
        ::core::mem::align_of::<elevator_type>(),
        8usize,
        concat!("Alignment of ", stringify!(elevator_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).icq_cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(icq_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).icq_size as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(icq_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).icq_align as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(icq_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).elevator_attrs as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).elevator_name as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).elevator_alias as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).elevator_owner as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).uses_mq as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(uses_mq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_type>())).queue_debugfs_attrs as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(queue_debugfs_attrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_type>())).hctx_debugfs_attrs as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(hctx_debugfs_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).icq_cache_name as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(icq_cache_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).list as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(list)
        )
    );
}
impl Default for elevator_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elevator_queue {
    pub type_: *mut elevator_type,
    pub elevator_data: *mut c_types::c_void,
    pub kobj: kobject,
    pub sysfs_lock: mutex,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub hash: [hlist_head; 64usize],
}
#[test]
fn bindgen_test_layout_elevator_queue() {
    assert_eq!(
        ::core::mem::size_of::<elevator_queue>(),
        632usize,
        concat!("Size of: ", stringify!(elevator_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<elevator_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(elevator_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).elevator_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(elevator_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).kobj as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).sysfs_lock as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(sysfs_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).hash as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for elevator_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl elevator_queue {
    #[inline]
    pub fn registered(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_registered(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uses_mq(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uses_mq(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        registered: c_types::c_uint,
        uses_mq: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let registered: u32 = unsafe { ::core::mem::transmute(registered) };
            registered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let uses_mq: u32 = unsafe { ::core::mem::transmute(uses_mq) };
            uses_mq as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type request_fn_proc = ::core::option::Option<unsafe extern "C" fn(q: *mut request_queue)>;
pub type make_request_fn =
    ::core::option::Option<unsafe extern "C" fn(q: *mut request_queue, bio: *mut bio) -> blk_qc_t>;
pub type poll_q_fn =
    ::core::option::Option<unsafe extern "C" fn(q: *mut request_queue, arg1: blk_qc_t) -> bool_>;
pub type prep_rq_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> c_types::c_int,
>;
pub type unprep_rq_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request)>;
pub type softirq_done_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>;
pub type dma_drain_needed_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request) -> c_types::c_int>;
pub type lld_busy_fn =
    ::core::option::Option<unsafe extern "C" fn(q: *mut request_queue) -> c_types::c_int>;
pub type bsg_job_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut bsg_job) -> c_types::c_int>;
pub type init_rq_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut request_queue,
        arg2: *mut request,
        arg3: gfp_t,
    ) -> c_types::c_int,
>;
pub type exit_rq_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request)>;
pub const blk_eh_timer_return_BLK_EH_NOT_HANDLED: blk_eh_timer_return = 0;
pub const blk_eh_timer_return_BLK_EH_HANDLED: blk_eh_timer_return = 1;
pub const blk_eh_timer_return_BLK_EH_RESET_TIMER: blk_eh_timer_return = 2;
pub type blk_eh_timer_return = u32;
pub type rq_timed_out_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request) -> blk_eh_timer_return>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_queue_tag {
    pub tag_index: *mut *mut request,
    pub tag_map: *mut c_types::c_ulong,
    pub max_depth: c_types::c_int,
    pub real_max_depth: c_types::c_int,
    pub refcnt: atomic_t,
    pub alloc_policy: c_types::c_int,
    pub next_tag: c_types::c_int,
}
#[test]
fn bindgen_test_layout_blk_queue_tag() {
    assert_eq!(
        ::core::mem::size_of::<blk_queue_tag>(),
        40usize,
        concat!("Size of: ", stringify!(blk_queue_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_queue_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_queue_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_queue_tag>())).tag_index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_queue_tag),
            "::",
            stringify!(tag_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_queue_tag>())).tag_map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_queue_tag),
            "::",
            stringify!(tag_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_queue_tag>())).max_depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_queue_tag),
            "::",
            stringify!(max_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_queue_tag>())).real_max_depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_queue_tag),
            "::",
            stringify!(real_max_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_queue_tag>())).refcnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_queue_tag),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_queue_tag>())).alloc_policy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_queue_tag),
            "::",
            stringify!(alloc_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_queue_tag>())).next_tag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_queue_tag),
            "::",
            stringify!(next_tag)
        )
    );
}
impl Default for blk_queue_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const blk_zoned_model_BLK_ZONED_NONE: blk_zoned_model = 0;
pub const blk_zoned_model_BLK_ZONED_HA: blk_zoned_model = 1;
pub const blk_zoned_model_BLK_ZONED_HM: blk_zoned_model = 2;
pub type blk_zoned_model = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct queue_limits {
    pub bounce_pfn: c_types::c_ulong,
    pub seg_boundary_mask: c_types::c_ulong,
    pub virt_boundary_mask: c_types::c_ulong,
    pub max_hw_sectors: c_types::c_uint,
    pub max_dev_sectors: c_types::c_uint,
    pub chunk_sectors: c_types::c_uint,
    pub max_sectors: c_types::c_uint,
    pub max_segment_size: c_types::c_uint,
    pub physical_block_size: c_types::c_uint,
    pub logical_block_size: c_types::c_uint,
    pub alignment_offset: c_types::c_uint,
    pub io_min: c_types::c_uint,
    pub io_opt: c_types::c_uint,
    pub max_discard_sectors: c_types::c_uint,
    pub max_hw_discard_sectors: c_types::c_uint,
    pub max_write_same_sectors: c_types::c_uint,
    pub max_write_zeroes_sectors: c_types::c_uint,
    pub discard_granularity: c_types::c_uint,
    pub discard_alignment: c_types::c_uint,
    pub max_segments: c_types::c_ushort,
    pub max_integrity_segments: c_types::c_ushort,
    pub max_discard_segments: c_types::c_ushort,
    pub misaligned: c_types::c_uchar,
    pub discard_misaligned: c_types::c_uchar,
    pub cluster: c_types::c_uchar,
    pub raid_partial_stripes_expensive: c_types::c_uchar,
    pub zoned: blk_zoned_model,
}
#[test]
fn bindgen_test_layout_queue_limits() {
    assert_eq!(
        ::core::mem::size_of::<queue_limits>(),
        104usize,
        concat!("Size of: ", stringify!(queue_limits))
    );
    assert_eq!(
        ::core::mem::align_of::<queue_limits>(),
        8usize,
        concat!("Alignment of ", stringify!(queue_limits))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).bounce_pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(bounce_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).seg_boundary_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(seg_boundary_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).virt_boundary_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(virt_boundary_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_hw_sectors as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_hw_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_dev_sectors as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_dev_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).chunk_sectors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(chunk_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_sectors as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_segment_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_segment_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).physical_block_size as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(physical_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).logical_block_size as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(logical_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).alignment_offset as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(alignment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).io_min as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(io_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).io_opt as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(io_opt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_discard_sectors as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_discard_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_hw_discard_sectors as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_hw_discard_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_write_same_sectors as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_write_same_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_write_zeroes_sectors as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_write_zeroes_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).discard_granularity as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(discard_granularity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).discard_alignment as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(discard_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_segments as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_segments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_integrity_segments as *const _ as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_integrity_segments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_discard_segments as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_discard_segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).misaligned as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(misaligned)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).discard_misaligned as *const _ as usize
        },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(discard_misaligned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).cluster as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(cluster)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).raid_partial_stripes_expensive as *const _
                as usize
        },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(raid_partial_stripes_expensive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).zoned as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(zoned)
        )
    );
}
impl Default for queue_limits {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_queue {
    pub queue_head: list_head,
    pub last_merge: *mut request,
    pub elevator: *mut elevator_queue,
    pub nr_rqs: [c_types::c_int; 2usize],
    pub nr_rqs_elvpriv: c_types::c_int,
    pub shared_hctx_restart: atomic_t,
    pub stats: *mut blk_queue_stats,
    pub rq_wb: *mut rq_wb,
    pub root_rl: request_list,
    pub request_fn: request_fn_proc,
    pub make_request_fn: make_request_fn,
    pub poll_fn: poll_q_fn,
    pub prep_rq_fn: prep_rq_fn,
    pub unprep_rq_fn: unprep_rq_fn,
    pub softirq_done_fn: softirq_done_fn,
    pub rq_timed_out_fn: rq_timed_out_fn,
    pub dma_drain_needed: dma_drain_needed_fn,
    pub lld_busy_fn: lld_busy_fn,
    pub init_rq_fn: init_rq_fn,
    pub exit_rq_fn: exit_rq_fn,
    pub initialize_rq_fn: ::core::option::Option<unsafe extern "C" fn(rq: *mut request)>,
    pub mq_ops: *const blk_mq_ops,
    pub mq_map: *mut c_types::c_uint,
    pub queue_ctx: *mut blk_mq_ctx,
    pub nr_queues: c_types::c_uint,
    pub queue_depth: c_types::c_uint,
    pub queue_hw_ctx: *mut *mut blk_mq_hw_ctx,
    pub nr_hw_queues: c_types::c_uint,
    pub end_sector: sector_t,
    pub boundary_rq: *mut request,
    pub delay_work: delayed_work,
    pub backing_dev_info: *mut backing_dev_info,
    pub queuedata: *mut c_types::c_void,
    pub queue_flags: c_types::c_ulong,
    pub id: c_types::c_int,
    pub bounce_gfp: gfp_t,
    pub __queue_lock: spinlock_t,
    pub queue_lock: *mut spinlock_t,
    pub kobj: kobject,
    pub mq_kobj: kobject,
    pub integrity: blk_integrity,
    pub dev: *mut device,
    pub rpm_status: c_types::c_int,
    pub nr_pending: c_types::c_uint,
    pub nr_requests: c_types::c_ulong,
    pub nr_congestion_on: c_types::c_uint,
    pub nr_congestion_off: c_types::c_uint,
    pub nr_batching: c_types::c_uint,
    pub dma_drain_size: c_types::c_uint,
    pub dma_drain_buffer: *mut c_types::c_void,
    pub dma_pad_mask: c_types::c_uint,
    pub dma_alignment: c_types::c_uint,
    pub queue_tags: *mut blk_queue_tag,
    pub tag_busy_list: list_head,
    pub nr_sorted: c_types::c_uint,
    pub in_flight: [c_types::c_uint; 2usize],
    pub request_fn_active: c_types::c_uint,
    pub rq_timeout: c_types::c_uint,
    pub poll_nsec: c_types::c_int,
    pub poll_cb: *mut blk_stat_callback,
    pub poll_stat: [blk_rq_stat; 16usize],
    pub timeout: timer_list,
    pub timeout_work: work_struct,
    pub timeout_list: list_head,
    pub icq_list: list_head,
    pub blkcg_pols: [c_types::c_ulong; 1usize],
    pub root_blkg: *mut blkcg_gq,
    pub blkg_list: list_head,
    pub limits: queue_limits,
    pub sg_timeout: c_types::c_uint,
    pub sg_reserved_size: c_types::c_uint,
    pub node: c_types::c_int,
    pub blk_trace: *mut blk_trace,
    pub blk_trace_mutex: mutex,
    pub fq: *mut blk_flush_queue,
    pub requeue_list: list_head,
    pub requeue_lock: spinlock_t,
    pub requeue_work: delayed_work,
    pub sysfs_lock: mutex,
    pub bypass_depth: c_types::c_int,
    pub mq_freeze_depth: atomic_t,
    pub bsg_job_fn: bsg_job_fn,
    pub bsg_dev: bsg_class_device,
    pub td: *mut throtl_data,
    pub callback_head: callback_head,
    pub mq_freeze_wq: wait_queue_head_t,
    pub q_usage_counter: percpu_ref,
    pub all_q_node: list_head,
    pub tag_set: *mut blk_mq_tag_set,
    pub tag_set_list: list_head,
    pub bio_split: *mut bio_set,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub mq_sysfs_init_done: bool_,
    pub cmd_size: usize,
    pub rq_alloc_data: *mut c_types::c_void,
    pub release_work: work_struct,
    pub write_hints: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_request_queue() {
    assert_eq!(
        ::core::mem::size_of::<request_queue>(),
        2128usize,
        concat!("Size of: ", stringify!(request_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<request_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(request_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).last_merge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(last_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).elevator as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(elevator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_rqs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_rqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_rqs_elvpriv as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_rqs_elvpriv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_queue>())).shared_hctx_restart as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(shared_hctx_restart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).stats as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rq_wb as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rq_wb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).root_rl as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(root_rl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).request_fn as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(request_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).make_request_fn as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(make_request_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).poll_fn as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(poll_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).prep_rq_fn as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(prep_rq_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).unprep_rq_fn as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(unprep_rq_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).softirq_done_fn as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(softirq_done_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rq_timed_out_fn as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rq_timed_out_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_drain_needed as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_drain_needed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).lld_busy_fn as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(lld_busy_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).init_rq_fn as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(init_rq_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).exit_rq_fn as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(exit_rq_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).initialize_rq_fn as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(initialize_rq_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_ops as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_map as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_ctx as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_queues as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_depth as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_hw_ctx as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_hw_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_hw_queues as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_hw_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).end_sector as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(end_sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).boundary_rq as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(boundary_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).delay_work as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(delay_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).backing_dev_info as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(backing_dev_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queuedata as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queuedata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_flags as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).id as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).bounce_gfp as *const _ as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(bounce_gfp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).__queue_lock as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(__queue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_lock as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).kobj as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_kobj as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).integrity as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(integrity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dev as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rpm_status as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rpm_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_pending as *const _ as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_requests as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_congestion_on as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_congestion_on)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_queue>())).nr_congestion_off as *const _ as usize
        },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_congestion_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_batching as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_batching)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_drain_size as *const _ as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_drain_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_drain_buffer as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_drain_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_pad_mask as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_pad_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_alignment as *const _ as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_tags as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).tag_busy_list as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(tag_busy_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_sorted as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_sorted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).in_flight as *const _ as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(in_flight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_queue>())).request_fn_active as *const _ as usize
        },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(request_fn_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rq_timeout as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rq_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).poll_nsec as *const _ as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(poll_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).poll_cb as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(poll_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).poll_stat as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(poll_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).timeout as *const _ as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).timeout_work as *const _ as usize },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(timeout_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).timeout_list as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(timeout_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).icq_list as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(icq_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).blkcg_pols as *const _ as usize },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(blkcg_pols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).root_blkg as *const _ as usize },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(root_blkg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).blkg_list as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(blkg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).limits as *const _ as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).sg_timeout as *const _ as usize },
        1592usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sg_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).sg_reserved_size as *const _ as usize },
        1596usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sg_reserved_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).node as *const _ as usize },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).blk_trace as *const _ as usize },
        1608usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(blk_trace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).blk_trace_mutex as *const _ as usize },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(blk_trace_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).fq as *const _ as usize },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(fq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).requeue_list as *const _ as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(requeue_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).requeue_lock as *const _ as usize },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(requeue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).requeue_work as *const _ as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(requeue_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).sysfs_lock as *const _ as usize },
        1768usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sysfs_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).bypass_depth as *const _ as usize },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(bypass_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_freeze_depth as *const _ as usize },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_freeze_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).bsg_job_fn as *const _ as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(bsg_job_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).bsg_dev as *const _ as usize },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(bsg_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).td as *const _ as usize },
        1864usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(td)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).callback_head as *const _ as usize },
        1872usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(callback_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_freeze_wq as *const _ as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_freeze_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).q_usage_counter as *const _ as usize },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(q_usage_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).all_q_node as *const _ as usize },
        1968usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(all_q_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).tag_set as *const _ as usize },
        1984usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(tag_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).tag_set_list as *const _ as usize },
        1992usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(tag_set_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).bio_split as *const _ as usize },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(bio_split)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).debugfs_dir as *const _ as usize },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(debugfs_dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_queue>())).sched_debugfs_dir as *const _ as usize
        },
        2024usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sched_debugfs_dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_queue>())).mq_sysfs_init_done as *const _ as usize
        },
        2032usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_sysfs_init_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).cmd_size as *const _ as usize },
        2040usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(cmd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rq_alloc_data as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rq_alloc_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).release_work as *const _ as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(release_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).write_hints as *const _ as usize },
        2088usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(write_hints)
        )
    );
}
impl Default for request_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_plug {
    pub list: list_head,
    pub mq_list: list_head,
    pub cb_list: list_head,
}
#[test]
fn bindgen_test_layout_blk_plug() {
    assert_eq!(
        ::core::mem::size_of::<blk_plug>(),
        48usize,
        concat!("Size of: ", stringify!(blk_plug))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_plug>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_plug))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_plug>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_plug),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_plug>())).mq_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_plug),
            "::",
            stringify!(mq_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_plug>())).cb_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_plug),
            "::",
            stringify!(cb_list)
        )
    );
}
impl Default for blk_plug {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity_iter {
    pub prot_buf: *mut c_types::c_void,
    pub data_buf: *mut c_types::c_void,
    pub seed: sector_t,
    pub data_size: c_types::c_uint,
    pub interval: c_types::c_ushort,
    pub disk_name: *const c_types::c_char,
}
#[test]
fn bindgen_test_layout_blk_integrity_iter() {
    assert_eq!(
        ::core::mem::size_of::<blk_integrity_iter>(),
        40usize,
        concat!("Size of: ", stringify!(blk_integrity_iter))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_integrity_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_integrity_iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).prot_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(prot_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).data_buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(data_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).seed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).data_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).disk_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(disk_name)
        )
    );
}
impl Default for blk_integrity_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type integrity_processing_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_integrity_iter) -> blk_status_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity_profile {
    pub generate_fn: integrity_processing_fn,
    pub verify_fn: integrity_processing_fn,
    pub name: *const c_types::c_char,
}
#[test]
fn bindgen_test_layout_blk_integrity_profile() {
    assert_eq!(
        ::core::mem::size_of::<blk_integrity_profile>(),
        24usize,
        concat!("Size of: ", stringify!(blk_integrity_profile))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_integrity_profile>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_integrity_profile))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_integrity_profile>())).generate_fn as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_profile),
            "::",
            stringify!(generate_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_integrity_profile>())).verify_fn as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_profile),
            "::",
            stringify!(verify_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_profile>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_profile),
            "::",
            stringify!(name)
        )
    );
}
impl Default for blk_integrity_profile {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device_operations {
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: fmode_t) -> c_types::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk, arg2: fmode_t)>,
    pub rw_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: sector_t,
            arg3: *mut page,
            arg4: bool_,
        ) -> c_types::c_int,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: fmode_t,
            arg3: c_types::c_uint,
            arg4: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: fmode_t,
            arg3: c_types::c_uint,
            arg4: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub check_events: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, clearing: c_types::c_uint) -> c_types::c_uint,
    >,
    pub media_changed:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk) -> c_types::c_int>,
    pub unlock_native_capacity: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk)>,
    pub revalidate_disk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk) -> c_types::c_int>,
    pub getgeo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: *mut hd_geometry) -> c_types::c_int,
    >,
    pub swap_slot_free_notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: c_types::c_ulong),
    >,
    pub owner: *mut module,
    pub pr_ops: *const pr_ops,
}
#[test]
fn bindgen_test_layout_block_device_operations() {
    assert_eq!(
        ::core::mem::size_of::<block_device_operations>(),
        104usize,
        concat!("Size of: ", stringify!(block_device_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).release as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).rw_page as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(rw_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).ioctl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(ioctl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).compat_ioctl as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(compat_ioctl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).check_events as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(check_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).media_changed as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(media_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).unlock_native_capacity as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(unlock_native_capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).revalidate_disk as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(revalidate_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).getgeo as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(getgeo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).swap_slot_free_notify as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(swap_slot_free_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).owner as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).pr_ops as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(pr_ops)
        )
    );
}
impl Default for block_device_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct sbitmap_word - Word in a &struct sbitmap."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sbitmap_word {
    #[doc = " @word: The bitmap word itself."]
    pub word: c_types::c_ulong,
    #[doc = " @depth: Number of bits being used in @word."]
    pub depth: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_sbitmap_word() {
    assert_eq!(
        ::core::mem::size_of::<sbitmap_word>(),
        64usize,
        concat!("Size of: ", stringify!(sbitmap_word))
    );
    assert_eq!(
        ::core::mem::align_of::<sbitmap_word>(),
        64usize,
        concat!("Alignment of ", stringify!(sbitmap_word))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sbitmap_word>())).word as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbitmap_word),
            "::",
            stringify!(word)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sbitmap_word>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sbitmap_word),
            "::",
            stringify!(depth)
        )
    );
}
impl Default for sbitmap_word {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct sbitmap - Scalable bitmap."]
#[doc = ""]
#[doc = " A &struct sbitmap is spread over multiple cachelines to avoid ping-pong. This"]
#[doc = " trades off higher memory usage for better scalability."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbitmap {
    #[doc = " @depth: Number of bits used in the whole bitmap."]
    pub depth: c_types::c_uint,
    #[doc = " @shift: log2(number of bits used per word)"]
    pub shift: c_types::c_uint,
    #[doc = " @map_nr: Number of words (cachelines) being used for the bitmap."]
    pub map_nr: c_types::c_uint,
    #[doc = " @map: Allocated bitmap."]
    pub map: *mut sbitmap_word,
}
#[test]
fn bindgen_test_layout_sbitmap() {
    assert_eq!(
        ::core::mem::size_of::<sbitmap>(),
        24usize,
        concat!("Size of: ", stringify!(sbitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<sbitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(sbitmap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sbitmap>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sbitmap),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sbitmap>())).shift as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sbitmap),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sbitmap>())).map_nr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sbitmap),
            "::",
            stringify!(map_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sbitmap>())).map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sbitmap),
            "::",
            stringify!(map)
        )
    );
}
impl Default for sbitmap {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_tags {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct blk_mq_hw_ctx {
    pub __bindgen_anon_1: blk_mq_hw_ctx__bindgen_ty_1,
    pub run_work: delayed_work,
    pub cpumask: cpumask_var_t,
    pub next_cpu: c_types::c_int,
    pub next_cpu_batch: c_types::c_int,
    pub flags: c_types::c_ulong,
    pub sched_data: *mut c_types::c_void,
    pub queue: *mut request_queue,
    pub fq: *mut blk_flush_queue,
    pub driver_data: *mut c_types::c_void,
    pub ctx_map: sbitmap,
    pub dispatch_from: *mut blk_mq_ctx,
    pub dispatch_busy: c_types::c_uint,
    pub nr_ctx: c_types::c_uint,
    pub ctxs: *mut *mut blk_mq_ctx,
    pub dispatch_wait: wait_queue_entry_t,
    pub wait_index: atomic_t,
    pub tags: *mut blk_mq_tags,
    pub sched_tags: *mut blk_mq_tags,
    pub queued: c_types::c_ulong,
    pub run: c_types::c_ulong,
    pub dispatched: [c_types::c_ulong; 7usize],
    pub numa_node: c_types::c_uint,
    pub queue_num: c_types::c_uint,
    pub nr_active: atomic_t,
    pub cpuhp_dead: hlist_node,
    pub kobj: kobject,
    pub poll_considered: c_types::c_ulong,
    pub poll_invoked: c_types::c_ulong,
    pub poll_success: c_types::c_ulong,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub queue_rq_srcu: __IncompleteArrayField<srcu_struct>,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct blk_mq_hw_ctx__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub dispatch: list_head,
    pub state: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_blk_mq_hw_ctx__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<blk_mq_hw_ctx__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(blk_mq_hw_ctx__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_mq_hw_ctx__bindgen_ty_1>(),
        64usize,
        concat!("Alignment of ", stringify!(blk_mq_hw_ctx__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_mq_hw_ctx__bindgen_ty_1>())).lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx__bindgen_ty_1),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_mq_hw_ctx__bindgen_ty_1>())).dispatch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx__bindgen_ty_1),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_mq_hw_ctx__bindgen_ty_1>())).state as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
}
impl Default for blk_mq_hw_ctx__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_blk_mq_hw_ctx() {
    assert_eq!(
        ::core::mem::size_of::<blk_mq_hw_ctx>(),
        576usize,
        concat!("Size of: ", stringify!(blk_mq_hw_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_mq_hw_ctx>(),
        64usize,
        concat!("Alignment of ", stringify!(blk_mq_hw_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).run_work as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(run_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).cpumask as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(cpumask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).next_cpu as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(next_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).next_cpu_batch as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(next_cpu_batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).flags as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).sched_data as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(sched_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).queue as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).fq as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(fq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).driver_data as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(driver_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).ctx_map as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(ctx_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).dispatch_from as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(dispatch_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).dispatch_busy as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(dispatch_busy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).nr_ctx as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(nr_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).ctxs as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(ctxs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).dispatch_wait as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(dispatch_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).wait_index as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(wait_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).tags as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).sched_tags as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(sched_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).queued as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(queued)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).run as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).dispatched as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(dispatched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).numa_node as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).queue_num as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(queue_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).nr_active as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(nr_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).cpuhp_dead as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(cpuhp_dead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).kobj as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).poll_considered as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(poll_considered)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).poll_invoked as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(poll_invoked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).poll_success as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(poll_success)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).debugfs_dir as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(debugfs_dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_mq_hw_ctx>())).sched_debugfs_dir as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(sched_debugfs_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_hw_ctx>())).queue_rq_srcu as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_hw_ctx),
            "::",
            stringify!(queue_rq_srcu)
        )
    );
}
impl Default for blk_mq_hw_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_tag_set {
    pub mq_map: *mut c_types::c_uint,
    pub ops: *const blk_mq_ops,
    pub nr_hw_queues: c_types::c_uint,
    pub queue_depth: c_types::c_uint,
    pub reserved_tags: c_types::c_uint,
    pub cmd_size: c_types::c_uint,
    pub numa_node: c_types::c_int,
    pub timeout: c_types::c_uint,
    pub flags: c_types::c_uint,
    pub driver_data: *mut c_types::c_void,
    pub tags: *mut *mut blk_mq_tags,
    pub tag_list_lock: mutex,
    pub tag_list: list_head,
}
#[test]
fn bindgen_test_layout_blk_mq_tag_set() {
    assert_eq!(
        ::core::mem::size_of::<blk_mq_tag_set>(),
        112usize,
        concat!("Size of: ", stringify!(blk_mq_tag_set))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_mq_tag_set>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_mq_tag_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).mq_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(mq_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).nr_hw_queues as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(nr_hw_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).queue_depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(queue_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).reserved_tags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(reserved_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).cmd_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(cmd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).numa_node as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).timeout as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).driver_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(driver_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).tags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).tag_list_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(tag_list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_tag_set>())).tag_list as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_tag_set),
            "::",
            stringify!(tag_list)
        )
    );
}
impl Default for blk_mq_tag_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_queue_data {
    pub rq: *mut request,
    pub last: bool_,
}
#[test]
fn bindgen_test_layout_blk_mq_queue_data() {
    assert_eq!(
        ::core::mem::size_of::<blk_mq_queue_data>(),
        16usize,
        concat!("Size of: ", stringify!(blk_mq_queue_data))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_mq_queue_data>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_mq_queue_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_queue_data>())).rq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_queue_data),
            "::",
            stringify!(rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_queue_data>())).last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_queue_data),
            "::",
            stringify!(last)
        )
    );
}
impl Default for blk_mq_queue_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type queue_rq_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: *const blk_mq_queue_data) -> blk_status_t,
>;
pub type get_budget_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> bool_>;
pub type put_budget_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>;
pub type timeout_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request, arg2: bool_) -> blk_eh_timer_return,
>;
pub type init_hctx_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut blk_mq_hw_ctx,
        arg2: *mut c_types::c_void,
        arg3: c_types::c_uint,
    ) -> c_types::c_int,
>;
pub type exit_hctx_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: c_types::c_uint)>;
pub type init_request_fn = ::core::option::Option<
    unsafe extern "C" fn(
        set: *mut blk_mq_tag_set,
        arg1: *mut request,
        arg2: c_types::c_uint,
        arg3: c_types::c_uint,
    ) -> c_types::c_int,
>;
pub type exit_request_fn = ::core::option::Option<
    unsafe extern "C" fn(set: *mut blk_mq_tag_set, arg1: *mut request, arg2: c_types::c_uint),
>;
pub type poll_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: c_types::c_uint) -> c_types::c_int,
>;
pub type map_queues_fn =
    ::core::option::Option<unsafe extern "C" fn(set: *mut blk_mq_tag_set) -> c_types::c_int>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_mq_ops {
    pub queue_rq: queue_rq_fn,
    pub get_budget: get_budget_fn,
    pub put_budget: put_budget_fn,
    pub timeout: timeout_fn,
    pub poll: poll_fn,
    pub complete: softirq_done_fn,
    pub init_hctx: init_hctx_fn,
    pub exit_hctx: exit_hctx_fn,
    pub init_request: init_request_fn,
    pub exit_request: exit_request_fn,
    pub initialize_rq_fn: ::core::option::Option<unsafe extern "C" fn(rq: *mut request)>,
    pub map_queues: map_queues_fn,
    pub show_rq: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, rq: *mut request)>,
}
#[test]
fn bindgen_test_layout_blk_mq_ops() {
    assert_eq!(
        ::core::mem::size_of::<blk_mq_ops>(),
        104usize,
        concat!("Size of: ", stringify!(blk_mq_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_mq_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_mq_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).queue_rq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(queue_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).get_budget as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(get_budget)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).put_budget as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(put_budget)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).timeout as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).poll as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).complete as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).init_hctx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(init_hctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).exit_hctx as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(exit_hctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).init_request as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(init_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).exit_request as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(exit_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).initialize_rq_fn as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(initialize_rq_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).map_queues as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(map_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_mq_ops>())).show_rq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_mq_ops),
            "::",
            stringify!(show_rq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut c_types::c_void,
    pub iov_len: __kernel_size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::core::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut c_types::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_kvec() {
    assert_eq!(
        ::core::mem::size_of::<kvec>(),
        16usize,
        concat!("Size of: ", stringify!(kvec))
    );
    assert_eq!(
        ::core::mem::align_of::<kvec>(),
        8usize,
        concat!("Alignment of ", stringify!(kvec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kvec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kvec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kvec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kvec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for kvec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter {
    pub type_: c_types::c_int,
    pub iov_offset: usize,
    pub count: usize,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1 {
    pub iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub pipe: *mut pipe_inode_info,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_iov_iter__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<iov_iter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(iov_iter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<iov_iter__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(iov_iter__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).iov as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_1),
            "::",
            stringify!(iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).kvec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_1),
            "::",
            stringify!(kvec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).bvec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_1),
            "::",
            stringify!(bvec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).pipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_1),
            "::",
            stringify!(pipe)
        )
    );
}
impl Default for iov_iter__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub nr_segs: c_types::c_ulong,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iov_iter__bindgen_ty_2__bindgen_ty_1 {
    pub idx: c_types::c_int,
    pub start_idx: c_types::c_int,
}
#[test]
fn bindgen_test_layout_iov_iter__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<iov_iter__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<iov_iter__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1>())).idx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1>())).start_idx as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(start_idx)
        )
    );
}
#[test]
fn bindgen_test_layout_iov_iter__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<iov_iter__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(iov_iter__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<iov_iter__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(iov_iter__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_2>())).nr_segs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_2),
            "::",
            stringify!(nr_segs)
        )
    );
}
impl Default for iov_iter__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_iov_iter() {
    assert_eq!(
        ::core::mem::size_of::<iov_iter>(),
        40usize,
        concat!("Size of: ", stringify!(iov_iter))
    );
    assert_eq!(
        ::core::mem::align_of::<iov_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(iov_iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter>())).iov_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter),
            "::",
            stringify!(iov_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter),
            "::",
            stringify!(count)
        )
    );
}
impl Default for iov_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "\tstruct pipe_buffer - a linux kernel pipe buffer"]
#[doc = "\t@page: the page containing the data for the pipe buffer"]
#[doc = "\t@offset: offset of data inside the @page"]
#[doc = "\t@len: length of data inside the @page"]
#[doc = "\t@ops: operations associated with this buffer. See @pipe_buf_operations."]
#[doc = "\t@flags: pipe buffer flags. See above."]
#[doc = "\t@private: private data owned by the ops."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_buffer {
    pub page: *mut page,
    pub offset: c_types::c_uint,
    pub len: c_types::c_uint,
    pub ops: *const pipe_buf_operations,
    pub flags: c_types::c_uint,
    pub private: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_pipe_buffer() {
    assert_eq!(
        ::core::mem::size_of::<pipe_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(pipe_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<pipe_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(pipe_buffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).private as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(private)
        )
    );
}
impl Default for pipe_buffer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "\tstruct pipe_inode_info - a linux kernel pipe"]
#[doc = "\t@mutex: mutex protecting the whole thing"]
#[doc = "\t@wait: reader/writer wait point in case of empty/full pipe"]
#[doc = "\t@nrbufs: the number of non-empty pipe buffers in this pipe"]
#[doc = "\t@buffers: total number of buffers (should be a power of 2)"]
#[doc = "\t@curbuf: the current pipe buffer entry"]
#[doc = "\t@tmp_page: cached released page"]
#[doc = "\t@readers: number of current readers of this pipe"]
#[doc = "\t@writers: number of current writers of this pipe"]
#[doc = "\t@files: number of struct file referring this pipe (protected by ->i_lock)"]
#[doc = "\t@waiting_writers: number of writers blocked waiting for room"]
#[doc = "\t@r_counter: reader counter"]
#[doc = "\t@w_counter: writer counter"]
#[doc = "\t@fasync_readers: reader side fasync"]
#[doc = "\t@fasync_writers: writer side fasync"]
#[doc = "\t@bufs: the circular array of pipe buffers"]
#[doc = "\t@user: the user who created this pipe"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_inode_info {
    pub mutex: mutex,
    pub wait: wait_queue_head_t,
    pub nrbufs: c_types::c_uint,
    pub curbuf: c_types::c_uint,
    pub buffers: c_types::c_uint,
    pub readers: c_types::c_uint,
    pub writers: c_types::c_uint,
    pub files: c_types::c_uint,
    pub waiting_writers: c_types::c_uint,
    pub r_counter: c_types::c_uint,
    pub w_counter: c_types::c_uint,
    pub tmp_page: *mut page,
    pub fasync_readers: *mut fasync_struct,
    pub fasync_writers: *mut fasync_struct,
    pub bufs: *mut pipe_buffer,
    pub user: *mut user_struct,
}
#[test]
fn bindgen_test_layout_pipe_inode_info() {
    assert_eq!(
        ::core::mem::size_of::<pipe_inode_info>(),
        136usize,
        concat!("Size of: ", stringify!(pipe_inode_info))
    );
    assert_eq!(
        ::core::mem::align_of::<pipe_inode_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pipe_inode_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).wait as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).nrbufs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(nrbufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).curbuf as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(curbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).buffers as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).readers as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).writers as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).files as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pipe_inode_info>())).waiting_writers as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(waiting_writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).r_counter as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(r_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).w_counter as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(w_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).tmp_page as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(tmp_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).fasync_readers as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(fasync_readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).fasync_writers as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(fasync_writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).bufs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).user as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(user)
        )
    );
}
impl Default for pipe_inode_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pipe_buf_operations {
    pub can_merge: c_types::c_int,
    pub confirm: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> c_types::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer),
    >,
    pub steal: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> c_types::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
    >,
}
#[test]
fn bindgen_test_layout_pipe_buf_operations() {
    assert_eq!(
        ::core::mem::size_of::<pipe_buf_operations>(),
        40usize,
        concat!("Size of: ", stringify!(pipe_buf_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<pipe_buf_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(pipe_buf_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).can_merge as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(can_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).confirm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(confirm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).steal as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(steal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).get as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(get)
        )
    );
}
pub const BINDINGS_GFP_KERNEL: gfp_t = 20971712;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_sect_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_notes_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct trace_event_call {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct trace_eval_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct static_key_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldt_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uprobe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct userfaultfd_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mmu_notifier_mm {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct assoc_array_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct key_user {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sem_undo_list {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct css_set {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct compat_robust_list_head {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct numa_group {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ftrace_ret_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_qos {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct irq_domain {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dma_coherent_mem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_param_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timer_rand_state {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_mq_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct throtl_data {
    pub _address: u8,
}
